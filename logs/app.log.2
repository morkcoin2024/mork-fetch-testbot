2025-08-10 09:03:03,197 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:03:03,200 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:03:03,854 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:03:19,037 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:03:19,041 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:03:19,711 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:05:25,482 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:05:25,485 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:05:26,233 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:05:33,904 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:05:33,907 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:05:35,666 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:05:42,040 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:05:42,043 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:05:42,898 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:06:12,200 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:06:12,203 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:06:13,047 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:06:36,814 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:06:36,817 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:06:37,510 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:07:01,792 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:07:01,795 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:07:02,501 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:07:07,877 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:07:07,880 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:07:08,604 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:17:30,100 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:17:30,102 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:17:30,860 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:17:37,960 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:17:37,963 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:17:38,678 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:21:15,053 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:21:15,057 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:21:15,797 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:21:19,970 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:21:19,974 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:21:20,647 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:25:21,163 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:25:21,166 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:25:22,022 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:25:24,197 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:25:24,201 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:25:25,046 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:25:34,799 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:25:34,801 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:25:35,478 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:25:55,061 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:25:55,066 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:25:55,928 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:26:27,205 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:26:27,208 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:26:27,933 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:26:49,249 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:26:49,251 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:26:50,048 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:27:00,183 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:27:00,186 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:27:00,909 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:35:24,805 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:35:24,809 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:35:25,461 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:35:28,618 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:35:28,621 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:35:29,446 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:35:53,191 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:35:53,194 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:35:53,858 [INFO] bot: Assistant system active - Telegram bot disabled
2025-08-10 09:36:36,255 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:36:36,259 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:36:37,158 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:36:48,409 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:36:48,413 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:36:49,204 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:36:49,213 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:36:49,214 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 123456789, 'username': 'testuser'}, 'chat': {'id': 123456789}, 'text': '/ping'}}
2025-08-10 09:36:49,214 [WARNING] app: [WEBHOOK] Telegram bot functionality disabled
2025-08-10 09:36:57,393 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:36:57,396 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:36:58,384 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:37:10,625 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:37:10,628 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:37:11,462 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:37:11,909 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:37:11,910 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 09:37:11,913 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:37:11,913 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/ping'
2025-08-10 09:37:11,914 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 09:37:12,480 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 09:37:13,222 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:37:13,222 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/status'}}
2025-08-10 09:37:13,222 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:37:13,223 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/status'
2025-08-10 09:37:13,223 [INFO] app: [WEBHOOK] Admin command detected: /status
2025-08-10 09:37:13,604 [INFO] app: [WEBHOOK] Command '/status' processed, response sent: 200
2025-08-10 09:37:15,646 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:37:15,647 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_whoami'}}
2025-08-10 09:37:15,647 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:37:15,648 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_whoami'
2025-08-10 09:37:15,648 [INFO] app: [WEBHOOK] Admin command detected: /a_whoami
2025-08-10 09:37:16,017 [INFO] app: [WEBHOOK] Command '/a_whoami' processed, response sent: 200
2025-08-10 09:37:22,517 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:37:22,517 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/help'}}
2025-08-10 09:37:22,517 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:37:22,517 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/help'
2025-08-10 09:37:22,517 [INFO] app: [WEBHOOK] Admin command detected: /help
2025-08-10 09:37:22,885 [INFO] app: [WEBHOOK] Command '/help' processed, response sent: 200
2025-08-10 09:37:38,235 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:37:38,239 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:37:39,036 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:39:46,141 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:39:46,141 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 09:39:46,142 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:39:46,142 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/ping'
2025-08-10 09:39:46,142 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 09:39:46,558 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 09:39:53,910 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:39:53,910 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'test'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 09:39:53,910 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:39:53,910 [INFO] app: [WEBHOOK] Message from test (1653046781): '/ping'
2025-08-10 09:39:53,910 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 09:39:54,287 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 09:40:18,099 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:18,100 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121102, 'message': {'message_id': 3975, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818361, 'text': '/a_ping', 'entities': [{'offset': 0, 'length': 7, 'type': 'bot_command'}]}}
2025-08-10 09:40:18,100 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:18,100 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_ping'
2025-08-10 09:40:18,100 [INFO] app: [WEBHOOK] Admin command detected: /a_ping
2025-08-10 09:40:18,479 [INFO] app: [WEBHOOK] Command '/a_ping' processed, response sent: 200
2025-08-10 09:40:18,596 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:18,598 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121103, 'message': {'message_id': 3976, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818382, 'text': '/a_whoami', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:40:18,598 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:18,599 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_whoami'
2025-08-10 09:40:18,599 [INFO] app: [WEBHOOK] Admin command detected: /a_whoami
2025-08-10 09:40:18,966 [INFO] app: [WEBHOOK] Command '/a_whoami' processed, response sent: 200
2025-08-10 09:40:19,087 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:19,089 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121104, 'message': {'message_id': 3977, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818391, 'text': '/a_status', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:40:19,089 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:19,091 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_status'
2025-08-10 09:40:19,094 [INFO] app: [WEBHOOK] Admin command detected: /a_status
2025-08-10 09:40:19,487 [INFO] app: [WEBHOOK] Command '/a_status' processed, response sent: 200
2025-08-10 09:40:19,606 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:19,608 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121105, 'message': {'message_id': 3978, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818411, 'text': '/a_logs_tail 120', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:40:19,610 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:19,612 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120'
2025-08-10 09:40:19,613 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120
2025-08-10 09:40:19,614 [INFO] app: [WEBHOOK] Unknown admin command: /a_logs_tail 120
2025-08-10 09:40:19,733 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:19,735 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121106, 'message': {'message_id': 3983, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818720, 'text': '/a_ping', 'entities': [{'offset': 0, 'length': 7, 'type': 'bot_command'}]}}
2025-08-10 09:40:19,736 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:19,741 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_ping'
2025-08-10 09:40:19,745 [INFO] app: [WEBHOOK] Admin command detected: /a_ping
2025-08-10 09:40:20,127 [INFO] app: [WEBHOOK] Command '/a_ping' processed, response sent: 200
2025-08-10 09:40:20,248 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:20,250 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121107, 'message': {'message_id': 3984, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818732, 'text': '/a_whoami', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:40:20,252 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:20,254 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_whoami'
2025-08-10 09:40:20,255 [INFO] app: [WEBHOOK] Admin command detected: /a_whoami
2025-08-10 09:40:20,640 [INFO] app: [WEBHOOK] Command '/a_whoami' processed, response sent: 200
2025-08-10 09:40:20,812 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:20,817 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121108, 'message': {'message_id': 3985, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818733, 'text': '/a_status', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:40:20,820 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:20,824 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_status'
2025-08-10 09:40:20,826 [INFO] app: [WEBHOOK] Admin command detected: /a_status
2025-08-10 09:40:21,246 [INFO] app: [WEBHOOK] Command '/a_status' processed, response sent: 200
2025-08-10 09:40:21,365 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:21,369 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121109, 'message': {'message_id': 3986, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818734, 'text': '/a_logs_tail', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:40:21,370 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:21,370 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail'
2025-08-10 09:40:21,370 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail
2025-08-10 09:40:21,370 [INFO] app: [WEBHOOK] Unknown admin command: /a_logs_tail
2025-08-10 09:40:58,054 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:58,054 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121110, 'message': {'message_id': 3995, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818857, 'text': '/a_ping', 'entities': [{'offset': 0, 'length': 7, 'type': 'bot_command'}]}}
2025-08-10 09:40:58,054 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:58,054 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_ping'
2025-08-10 09:40:58,054 [INFO] app: [WEBHOOK] Admin command detected: /a_ping
2025-08-10 09:40:58,421 [INFO] app: [WEBHOOK] Command '/a_ping' processed, response sent: 200
2025-08-10 09:40:59,651 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:40:59,652 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121111, 'message': {'message_id': 3997, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818859, 'text': '/a_whoami', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:40:59,652 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:40:59,652 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_whoami'
2025-08-10 09:40:59,652 [INFO] app: [WEBHOOK] Admin command detected: /a_whoami
2025-08-10 09:41:00,019 [INFO] app: [WEBHOOK] Command '/a_whoami' processed, response sent: 200
2025-08-10 09:41:01,164 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:41:01,164 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121112, 'message': {'message_id': 3999, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818861, 'text': '/a_status', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 09:41:01,164 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:41:01,165 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_status'
2025-08-10 09:41:01,165 [INFO] app: [WEBHOOK] Admin command detected: /a_status
2025-08-10 09:41:01,531 [INFO] app: [WEBHOOK] Command '/a_status' processed, response sent: 200
2025-08-10 09:41:02,707 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:41:02,707 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121113, 'message': {'message_id': 4001, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754818862, 'text': '/a_logs_tail', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:41:02,707 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:41:02,707 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail'
2025-08-10 09:41:02,707 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail
2025-08-10 09:41:02,707 [INFO] app: [WEBHOOK] Unknown admin command: /a_logs_tail
2025-08-10 09:42:28,962 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:42:28,967 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:42:29,764 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:42:30,925 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:42:30,926 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail'}}
2025-08-10 09:42:30,926 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:42:30,926 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_logs_tail'
2025-08-10 09:42:30,926 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail
2025-08-10 09:42:31,341 [INFO] app: [WEBHOOK] Command '/a_logs_tail' processed, response sent: 200
2025-08-10 09:42:32,435 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:42:32,436 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_mode'}}
2025-08-10 09:42:32,436 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:42:32,436 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_mode'
2025-08-10 09:42:32,436 [INFO] app: [WEBHOOK] Admin command detected: /a_mode
2025-08-10 09:42:32,813 [INFO] app: [WEBHOOK] Command '/a_mode' processed, response sent: 200
2025-08-10 09:42:39,233 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:42:39,236 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:42:39,888 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:46:09,150 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:46:09,153 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:46:09,882 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:46:11,022 [INFO] root: Boot: logging to logs/app.log
2025-08-10 09:46:11,026 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:46:11,782 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:46:12,959 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:46:12,961 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail 30'}}
2025-08-10 09:46:12,962 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:46:12,962 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_logs_tail 30'
2025-08-10 09:46:12,963 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 30
2025-08-10 09:46:13,410 [INFO] app: [WEBHOOK] Command '/a_logs_tail 30' processed, response sent: 200
2025-08-10 09:46:14,539 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:46:14,540 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail level=info'}}
2025-08-10 09:46:14,541 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:46:14,541 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_logs_tail level=info'
2025-08-10 09:46:14,541 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail level=info
2025-08-10 09:46:14,974 [INFO] app: [WEBHOOK] Command '/a_logs_tail level=info' processed, response sent: 200
2025-08-10 09:47:21,365 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:21,365 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:21,366 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 09:47:21,368 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:47:22,105 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:47:41,493 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:41,493 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:41,494 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 09:47:41,498 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:47:42,585 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:47:49,252 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:51,074 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:47:51,074 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail 20'}}
2025-08-10 09:47:51,074 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:47:51,075 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_logs_tail 20'
2025-08-10 09:47:51,075 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 20
2025-08-10 09:47:51,539 [INFO] app: [WEBHOOK] Command '/a_logs_tail 20' processed, response sent: 200
2025-08-10 09:47:52,328 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:52,328 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:47:52,329 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 09:47:52,332 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 09:47:53,054 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 09:49:30,838 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:49:30,841 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 09:49:31,143 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:49:31,144 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'test'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail 5'}}
2025-08-10 09:49:31,144 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:49:31,145 [INFO] app: [WEBHOOK] Message from test (1653046781): '/a_logs_tail 5'
2025-08-10 09:49:31,145 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 5
2025-08-10 09:49:31,589 [INFO] app: [WEBHOOK] Command '/a_logs_tail 5' processed, response sent: 200
2025-08-10 09:49:38,048 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 09:49:38,049 [INFO] root: Ring buffer test entry 1
2025-08-10 09:49:38,050 [WARNING] root: Ring buffer test entry 2
2025-08-10 09:49:38,050 [ERROR] root: Ring buffer test entry 3
2025-08-10 09:49:38,052 [INFO] root: Ring buffer test entry 4
2025-08-10 09:49:38,108 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 09:49:38,109 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_logs_tail 10 level=info'}}
2025-08-10 09:49:38,109 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:49:38,109 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_logs_tail 10 level=info'
2025-08-10 09:49:38,109 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 10 level=info
2025-08-10 09:49:38,542 [INFO] app: [WEBHOOK] Command '/a_logs_tail 10 level=info' processed, response sent: 200
2025-08-10 09:52:33,360 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:52:33,360 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121114, 'message': {'message_id': 4009, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819552, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 09:52:33,361 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:52:33,361 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 09:52:33,361 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 09:52:33,361 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 09:52:38,094 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:52:38,094 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121115, 'message': {'message_id': 4010, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819558, 'text': 'Implement ring-buffer logging + upgraded /a_logs_tail in one patch.\n\nGOALS\n- Always have logs to tail even before files exist (ring buffer).\n- /a_logs_tail supports:\n  • line count: plain number or n= (default 200; clamp 10..2000)\n  • level filter: level=error|warn|info|all  (default all)\n  • multi-source combine: sources=app,webhook,router,trading (merge tails, sort by timestamp)\n  • safe chunking under Telegram limits\n- Keep existing webhook flow and other admin commands intact.\n\nCHANGES\n\n1) main.py – add robust logging (file + ring buffer)\n- Near the top, before the app starts, insert (or update) this exact block. If a similar block exists, merge without duplicating handlers:\n\n# ---- robust logging: file + ring buffer ----\nimport logging, pathlib\nfrom logging.handlers import RotatingFileHandler\nfrom collections import deque\n\npathlib.Path("logs").mkdir(exist_ok=True)\nLOG_FILE = "logs/app.log"\n\nclass RingBufferHandler(logging.Handler):\n    """Keeps the last N formatted log lines in memory for /a_logs_tail fallback."""\n    def __init__(self, capacity=12000):\n        super().__init__()\n        self.buffer = deque(maxlen=capacity)\n    def emit(self, record):\n        try:\n            self.buffer.append(self.format(record))\n        except Exception:\n            pass\n\nroot = logging.getLogger()\nroot.setLevel(logging.INFO)\nfmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")\n\n# Attach once\nif not any(isinstance(h, RotatingFileHandler) for h in root.handlers):\n    fh = RotatingFileHandler(LOG_FILE, maxBytes=1_000_000, backupCount=3, encoding="utf-8")\n    fh.setFormatter(fmt)\n    root.addHandler(fh)\n\nif not any(isinstance(h, RingBufferHandler) for h in root.handlers):\n    rb = RingBufferHandler(capacity=12000)\n    rb.setFormatter(fmt)\n    root.addHandler(rb)\n\nlogging.info("Boot logging ready: file=%s + ring-buffer", LOG_FILE)\n\n2) alerts/telegram.py – enhance /a_logs_tail\n- Ensure these imports are present at top: \n  import glob, datetime, asyncio, pathlib, logging, re\n  from telegram.constants import ParseMode\n\n- Add this helper (if missing):\n\ndef _read_ring_tail(n_lines: int) -> str:\n    lg = logging.getLogger()\n    for h in lg.handlers:\n        if h.__class__.__name__ == "RingBufferHandler":\n            lines = list(h.buffer)[-n_lines:]\n            return "\\n".join(lines)\n    return "(no ring buffer logs available)"\n\n- Add helpers for args/levels/sources/timestamps:\n\nLEVEL_ORDER = {"error": 40, "warn": 30, "warning": 30, "info": 20, "all": 0}\n\ndef _parse_tail_args(args):\n    n = 200\n    level = "all"\n    sources = []  # [] => auto-detect logs/*.log\n    for a in (args or []):\n        a = a.strip()\n        if a.isdigit():\n            n = max(10, min(2000, int(a))); continue\n        if a.startswith("n="):\n            try: n = max(10, min(2000, int(a.split("=",1)[1])))\n            except: pass\n            continue\n        if a.startswith("level="):\n            lvl = a.split("=",1)[1].lower()\n            if lvl in LEVEL_ORDER: level = lvl\n            continue\n        if a.startswith("sources="):\n            sources = [s.strip() for s in a.split("=",1)[1].split(",") if s.strip()]\n            continue\n    return n, level, sources\n\ndef _level_from_line(line: str) -> int:\n    l = line.lower()\n    if "[error]" in l: return 40\n    if "[warning]" in l or " warn" in l: return 30\n    if "[info]" in l: return 20\n    return 10\n\ndef _extract_ts(line: str):\n    try:\n        ts = line.split(" [", 1)[0]\n        return datetime.datetime.strptime(ts, "%Y-%m-%d %H:%M:%S,%f")\n    except Exception:\n        return datetime.datetime.utcnow()\n\ndef _read_tail_file(path: pathlib.Path, n_lines: int):\n    if not path.exists(): return []\n    raw = _tail_lines(path, n_lines)  # use existing helper that tails a single file\n    return [(_extract_ts(ln), ln) for ln in raw.splitlines() if ln.strip()]', 'entities': [{'offset': 41, 'length': 12, 'type': 'bot_command'}, {'offset': 143, 'length': 12, 'type': 'bot_command'}, {'offset': 499, 'length': 7, 'type': 'url'}, {'offset': 1009, 'length': 12, 'type': 'bot_command'}, {'offset': 1325, 'length': 12, 'type': 'url'}, {'offset': 1806, 'length': 12, 'type': 'url'}, {'offset': 1885, 'length': 11, 'type': 'url'}, {'offset': 1907, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:52:38,094 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:52:38,094 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Implement ring-buffer logging + upgraded /a_logs_tail in one patch.

GOALS
- Always have logs to tail even before files exist (ring buffer).
- /a_logs_tail supports:
  • line count: plain number or n= (default 200; clamp 10..2000)
  • level filter: level=error|warn|info|all  (default all)
  • multi-source combine: sources=app,webhook,router,trading (merge tails, sort by timestamp)
  • safe chunking under Telegram limits
- Keep existing webhook flow and other admin commands intact.

CHANGES

1) main.py – add robust logging (file + ring buffer)
- Near the top, before the app starts, insert (or update) this exact block. If a similar block exists, merge without duplicating handlers:

# ---- robust logging: file + ring buffer ----
import logging, pathlib
from logging.handlers import RotatingFileHandler
from collections import deque

pathlib.Path("logs").mkdir(exist_ok=True)
LOG_FILE = "logs/app.log"

class RingBufferHandler(logging.Handler):
    """Keeps the last N formatted log lines in memory for /a_logs_tail fallback."""
    def __init__(self, capacity=12000):
        super().__init__()
        self.buffer = deque(maxlen=capacity)
    def emit(self, record):
        try:
            self.buffer.append(self.format(record))
        except Exception:
            pass

root = logging.getLogger()
root.setLevel(logging.INFO)
fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")

# Attach once
if not any(isinstance(h, RotatingFileHandler) for h in root.handlers):
    fh = RotatingFileHandler(LOG_FILE, maxBytes=1_000_000, backupCount=3, encoding="utf-8")
    fh.setFormatter(fmt)
    root.addHandler(fh)

if not any(isinstance(h, RingBufferHandler) for h in root.handlers):
    rb = RingBufferHandler(capacity=12000)
    rb.setFormatter(fmt)
    root.addHandler(rb)

logging.info("Boot logging ready: file=%s + ring-buffer", LOG_FILE)

2) alerts/telegram.py – enhance /a_logs_tail
- Ensure these imports are present at top: 
  import glob, datetime, asyncio, pathlib, logging, re
  from telegram.constants import ParseMode

- Add this helper (if missing):

def _read_ring_tail(n_lines: int) -> str:
    lg = logging.getLogger()
    for h in lg.handlers:
        if h.__class__.__name__ == "RingBufferHandler":
            lines = list(h.buffer)[-n_lines:]
            return "\n".join(lines)
    return "(no ring buffer logs available)"

- Add helpers for args/levels/sources/timestamps:

LEVEL_ORDER = {"error": 40, "warn": 30, "warning": 30, "info": 20, "all": 0}

def _parse_tail_args(args):
    n = 200
    level = "all"
    sources = []  # [] => auto-detect logs/*.log
    for a in (args or []):
        a = a.strip()
        if a.isdigit():
            n = max(10, min(2000, int(a))); continue
        if a.startswith("n="):
            try: n = max(10, min(2000, int(a.split("=",1)[1])))
            except: pass
            continue
        if a.startswith("level="):
            lvl = a.split("=",1)[1].lower()
            if lvl in LEVEL_ORDER: level = lvl
            continue
        if a.startswith("sources="):
            sources = [s.strip() for s in a.split("=",1)[1].split(",") if s.strip()]
            continue
    return n, level, sources

def _level_from_line(line: str) -> int:
    l = line.lower()
    if "[error]" in l: return 40
    if "[warning]" in l or " warn" in l: return 30
    if "[info]" in l: return 20
    return 10

def _extract_ts(line: str):
    try:
        ts = line.split(" [", 1)[0]
        return datetime.datetime.strptime(ts, "%Y-%m-%d %H:%M:%S,%f")
    except Exception:
        return datetime.datetime.utcnow()

def _read_tail_file(path: pathlib.Path, n_lines: int):
    if not path.exists(): return []
    raw = _tail_lines(path, n_lines)  # use existing helper that tails a single file
    return [(_extract_ts(ln), ln) for ln in raw.splitlines() if ln.strip()]'
2025-08-10 09:52:38,218 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:52:38,218 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121116, 'message': {'message_id': 4011, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819558, 'text': 'def _gather_sources(sources):\n    name_map = {\n        "app": pathlib.Path("logs/app.log"),\n        "webhook": pathlib.Path("logs/webhook.log"),\n        "router": pathlib.Path("logs/router.log"),\n        "trading": pathlib.Path("logs/trading.log"),\n    }\n    if sources:\n        return [p for k,p in name_map.items() if k in sources]\n    files = [pathlib.Path(p) for p in glob.glob("logs/*.log")]\n    return files or [pathlib.Path("logs/app.log")]\n\n- Replace the existing cmd_logs_tail with this async version:\n\nasync def cmd_logs_tail(update, context):\n    if not _is_admin(update):\n        return await update.message.reply_text("Not authorized.")\n    n, level, sources = _parse_tail_args(context.args)\n    files = _gather_sources(sources)\n\n    rows = []\n    for f in files:\n        try:\n            rows.extend(_read_tail_file(f, n))\n        except Exception as e:\n            rows.append((datetime.datetime.utcnow(), f"(read error {f}: {e})"))\n\n    # If no file rows, fall back to ring buffer immediately\n    if not rows:\n        text = _read_ring_tail(n)\n        if not text or text.startswith("(no ring"):\n            text = "(no file logs yet; showing in-memory ring buffer)\\n" + _read_ring_tail(n)\n        while text:\n            chunk = text[:3500]; text = text[3500:]\n            await update.message.reply_text(f"```\\n{chunk}\\n```", parse_mode=ParseMode.MARKDOWN)\n            if text: await asyncio.sleep(0.1)\n        return\n\n    # Sort + level filter\n    rows.sort(key=lambda x: x[0])\n    min_level = LEVEL_ORDER.get(level, 0)\n    filtered = [ln for ts, ln in rows if _level_from_line(ln) >= min_level]\n    header = f"(level>={level}; combined from {\', \'.join(str(f) for f in files)})\\n"\n    if not filtered:\n        filtered = [ln for ts, ln in rows]\n        header = f"(no lines matched level={level}; showing recent combined tail)\\n"\n\n    text = header + "\\n".join(filtered[-n:]) if filtered else header + "(no logs found)"\n    while text:\n        chunk = text[:3500]; text = text[3500:]\n        await update.message.reply_text(f"```\\n{chunk}\\n```", parse_mode=ParseMode.MARKDOWN)\n        if text: await asyncio.sleep(0.1)\n\nVALIDATION\n- Restart app.\n- Run:\n  1) /a_logs_tail                -> should show recent logs from logs/*.log or ring buffer\n  2) /a_logs_tail 100            -> exactly ~100 lines (capped)\n  3) /a_logs_tail level=warn     -> only warnings/errors (or fallback notice)\n  4) /a_logs_tail 300 level=error sources=app,trading -> merged + filtered\n- Ensure responses are chunked and under Telegram limits.\n- No behavior changes for other admin commands.', 'entities': [{'offset': 2177, 'length': 12, 'type': 'bot_command'}, {'offset': 2268, 'length': 12, 'type': 'bot_command'}, {'offset': 2332, 'length': 12, 'type': 'bot_command'}, {'offset': 2410, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:52:38,218 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:52:38,219 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def _gather_sources(sources):
    name_map = {
        "app": pathlib.Path("logs/app.log"),
        "webhook": pathlib.Path("logs/webhook.log"),
        "router": pathlib.Path("logs/router.log"),
        "trading": pathlib.Path("logs/trading.log"),
    }
    if sources:
        return [p for k,p in name_map.items() if k in sources]
    files = [pathlib.Path(p) for p in glob.glob("logs/*.log")]
    return files or [pathlib.Path("logs/app.log")]

- Replace the existing cmd_logs_tail with this async version:

async def cmd_logs_tail(update, context):
    if not _is_admin(update):
        return await update.message.reply_text("Not authorized.")
    n, level, sources = _parse_tail_args(context.args)
    files = _gather_sources(sources)

    rows = []
    for f in files:
        try:
            rows.extend(_read_tail_file(f, n))
        except Exception as e:
            rows.append((datetime.datetime.utcnow(), f"(read error {f}: {e})"))

    # If no file rows, fall back to ring buffer immediately
    if not rows:
        text = _read_ring_tail(n)
        if not text or text.startswith("(no ring"):
            text = "(no file logs yet; showing in-memory ring buffer)\n" + _read_ring_tail(n)
        while text:
            chunk = text[:3500]; text = text[3500:]
            await update.message.reply_text(f"```\n{chunk}\n```", parse_mode=ParseMode.MARKDOWN)
            if text: await asyncio.sleep(0.1)
        return

    # Sort + level filter
    rows.sort(key=lambda x: x[0])
    min_level = LEVEL_ORDER.get(level, 0)
    filtered = [ln for ts, ln in rows if _level_from_line(ln) >= min_level]
    header = f"(level>={level}; combined from {', '.join(str(f) for f in files)})\n"
    if not filtered:
        filtered = [ln for ts, ln in rows]
        header = f"(no lines matched level={level}; showing recent combined tail)\n"

    text = header + "\n".join(filtered[-n:]) if filtered else header + "(no logs found)"
    while text:
        chunk = text[:3500]; text = text[3500:]
        await update.message.reply_text(f"```\n{chunk}\n```", parse_mode=ParseMode.MARKDOWN)
        if text: await asyncio.sleep(0.1)

VALIDATION
- Restart app.
- Run:
  1) /a_logs_tail                -> should show recent logs from logs/*.log or ring buffer
  2) /a_logs_tail 100            -> exactly ~100 lines (capped)
  3) /a_logs_tail level=warn     -> only warnings/errors (or fallback notice)
  4) /a_logs_tail 300 level=error sources=app,trading -> merged + filtered
- Ensure responses are chunked and under Telegram limits.
- No behavior changes for other admin commands.'
2025-08-10 09:56:04,883 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:56:04,884 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121117, 'message': {'message_id': 4012, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819764, 'text': '/a_logs_tail 200 level=error', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:56:04,884 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:56:04,884 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 200 level=error'
2025-08-10 09:56:04,884 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 200 level=error
2025-08-10 09:56:05,267 [INFO] app: [WEBHOOK] Command '/a_logs_tail 200 level=error' processed, response sent: 200
2025-08-10 09:56:38,366 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:56:38,366 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121118, 'message': {'message_id': 4014, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819798, 'text': '/assistant_toggle OFF', 'entities': [{'offset': 0, 'length': 17, 'type': 'bot_command'}]}}
2025-08-10 09:56:38,366 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:56:38,366 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_toggle OFF'
2025-08-10 09:56:38,367 [INFO] app: [WEBHOOK] Admin command detected: /assistant_toggle OFF
2025-08-10 09:56:38,367 [INFO] app: [WEBHOOK] Unknown admin command: /assistant_toggle OFF
2025-08-10 09:57:14,872 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:57:14,873 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121119, 'message': {'message_id': 4015, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819834, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 09:57:14,873 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:57:14,873 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 09:57:14,873 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 09:57:14,873 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 09:57:21,881 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:57:21,881 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121120, 'message': {'message_id': 4016, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819841, 'text': 'Patch the assistant command so it always replies and works in our active async router.\n\nCHANGES\n1) alerts/telegram.py\n- Ensure async-safe assistant handler with error logging and guaranteed replies.\n- Add admin alias logic helper we can call from legacy/active router.\n\nCODE (replace or add – idempotent):\n\nimport logging, asyncio\nfrom config import ASSISTANT_ADMIN_TELEGRAM_ID, ASSISTANT_WRITE_GUARD, ASSISTANT_FAILSAFE\nfrom assistant_dev import assistant_codegen, apply_unified_diffs, maybe_run_commands, safe_restart_if_needed\n\ndef _is_admin(update):\n    return getattr(update.effective_user, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\nasync def cmd_assistant_async(update, context):\n    try:\n        if not _is_admin(update):\n            await update.message.reply_text("Not authorized."); return\n        if str(ASSISTANT_FAILSAFE).upper() == "ON":\n            await update.message.reply_text("🚫 Assistant patching DISABLED (failsafe ON)."); return\n\n        req = (update.message.text or "").partition(" ")[2].strip()\n        if not req:\n            await update.message.reply_text("Usage: /assistant <change request>"); return\n\n        await update.message.reply_text("Thinking… generating patch.")\n        logging.info("assistant: start request=%r", req)\n\n        # Generate plan + diffs (with internal fallback model)\n        result = assistant_codegen(req)\n        plan = result.get("plan","(no plan)")\n        diffs = result.get("diffs",[])\n        commands = result.get("commands",[])\n        restart = result.get("restart","none")\n\n        # Apply (or dry-run)\n        apply_res = apply_unified_diffs(diffs)\n        cmd_out = maybe_run_commands(commands)\n\n        summary = [\n            f"✅ Plan:\\\\n{plan}",\n            f"✍️ Mode: {\'WRITE\' if str(ASSISTANT_WRITE_GUARD).upper()==\'ON\' else \'DRY-RUN\'}",\n            f"📝 Applied: {len(apply_res.applied_files)} | Failed: {len(apply_res.failed_files)}",\n            ("❌ " + ", ".join(apply_res.failed_files)) if apply_res.failed_files else "❌ none",\n            f"🔧 Commands: {\'ran\' if str(ASSISTANT_WRITE_GUARD).upper()==\'ON\' else \'skipped (dry-run)\'}",\n            f"♻️ Restart: {restart}",\n        ]\n        await update.message.reply_text("\\\\n\\\\n".join(summary)[:4000])\n        if diffs:\n            await update.message.reply_text("Diff preview (first patch):\\\\n\\\\n" + diffs[0][:3500])\n\n        safe_restart_if_needed(restart)\n    except Exception as e:\n        logging.exception("cmd_assistant_async error")\n        try:\n            await update.message.reply_text(f"❌ /assistant failed: {e}")\n        except Exception:\n            pass\n\n# Admin alias entry you can call from the legacy router:\nasync def admin_alias_assistant(update, context):\n    # Reuse the same handler, but ensure args are preserved\n    await cmd_assistant_async(update, context)\n\n2) ACTIVE ROUTER (the file where /help works)\n- Import and intercept /a_assistant BEFORE unknown-catchers.\n- This guarantees our assistant uses the working path.\n\nAdd near other imports:\nfrom alerts.telegram import admin_alias_assistant\n\nIn the message/command routing logic (before unknown):\nif text.startswith("/a_assistant"):\n    # Preserve the rest of the command as the request\n    # Convert \'/a_assistant …\' -> \'/assistant …\' so cmd_assistant sees the prompt\n    update.message.text = "/assistant " + text.split(" ", 1)[1] if " " in text else "/assistant"\n    await admin_alias_assistant(update, context)\n    return\n\n3) (Optional) Register /assistant normal path if you also use PTB CommandHandler:\napplication.add_handler(CommandHandler("assistant", cmd_assistant_async), group=0)\n\nVALIDATION\n- Restart.\n- Send: /a_assistant add a single comment at the top of main.py: \'# managed by assistant\'\n- Expect: DRY-RUN plan first (if WRITE_GUARD=OFF) and a summary reply.\n- If no reply, run /a_logs_tail 200 level=error and send the last block.', 'entities': [{'offset': 106, 'length': 11, 'type': 'url'}, {'offset': 1096, 'length': 10, 'type': 'bot_command'}, {'offset': 1214, 'length': 12, 'type': 'url'}, {'offset': 2537, 'length': 10, 'type': 'bot_command'}, {'offset': 2854, 'length': 5, 'type': 'bot_command'}, {'offset': 2890, 'length': 12, 'type': 'bot_command'}, {'offset': 3134, 'length': 12, 'type': 'bot_command'}, {'offset': 3219, 'length': 12, 'type': 'bot_command'}, {'offset': 3239, 'length': 10, 'type': 'bot_command'}, {'offset': 3313, 'length': 10, 'type': 'bot_command'}, {'offset': 3371, 'length': 10, 'type': 'bot_command'}, {'offset': 3467, 'length': 10, 'type': 'bot_command'}, {'offset': 3640, 'length': 12, 'type': 'bot_command'}, {'offset': 3688, 'length': 7, 'type': 'url'}, {'offset': 3812, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:57:21,881 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:57:21,881 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Patch the assistant command so it always replies and works in our active async router.

CHANGES
1) alerts/telegram.py
- Ensure async-safe assistant handler with error logging and guaranteed replies.
- Add admin alias logic helper we can call from legacy/active router.

CODE (replace or add – idempotent):

import logging, asyncio
from config import ASSISTANT_ADMIN_TELEGRAM_ID, ASSISTANT_WRITE_GUARD, ASSISTANT_FAILSAFE
from assistant_dev import assistant_codegen, apply_unified_diffs, maybe_run_commands, safe_restart_if_needed

def _is_admin(update):
    return getattr(update.effective_user, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

async def cmd_assistant_async(update, context):
    try:
        if not _is_admin(update):
            await update.message.reply_text("Not authorized."); return
        if str(ASSISTANT_FAILSAFE).upper() == "ON":
            await update.message.reply_text("🚫 Assistant patching DISABLED (failsafe ON)."); return

        req = (update.message.text or "").partition(" ")[2].strip()
        if not req:
            await update.message.reply_text("Usage: /assistant <change request>"); return

        await update.message.reply_text("Thinking… generating patch.")
        logging.info("assistant: start request=%r", req)

        # Generate plan + diffs (with internal fallback model)
        result = assistant_codegen(req)
        plan = result.get("plan","(no plan)")
        diffs = result.get("diffs",[])
        commands = result.get("commands",[])
        restart = result.get("restart","none")

        # Apply (or dry-run)
        apply_res = apply_unified_diffs(diffs)
        cmd_out = maybe_run_commands(commands)

        summary = [
            f"✅ Plan:\\n{plan}",
            f"✍️ Mode: {'WRITE' if str(ASSISTANT_WRITE_GUARD).upper()=='ON' else 'DRY-RUN'}",
            f"📝 Applied: {len(apply_res.applied_files)} | Failed: {len(apply_res.failed_files)}",
            ("❌ " + ", ".join(apply_res.failed_files)) if apply_res.failed_files else "❌ none",
            f"🔧 Commands: {'ran' if str(ASSISTANT_WRITE_GUARD).upper()=='ON' else 'skipped (dry-run)'}",
            f"♻️ Restart: {restart}",
        ]
        await update.message.reply_text("\\n\\n".join(summary)[:4000])
        if diffs:
            await update.message.reply_text("Diff preview (first patch):\\n\\n" + diffs[0][:3500])

        safe_restart_if_needed(restart)
    except Exception as e:
        logging.exception("cmd_assistant_async error")
        try:
            await update.message.reply_text(f"❌ /assistant failed: {e}")
        except Exception:
            pass

# Admin alias entry you can call from the legacy router:
async def admin_alias_assistant(update, context):
    # Reuse the same handler, but ensure args are preserved
    await cmd_assistant_async(update, context)

2) ACTIVE ROUTER (the file where /help works)
- Import and intercept /a_assistant BEFORE unknown-catchers.
- This guarantees our assistant uses the working path.

Add near other imports:
from alerts.telegram import admin_alias_assistant

In the message/command routing logic (before unknown):
if text.startswith("/a_assistant"):
    # Preserve the rest of the command as the request
    # Convert '/a_assistant …' -> '/assistant …' so cmd_assistant sees the prompt
    update.message.text = "/assistant " + text.split(" ", 1)[1] if " " in text else "/assistant"
    await admin_alias_assistant(update, context)
    return

3) (Optional) Register /assistant normal path if you also use PTB CommandHandler:
application.add_handler(CommandHandler("assistant", cmd_assistant_async), group=0)

VALIDATION
- Restart.
- Send: /a_assistant add a single comment at the top of main.py: '# managed by assistant'
- Expect: DRY-RUN plan first (if WRITE_GUARD=OFF) and a summary reply.
- If no reply, run /a_logs_tail 200 level=error and send the last block.'
2025-08-10 09:58:02,967 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 09:58:02,967 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121121, 'message': {'message_id': 4017, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754819882, 'text': '/a_logs_tail 20 level=error', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 09:58:02,967 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 09:58:02,967 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 20 level=error'
2025-08-10 09:58:02,968 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 20 level=error
2025-08-10 09:58:03,380 [INFO] app: [WEBHOOK] Command '/a_logs_tail 20 level=error' processed, response sent: 200
2025-08-10 10:01:04,613 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:01:04,614 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121122, 'message': {'message_id': 4019, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820064, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:01:04,614 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:01:04,614 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:01:04,615 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:01:04,615 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:01:18,572 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:01:18,572 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121123, 'message': {'message_id': 4020, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820078, 'text': 'Add /a_assistant_toggle to active router and link it to existing cmd_assistant_toggle.\n\nCHANGES:\n1) alerts/telegram.py\n- Import the toggle handler:\nfrom alerts.telegram import cmd_assistant_toggle\n\n- Add a new async alias:\nasync def admin_alias_toggle(update, context):\n    import logging\n    uid = getattr(update.effective_user, "id", None)\n    if uid != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized.")\n        return\n    logging.info(f"Admin toggle request: {context.args}")\n    await cmd_assistant_toggle(update, context)\n\n2) ACTIVE ROUTER FILE (the one where /help works)\n- Near the top with other imports:\nfrom alerts.telegram import admin_alias_toggle\n\n- In the text/command handling section, BEFORE unknown command catchers:\nif text.startswith("/a_assistant_toggle"):\n    parts = text.split(maxsplit=1)\n    context.args = parts[1].split() if len(parts) == 2 else []\n    await admin_alias_toggle(update, context)\n    return\n\nVALIDATION:\n- Restart the bot.\n- In Telegram, send: /a_assistant_toggle OFF\n- You should get a confirmation message.\n- Run: /a_logs_tail 50 level=info — you should see "Admin toggle request: [...]" in the logs.', 'entities': [{'offset': 4, 'length': 19, 'type': 'bot_command'}, {'offset': 107, 'length': 11, 'type': 'url'}, {'offset': 463, 'length': 12, 'type': 'url'}, {'offset': 603, 'length': 5, 'type': 'bot_command'}, {'offset': 792, 'length': 19, 'type': 'bot_command'}, {'offset': 1023, 'length': 19, 'type': 'bot_command'}, {'offset': 1095, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:01:18,573 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:01:18,573 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add /a_assistant_toggle to active router and link it to existing cmd_assistant_toggle.

CHANGES:
1) alerts/telegram.py
- Import the toggle handler:
from alerts.telegram import cmd_assistant_toggle

- Add a new async alias:
async def admin_alias_toggle(update, context):
    import logging
    uid = getattr(update.effective_user, "id", None)
    if uid != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized.")
        return
    logging.info(f"Admin toggle request: {context.args}")
    await cmd_assistant_toggle(update, context)

2) ACTIVE ROUTER FILE (the one where /help works)
- Near the top with other imports:
from alerts.telegram import admin_alias_toggle

- In the text/command handling section, BEFORE unknown command catchers:
if text.startswith("/a_assistant_toggle"):
    parts = text.split(maxsplit=1)
    context.args = parts[1].split() if len(parts) == 2 else []
    await admin_alias_toggle(update, context)
    return

VALIDATION:
- Restart the bot.
- In Telegram, send: /a_assistant_toggle OFF
- You should get a confirmation message.
- Run: /a_logs_tail 50 level=info — you should see "Admin toggle request: [...]" in the logs.'
2025-08-10 10:03:19,744 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:03:19,744 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121124, 'message': {'message_id': 4021, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820199, 'text': '/a_assistant_toggle OFF', 'entities': [{'offset': 0, 'length': 19, 'type': 'bot_command'}]}}
2025-08-10 10:03:19,744 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:03:19,744 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_assistant_toggle OFF'
2025-08-10 10:03:19,744 [INFO] app: [WEBHOOK] Admin command detected: /a_assistant_toggle OFF
2025-08-10 10:03:19,745 [INFO] app: [WEBHOOK] Unknown admin command: /a_assistant_toggle OFF
2025-08-10 10:03:31,165 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:03:31,166 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121125, 'message': {'message_id': 4022, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820211, 'text': '/a_assistant_toggle OFF', 'entities': [{'offset': 0, 'length': 19, 'type': 'bot_command'}]}}
2025-08-10 10:03:31,166 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:03:31,166 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_assistant_toggle OFF'
2025-08-10 10:03:31,166 [INFO] app: [WEBHOOK] Admin command detected: /a_assistant_toggle OFF
2025-08-10 10:03:31,166 [INFO] app: [WEBHOOK] Unknown admin command: /a_assistant_toggle OFF
2025-08-10 10:04:37,191 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:04:37,191 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121126, 'message': {'message_id': 4023, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820276, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:04:37,191 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:04:37,191 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:04:37,192 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:04:37,192 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:04:47,912 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:04:47,912 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121127, 'message': {'message_id': 4024, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820287, 'text': 'Install a high-priority admin interceptor that always catches /a_* commands, regardless of the legacy router.\n\nCreate file: alerts/admin_router.py  (PTB v20+)\n------------------------------------------------\nimport logging\nfrom telegram.ext import ApplicationHandlerStop\nfrom config import ASSISTANT_ADMIN_TELEGRAM_ID\nfrom alerts.telegram import (\n    cmd_status, cmd_logs_tail, cmd_logs_stream, cmd_logs_watch, cmd_mode,\n    cmd_ping, cmd_whoami,\n)\n\ndef _is_admin(update):\n    return getattr(update.effective_user, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\nasync def admin_router(update, context):\n    msg = getattr(update, "message", None) or getattr(update, "edited_message", None)\n    if not msg or not msg.text:\n        return\n    text = msg.text.strip()\n    if not text.startswith("/a_"):\n        return  # not an admin alias; let the rest handle\n\n    if not _is_admin(update):\n        await msg.reply_text("Not authorized.")\n        raise ApplicationHandlerStop\n\n    parts = text.split(maxsplit=1)\n    cmd = parts[0].lower()\n    args = parts[1].split() if len(parts) == 2 else []\n    context.args = args\n    logging.info("admin_router caught %s args=%r", cmd, args)\n\n    try:\n        if   cmd == "/a_ping":          await cmd_ping(update, context)\n        elif cmd == "/a_whoami":        await cmd_whoami(update, context)\n        elif cmd == "/a_status":        await cmd_status(update, context)\n        elif cmd == "/a_logs_tail":     await cmd_logs_tail(update, context)\n        elif cmd == "/a_logs_stream":   await cmd_logs_stream(update, context)\n        elif cmd == "/a_logs_watch":    await cmd_logs_watch(update, context)\n        elif cmd == "/a_mode":          await cmd_mode(update, context)\n        else:\n            await msg.reply_text("Unknown admin alias.")\n        raise ApplicationHandlerStop  # stop legacy unknown handler\n    except ApplicationHandlerStop:\n        raise\n    except Exception as e:\n        logging.exception("admin_router error")\n        await msg.reply_text(f"admin router error: {e}")\n        raise ApplicationHandlerStop\n\n\nRegister the interceptor at highest priority in the real entrypoint(s)\n----------------------------------------------------------------------\nIn whichever file actually builds the PTB Application (one of: bot.py, main.py, app.py),\nafter creating the Application instance and BEFORE other handlers, add:\n\nfrom telegram.ext import MessageHandler, filters\nfrom alerts.admin_router import admin_router\napplication.add_handler(MessageHandler(filters.ALL, admin_router), group=-100)\nimport logging; logging.info(">>> admin_router installed (group=-100) <<<")\n\nMake this change idempotent and apply it to bot.py, main.py, AND app.py if they exist,\nonly if Application is present. Do not duplicate the handler if it already exists.\n\nVALIDATION:\n- Restart the app.\n- /a_ping          -> expect "pong"\n- /a_whoami        -> expect your numeric ID\n- /a_status        -> expect PTB version + handler list\n- /a_logs_tail 80  -> expect recent logs', 'entities': [{'offset': 62, 'length': 3, 'type': 'bot_command'}, {'offset': 790, 'length': 3, 'type': 'bot_command'}, {'offset': 1117, 'length': 12, 'type': 'url'}, {'offset': 1206, 'length': 7, 'type': 'bot_command'}, {'offset': 1278, 'length': 9, 'type': 'bot_command'}, {'offset': 1352, 'length': 9, 'type': 'bot_command'}, {'offset': 1426, 'length': 12, 'type': 'bot_command'}, {'offset': 1503, 'length': 14, 'type': 'bot_command'}, {'offset': 1582, 'length': 13, 'type': 'bot_command'}, {'offset': 1660, 'length': 7, 'type': 'bot_command'}, {'offset': 2275, 'length': 6, 'type': 'url'}, {'offset': 2283, 'length': 7, 'type': 'url'}, {'offset': 2292, 'length': 6, 'type': 'url'}, {'offset': 2563, 'length': 12, 'type': 'url'}, {'offset': 2668, 'length': 6, 'type': 'url'}, {'offset': 2676, 'length': 7, 'type': 'url'}, {'offset': 2689, 'length': 6, 'type': 'url'}, {'offset': 2828, 'length': 7, 'type': 'bot_command'}, {'offset': 2864, 'length': 9, 'type': 'bot_command'}, {'offset': 2909, 'length': 9, 'type': 'bot_command'}, {'offset': 2965, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:04:47,912 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:04:47,912 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Install a high-priority admin interceptor that always catches /a_* commands, regardless of the legacy router.

Create file: alerts/admin_router.py  (PTB v20+)
------------------------------------------------
import logging
from telegram.ext import ApplicationHandlerStop
from config import ASSISTANT_ADMIN_TELEGRAM_ID
from alerts.telegram import (
    cmd_status, cmd_logs_tail, cmd_logs_stream, cmd_logs_watch, cmd_mode,
    cmd_ping, cmd_whoami,
)

def _is_admin(update):
    return getattr(update.effective_user, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

async def admin_router(update, context):
    msg = getattr(update, "message", None) or getattr(update, "edited_message", None)
    if not msg or not msg.text:
        return
    text = msg.text.strip()
    if not text.startswith("/a_"):
        return  # not an admin alias; let the rest handle

    if not _is_admin(update):
        await msg.reply_text("Not authorized.")
        raise ApplicationHandlerStop

    parts = text.split(maxsplit=1)
    cmd = parts[0].lower()
    args = parts[1].split() if len(parts) == 2 else []
    context.args = args
    logging.info("admin_router caught %s args=%r", cmd, args)

    try:
        if   cmd == "/a_ping":          await cmd_ping(update, context)
        elif cmd == "/a_whoami":        await cmd_whoami(update, context)
        elif cmd == "/a_status":        await cmd_status(update, context)
        elif cmd == "/a_logs_tail":     await cmd_logs_tail(update, context)
        elif cmd == "/a_logs_stream":   await cmd_logs_stream(update, context)
        elif cmd == "/a_logs_watch":    await cmd_logs_watch(update, context)
        elif cmd == "/a_mode":          await cmd_mode(update, context)
        else:
            await msg.reply_text("Unknown admin alias.")
        raise ApplicationHandlerStop  # stop legacy unknown handler
    except ApplicationHandlerStop:
        raise
    except Exception as e:
        logging.exception("admin_router error")
        await msg.reply_text(f"admin router error: {e}")
        raise ApplicationHandlerStop


Register the interceptor at highest priority in the real entrypoint(s)
----------------------------------------------------------------------
In whichever file actually builds the PTB Application (one of: bot.py, main.py, app.py),
after creating the Application instance and BEFORE other handlers, add:

from telegram.ext import MessageHandler, filters
from alerts.admin_router import admin_router
application.add_handler(MessageHandler(filters.ALL, admin_router), group=-100)
import logging; logging.info(">>> admin_router installed (group=-100) <<<")

Make this change idempotent and apply it to bot.py, main.py, AND app.py if they exist,
only if Application is present. Do not duplicate the handler if it already exists.

VALIDATION:
- Restart the app.
- /a_ping          -> expect "pong"
- /a_whoami        -> expect your numeric ID
- /a_status        -> expect PTB version + handler list
- /a_logs_tail 80  -> expect recent logs'
2025-08-10 10:05:03,906 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:05:03,906 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:05:03,907 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:05:03,913 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:05:04,981 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:06:15,189 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:06:15,189 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:06:15,189 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:06:15,192 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:06:15,878 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:06:41,018 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:06:41,019 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121128, 'message': {'message_id': 4025, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820400, 'text': '/a_logs_tail 50 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:06:41,019 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:06:41,019 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 50 level=info'
2025-08-10 10:06:41,019 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 50 level=info
2025-08-10 10:06:41,506 [INFO] app: [WEBHOOK] Command '/a_logs_tail 50 level=info' processed, response sent: 200
2025-08-10 10:07:33,608 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:07:33,609 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121129, 'message': {'message_id': 4027, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820453, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:07:33,609 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:07:33,609 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:07:33,609 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:07:33,609 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:07:41,081 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:07:41,081 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121130, 'message': {'message_id': 4028, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820460, 'text': 'Scan the entire project for from telegram import Chat or import Chat and remove or comment those lines.\nIf code relies on Chat for type hints, replace with:\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\n# and adjust annotations accordingly.\n\nAfter removal, ensure Application creation still works.\n\nRestart the app after change.', 'entities': [{'offset': 28, 'length': 25, 'type': 'code'}, {'offset': 57, 'length': 11, 'type': 'code'}]}}
2025-08-10 10:07:41,081 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:07:41,081 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Scan the entire project for from telegram import Chat or import Chat and remove or comment those lines.
If code relies on Chat for type hints, replace with:
from telegram import Update
from telegram.ext import ContextTypes
# and adjust annotations accordingly.

After removal, ensure Application creation still works.

Restart the app after change.'
2025-08-10 10:08:02,751 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:08:02,752 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:08:02,752 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:08:02,755 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:08:03,488 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:08:41,626 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:08:41,626 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121131, 'message': {'message_id': 4029, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820521, 'text': '/a_ping', 'entities': [{'offset': 0, 'length': 7, 'type': 'bot_command'}]}}
2025-08-10 10:08:41,626 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:08:41,626 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_ping'
2025-08-10 10:08:41,627 [INFO] app: [WEBHOOK] Admin command detected: /a_ping
2025-08-10 10:08:42,047 [INFO] app: [WEBHOOK] Command '/a_ping' processed, response sent: 200
2025-08-10 10:08:53,266 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:08:53,267 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121132, 'message': {'message_id': 4031, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820533, 'text': '/a_assistant_toggle OFF', 'entities': [{'offset': 0, 'length': 19, 'type': 'bot_command'}]}}
2025-08-10 10:08:53,267 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:08:53,268 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_assistant_toggle OFF'
2025-08-10 10:08:53,268 [INFO] app: [WEBHOOK] Admin command detected: /a_assistant_toggle OFF
2025-08-10 10:08:53,268 [INFO] app: [WEBHOOK] Unknown admin command: /a_assistant_toggle OFF
2025-08-10 10:09:32,125 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:09:32,125 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121133, 'message': {'message_id': 4032, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820572, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:09:32,125 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:09:32,125 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:09:32,126 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:09:32,126 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:09:38,451 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:09:38,452 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121134, 'message': {'message_id': 4033, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820578, 'text': 'Make admin and assistant commands work via the Flask webhook router (no PTB required).\n\nGOALS\n- In the Flask webhook handler (the one logging “[WEBHOOK] Received POST”), add robust routing for:\n  /a_ping, /a_whoami, /a_status, /a_logs_tail, /a_logs_stream, /a_logs_watch, /a_mode,\n  /a_assistant_toggle, and /assistant <request>\n- Call the existing functions in alerts/telegram.py where available.\n- Ensure every command sends a reply even on error, and log any exceptions.\n\nCHANGES\n1) In the Flask app file (where “[WEBHOOK] Received POST” is logged; usually app.py or bot.py):\n   - Inside the POST route that receives Telegram updates, BEFORE any “unknown” fallback, add:\n\n   from config import ASSISTANT_ADMIN_TELEGRAM_ID\n   from alerts.telegram import (\n       cmd_ping, cmd_whoami, cmd_status, cmd_logs_tail, cmd_logs_stream, cmd_logs_watch, cmd_mode,\n       cmd_assistant_toggle, cmd_assistant_async\n   )\n\n   async def _ensure_reply(func, update, context):\n       try:\n           await func(update, context)\n       except Exception as e:\n           import logging\n           logging.exception("flask router cmd error")\n           try:\n               await update.message.reply_text(f"❌ command failed: {e}")\n           except Exception:\n               pass\n\n   def _is_admin(u):\n       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n   # PSEUDOCODE inside the webhook processing right after you parse text:\n   # text = (update.message.text or "").strip()\n   if text.startswith("/a_ping"):\n       await _ensure_reply(cmd_ping, update, context); return "ok"\n   if text.startswith("/a_whoami"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(cmd_whoami, update, context); return "ok"\n   if text.startswith("/a_status"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(cmd_status, update, context); return "ok"\n   if text.startswith("/a_logs_tail"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(cmd_logs_tail, update, context); return "ok"\n   if text.startswith("/a_logs_stream"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(cmd_logs_stream, update, context); return "ok"\n   if text.startswith("/a_logs_watch"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split(maxsplit=1)\n       context.args = parts[1].split() if len(parts) == 2 else []\n       await _ensure_reply(cmd_logs_watch, update, context); return "ok"\n   if text.startswith("/a_mode"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(cmd_mode, update, context); return "ok"\n\n   # Assistant toggle via Flask\n   if text.startswith("/a_assistant_toggle"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(cmd_assistant_toggle, update, context); return "ok"\n\n   # Assistant codegen via Flask\n   if text.startswith("/assistant "):  # normal path also allowed\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       # Use the async assistant handler\n       await _ensure_reply(cmd_assistant_async, update, context); return "ok"', 'entities': [{'offset': 196, 'length': 7, 'type': 'bot_command'}, {'offset': 205, 'length': 9, 'type': 'bot_command'}, {'offset': 216, 'length': 9, 'type': 'bot_command'}, {'offset': 227, 'length': 12, 'type': 'bot_command'}, {'offset': 241, 'length': 14, 'type': 'bot_command'}, {'offset': 257, 'length': 13, 'type': 'bot_command'}, {'offset': 272, 'length': 7, 'type': 'bot_command'}, {'offset': 283, 'length': 19, 'type': 'bot_command'}, {'offset': 308, 'length': 10, 'type': 'bot_command'}, {'offset': 369, 'length': 11, 'type': 'url'}, {'offset': 560, 'length': 6, 'type': 'url'}, {'offset': 570, 'length': 6, 'type': 'url'}, {'offset': 1422, 'length': 4, 'type': 'code'}, {'offset': 1499, 'length': 7, 'type': 'bot_command'}, {'offset': 1600, 'length': 9, 'type': 'bot_command'}, {'offset': 1828, 'length': 9, 'type': 'bot_command'}, {'offset': 2056, 'length': 12, 'type': 'bot_command'}, {'offset': 2376, 'length': 14, 'type': 'bot_command'}, {'offset': 2700, 'length': 13, 'type': 'bot_command'}, {'offset': 3040, 'length': 7, 'type': 'bot_command'}, {'offset': 3383, 'length': 19, 'type': 'bot_command'}, {'offset': 3751, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:09:38,452 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:09:38,452 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Make admin and assistant commands work via the Flask webhook router (no PTB required).

GOALS
- In the Flask webhook handler (the one logging “[WEBHOOK] Received POST”), add robust routing for:
  /a_ping, /a_whoami, /a_status, /a_logs_tail, /a_logs_stream, /a_logs_watch, /a_mode,
  /a_assistant_toggle, and /assistant <request>
- Call the existing functions in alerts/telegram.py where available.
- Ensure every command sends a reply even on error, and log any exceptions.

CHANGES
1) In the Flask app file (where “[WEBHOOK] Received POST” is logged; usually app.py or bot.py):
   - Inside the POST route that receives Telegram updates, BEFORE any “unknown” fallback, add:

   from config import ASSISTANT_ADMIN_TELEGRAM_ID
   from alerts.telegram import (
       cmd_ping, cmd_whoami, cmd_status, cmd_logs_tail, cmd_logs_stream, cmd_logs_watch, cmd_mode,
       cmd_assistant_toggle, cmd_assistant_async
   )

   async def _ensure_reply(func, update, context):
       try:
           await func(update, context)
       except Exception as e:
           import logging
           logging.exception("flask router cmd error")
           try:
               await update.message.reply_text(f"❌ command failed: {e}")
           except Exception:
               pass

   def _is_admin(u):
       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

   # PSEUDOCODE inside the webhook processing right after you parse text:
   # text = (update.message.text or "").strip()
   if text.startswith("/a_ping"):
       await _ensure_reply(cmd_ping, update, context); return "ok"
   if text.startswith("/a_whoami"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(cmd_whoami, update, context); return "ok"
   if text.startswith("/a_status"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(cmd_status, update, context); return "ok"
   if text.startswith("/a_logs_tail"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(cmd_logs_tail, update, context); return "ok"
   if text.startswith("/a_logs_stream"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(cmd_logs_stream, update, context); return "ok"
   if text.startswith("/a_logs_watch"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split(maxsplit=1)
       context.args = parts[1].split() if len(parts) == 2 else []
       await _ensure_reply(cmd_logs_watch, update, context); return "ok"
   if text.startswith("/a_mode"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(cmd_mode, update, context); return "ok"

   # Assistant toggle via Flask
   if text.startswith("/a_assistant_toggle"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(cmd_assistant_toggle, update, context); return "ok"

   # Assistant codegen via Flask
   if text.startswith("/assistant "):  # normal path also allowed
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       # Use the async assistant handler
       await _ensure_reply(cmd_assistant_async, update, context); return "ok"'
2025-08-10 10:09:38,568 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:09:38,568 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121135, 'message': {'message_id': 4034, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820578, 'text': '2) Remove any failing imports like “from telegram import Chat” which break PTB.\n   - Search project for that import and delete/comment it.\n   - Do NOT attempt to start PTB here; we are staying on Flask for now.\n\nVALIDATION\n- Restart the app.\n- Expect no console errors on import.'}}
2025-08-10 10:09:38,568 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:09:38,568 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '2) Remove any failing imports like “from telegram import Chat” which break PTB.
   - Search project for that import and delete/comment it.
   - Do NOT attempt to start PTB here; we are staying on Flask for now.

VALIDATION
- Restart the app.
- Expect no console errors on import.'
2025-08-10 10:09:56,060 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:09:56,060 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:09:56,060 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:09:56,064 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:09:56,800 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:10:08,446 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:10:08,446 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121136, 'message': {'message_id': 4035, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820608, 'text': '/a_ping', 'entities': [{'offset': 0, 'length': 7, 'type': 'bot_command'}]}}
2025-08-10 10:10:08,446 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:10:08,446 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_ping'
2025-08-10 10:10:08,446 [INFO] app: [WEBHOOK] Admin command detected: /a_ping
2025-08-10 10:10:08,974 [INFO] app: [WEBHOOK] Command '/a_ping' processed, response sent: 200
2025-08-10 10:10:16,571 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:10:16,572 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121137, 'message': {'message_id': 4037, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820616, 'text': '/a_whoami', 'entities': [{'offset': 0, 'length': 9, 'type': 'bot_command'}]}}
2025-08-10 10:10:16,572 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:10:16,572 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_whoami'
2025-08-10 10:10:16,572 [INFO] app: [WEBHOOK] Admin command detected: /a_whoami
2025-08-10 10:10:16,996 [INFO] app: [WEBHOOK] Command '/a_whoami' processed, response sent: 200
2025-08-10 10:10:26,697 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:10:26,698 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121138, 'message': {'message_id': 4039, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754820626, 'text': '/a_assistant_toggle OFF', 'entities': [{'offset': 0, 'length': 19, 'type': 'bot_command'}]}}
2025-08-10 10:10:26,698 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:10:26,698 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_assistant_toggle OFF'
2025-08-10 10:10:26,698 [INFO] app: [WEBHOOK] Admin command detected: /a_assistant_toggle OFF
2025-08-10 10:10:26,698 [INFO] app: [WEBHOOK] Unknown admin command: /a_assistant_toggle OFF
2025-08-10 10:24:53,089 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:24:53,089 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121139, 'message': {'message_id': 4040, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821492, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:24:53,089 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:24:53,089 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:24:53,090 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:24:53,090 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:25:23,674 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:25:23,674 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121140, 'message': {'message_id': 4041, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821523, 'text': 'Add admin command handling directly to the Flask webhook so it works without PTB running.\n\n1) In the Flask app file that handles Telegram webhooks (the one logging "[WEBHOOK] Received POST"):\n   - Find where you parse text from the incoming update (after: update = Update.de_json(...), or after extracting `text = ...`).\n   - Before the "unknown command" fallback, add this:\n\n   from config import ASSISTANT_ADMIN_TELEGRAM_ID\n   from alerts import telegram as tg\n\n   async def _ensure_reply(func, update, context):\n       try:\n           await func(update, context)\n       except Exception as e:\n           import logging\n           logging.exception("flask router cmd error")\n           try:\n               await update.message.reply_text(f"❌ command failed: {e}")\n           except Exception:\n               pass\n\n   def _is_admin(u):\n       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n   # Command routing (Flask mode)\n   if text.startswith("/a_ping"):\n       await _ensure_reply(tg.cmd_ping, update, context); return "ok"\n\n   if text.startswith("/a_whoami"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_whoami, update, context); return "ok"\n\n   if text.startswith("/a_status"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_status, update, context); return "ok"\n\n   if text.startswith("/a_logs_tail"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"\n\n   if text.startswith("/a_assistant_toggle"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(tg.cmd_assistant_toggle, update, context); return "ok"\n\n   if text.startswith("/assistant "):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"\n\n2) Save and restart the Flask app.\n\nValidation after restart:\n- Run in Telegram: /a_ping → expect "pong".\n- Run in Telegram: /a_assistant_toggle OFF → expect confirmation text and log entry.\n- Run in Telegram: /a_assistant_toggle ON → expect confirmation text and log entry.', 'entities': [{'offset': 218, 'length': 4, 'type': 'code'}, {'offset': 963, 'length': 7, 'type': 'bot_command'}, {'offset': 1068, 'length': 9, 'type': 'bot_command'}, {'offset': 1300, 'length': 9, 'type': 'bot_command'}, {'offset': 1532, 'length': 12, 'type': 'bot_command'}, {'offset': 1856, 'length': 19, 'type': 'bot_command'}, {'offset': 2194, 'length': 10, 'type': 'bot_command'}, {'offset': 2495, 'length': 7, 'type': 'bot_command'}, {'offset': 2539, 'length': 19, 'type': 'bot_command'}, {'offset': 2624, 'length': 19, 'type': 'bot_command'}]}}
2025-08-10 10:25:23,674 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:25:23,674 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add admin command handling directly to the Flask webhook so it works without PTB running.

1) In the Flask app file that handles Telegram webhooks (the one logging "[WEBHOOK] Received POST"):
   - Find where you parse text from the incoming update (after: update = Update.de_json(...), or after extracting `text = ...`).
   - Before the "unknown command" fallback, add this:

   from config import ASSISTANT_ADMIN_TELEGRAM_ID
   from alerts import telegram as tg

   async def _ensure_reply(func, update, context):
       try:
           await func(update, context)
       except Exception as e:
           import logging
           logging.exception("flask router cmd error")
           try:
               await update.message.reply_text(f"❌ command failed: {e}")
           except Exception:
               pass

   def _is_admin(u):
       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

   # Command routing (Flask mode)
   if text.startswith("/a_ping"):
       await _ensure_reply(tg.cmd_ping, update, context); return "ok"

   if text.startswith("/a_whoami"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_whoami, update, context); return "ok"

   if text.startswith("/a_status"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_status, update, context); return "ok"

   if text.startswith("/a_logs_tail"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"

   if text.startswith("/a_assistant_toggle"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(tg.cmd_assistant_toggle, update, context); return "ok"

   if text.startswith("/assistant "):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"

2) Save and restart the Flask app.

Validation after restart:
- Run in Telegram: /a_ping → expect "pong".
- Run in Telegram: /a_assistant_toggle OFF → expect confirmation text and log entry.
- Run in Telegram: /a_assistant_toggle ON → expect confirmation text and log entry.'
2025-08-10 10:25:44,495 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:25:44,495 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121141, 'message': {'message_id': 4042, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821544, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:25:44,495 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:25:44,496 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:25:44,496 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:25:44,496 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:25:57,878 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:25:57,878 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121142, 'message': {'message_id': 4043, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821557, 'text': 'Add admin + assistant command handling directly to the Flask webhook (bypassing PTB) and add /assistant_model command for live model switching.\n\n1) In the Flask app file that processes Telegram webhooks (the one logging "[WEBHOOK] Received POST"):\n   - Find where you parse text from the incoming update (after: update = Update.de_json(...), or after extracting `text = ...`).\n   - Before the "unknown command" fallback, insert:\n\n   from config import (\n       ASSISTANT_ADMIN_TELEGRAM_ID,\n       ASSISTANT_MODEL\n   )\n   from alerts import telegram as tg\n   import logging\n\n   async def _ensure_reply(func, update, context):\n       try:\n           await func(update, context)\n       except Exception as e:\n           logging.exception("flask router cmd error")\n           try:\n               await update.message.reply_text(f"❌ command failed: {e}")\n           except Exception:\n               pass\n\n   def _is_admin(u):\n       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n   # Command routing in Flask mode\n   if text.startswith("/a_ping"):\n       await _ensure_reply(tg.cmd_ping, update, context); return "ok"\n\n   if text.startswith("/a_whoami"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_whoami, update, context); return "ok"\n\n   if text.startswith("/a_status"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_status, update, context); return "ok"\n\n   if text.startswith("/a_logs_tail"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"\n\n   if text.startswith("/a_assistant_toggle"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       context.args = parts[1:] if len(parts) > 1 else []\n       await _ensure_reply(tg.cmd_assistant_toggle, update, context); return "ok"\n\n   if text.startswith("/assistant "):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"\n\n   # NEW: Assistant model switching\n   if text.startswith("/assistant_model"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       if len(parts) < 2:\n           await update.message.reply_text(f"Current model: {ASSISTANT_MODEL}"); return "ok"\n       new_model = parts[1].strip()\n       import os\n       os.environ["ASSISTANT_MODEL"] = new_model\n       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")\n       logging.info(f"[ADMIN] Assistant model changed to {new_model}")\n       return "ok"\n\n2) Save and restart the Flask app.\n\nValidation after restart:\n- /a_ping → pong\n- /a_assistant_toggle OFF → toggle OFF confirmation\n- /assistant_model → shows current model\n- /assistant_model gpt-4o → switches model and confirms\n- /a_logs_tail 50 level=info → shows logs', 'entities': [{'offset': 93, 'length': 16, 'type': 'bot_command'}, {'offset': 274, 'length': 4, 'type': 'code'}, {'offset': 1048, 'length': 7, 'type': 'bot_command'}, {'offset': 1153, 'length': 9, 'type': 'bot_command'}, {'offset': 1385, 'length': 9, 'type': 'bot_command'}, {'offset': 1617, 'length': 12, 'type': 'bot_command'}, {'offset': 1941, 'length': 19, 'type': 'bot_command'}, {'offset': 2279, 'length': 10, 'type': 'bot_command'}, {'offset': 2558, 'length': 16, 'type': 'bot_command'}, {'offset': 3042, 'length': 12, 'type': 'url'}, {'offset': 3190, 'length': 7, 'type': 'code'}, {'offset': 3207, 'length': 23, 'type': 'code'}, {'offset': 3259, 'length': 16, 'type': 'code'}, {'offset': 3300, 'length': 23, 'type': 'code'}, {'offset': 3356, 'length': 26, 'type': 'code'}]}}
2025-08-10 10:25:57,879 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:25:57,879 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add admin + assistant command handling directly to the Flask webhook (bypassing PTB) and add /assistant_model command for live model switching.

1) In the Flask app file that processes Telegram webhooks (the one logging "[WEBHOOK] Received POST"):
   - Find where you parse text from the incoming update (after: update = Update.de_json(...), or after extracting `text = ...`).
   - Before the "unknown command" fallback, insert:

   from config import (
       ASSISTANT_ADMIN_TELEGRAM_ID,
       ASSISTANT_MODEL
   )
   from alerts import telegram as tg
   import logging

   async def _ensure_reply(func, update, context):
       try:
           await func(update, context)
       except Exception as e:
           logging.exception("flask router cmd error")
           try:
               await update.message.reply_text(f"❌ command failed: {e}")
           except Exception:
               pass

   def _is_admin(u):
       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

   # Command routing in Flask mode
   if text.startswith("/a_ping"):
       await _ensure_reply(tg.cmd_ping, update, context); return "ok"

   if text.startswith("/a_whoami"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_whoami, update, context); return "ok"

   if text.startswith("/a_status"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_status, update, context); return "ok"

   if text.startswith("/a_logs_tail"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"

   if text.startswith("/a_assistant_toggle"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       context.args = parts[1:] if len(parts) > 1 else []
       await _ensure_reply(tg.cmd_assistant_toggle, update, context); return "ok"

   if text.startswith("/assistant "):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"

   # NEW: Assistant model switching
   if text.startswith("/assistant_model"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       if len(parts) < 2:
           await update.message.reply_text(f"Current model: {ASSISTANT_MODEL}"); return "ok"
       new_model = parts[1].strip()
       import os
       os.environ["ASSISTANT_MODEL"] = new_model
       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")
       logging.info(f"[ADMIN] Assistant model changed to {new_model}")
       return "ok"

2) Save and restart the Flask app.

Validation after restart:
- /a_ping → pong
- /a_assistant_toggle OFF → toggle OFF confirmation
- /assistant_model → shows current model
- /assistant_model gpt-4o → switches model and confirms
- /a_logs_tail 50 level=info → shows logs'
2025-08-10 10:26:43,340 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:26:43,340 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121143, 'message': {'message_id': 4044, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821603, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:26:43,340 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:26:43,340 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:26:43,340 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:26:43,340 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:27:03,316 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:27:03,317 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121144, 'message': {'message_id': 4045, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821623, 'text': 'Add robust model fallback + persistence for the assistant.\n\nGOALS\n- Try preferred model first (from .assistant_model or ASSISTANT_MODEL env).\n- On any error (not found, quota, etc.), auto-fallback to gpt-4o.\n- Let /assistant_model update both ENV (live) and a small .assistant_model file (so the choice survives restarts).\n\nCHANGES\n\n1) assistant_dev.py — runtime-selected model + fallback\n----------------------------------------------------------------\n- Replace the existing model selection/assistant_codegen with the following (merge if parts exist):\n\nfrom pathlib import Path\nimport logging\nfrom openai import OpenAI\n\nPERSIST_PATH = Path(".assistant_model")\nDEFAULT_MODEL = os.getenv("ASSISTANT_MODEL", "gpt-5-thinking")\nFALLBACK_MODEL = "gpt-4o"\n\ndef _load_model_name() -> str:\n    try:\n        if PERSIST_PATH.exists():\n            name = PERSIST_PATH.read_text(encoding="utf-8").strip()\n            if name:\n                return name\n    except Exception:\n        pass\n    return DEFAULT_MODEL\n\ndef _save_model_name(name: str):\n    try:\n        PERSIST_PATH.write_text(name.strip(), encoding="utf-8")\n    except Exception as e:\n        logging.warning("could not persist model name: %s", e)\n\ndef get_current_model() -> str:\n    return _load_model_name()\n\ndef set_current_model(name: str) -> str:\n    name = name.strip()\n    _save_model_name(name)\n    return name\n\nclient = OpenAI(api_key=OPENAI_API_KEY)\n\ndef assistant_codegen(user_request: str) -> dict:\n    """Generate plan + diffs with preferred model, fallback to gpt-4o on error."""\n    model = get_current_model()\n    msg = f"User request:\\n{user_request}\\nProject: Python Telegram bot + Flask on Replit."\n    try:\n        r = client.chat.completions.create(\n            model=model,\n            temperature=0.2,\n            messages=[{"role":"system","content":SYSTEM},{"role":"user","content":msg}],\n        )\n    except Exception as e:\n        logging.warning("Assistant model %s failed: %s", model, e)\n        logging.warning("Falling back to %s", FALLBACK_MODEL)\n        r = client.chat.completions.create(\n            model=FALLBACK_MODEL,\n            temperature=0.2,\n            messages=[{"role":"system","content":SYSTEM},{"role":"user","content":msg}],\n        )\n    content = r.choices[0].message.content\n    try:\n        return json.loads(content)\n    except Exception:\n        return {"plan":"parse_error","diffs":[],"commands":[],"restart":"none","raw":content}\n\n# (optional helper exports)\nall = ["get_current_model", "set_current_model", "assistant_codegen", "apply_unified_diffs", "maybe_run_commands", "safe_restart_if_needed"]\n\n\n2) Flask webhook router — /assistant_model writes ENV and persists to file\n----------------------------------------------------------------\n- In your Flask webhook command routing (where we already added /assistant_model), replace that block with:\n\n   if text.startswith("/assistant_model"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       if len(parts) < 2:\n           # Show current from persistence\n           try:\n               from assistant_dev import get_current_model\n               cur = get_current_model()\n           except Exception:\n               cur = os.environ.get("ASSISTANT_MODEL", "gpt-5-thinking")\n           await update.message.reply_text(f"Current model: {cur}"); return "ok"\n       new_model = parts[1].strip()\n       import os\n       from assistant_dev import set_current_model\n       os.environ["ASSISTANT_MODEL"] = new_model   # live in-process\n       set_current_model(new_model)                # persist to .assistant_model\n       logging.info(f"[ADMIN] Assistant model changed to {new_model}")\n       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")\n       return "ok"', 'entities': [{'offset': 214, 'length': 16, 'type': 'bot_command'}, {'offset': 2471, 'length': 3, 'type': 'italic'}, {'offset': 2640, 'length': 16, 'type': 'bot_command'}, {'offset': 2818, 'length': 16, 'type': 'bot_command'}, {'offset': 2886, 'length': 16, 'type': 'bot_command'}, {'offset': 3686, 'length': 12, 'type': 'url'}]}}
2025-08-10 10:27:03,317 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:27:03,317 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add robust model fallback + persistence for the assistant.

GOALS
- Try preferred model first (from .assistant_model or ASSISTANT_MODEL env).
- On any error (not found, quota, etc.), auto-fallback to gpt-4o.
- Let /assistant_model update both ENV (live) and a small .assistant_model file (so the choice survives restarts).

CHANGES

1) assistant_dev.py — runtime-selected model + fallback
----------------------------------------------------------------
- Replace the existing model selection/assistant_codegen with the following (merge if parts exist):

from pathlib import Path
import logging
from openai import OpenAI

PERSIST_PATH = Path(".assistant_model")
DEFAULT_MODEL = os.getenv("ASSISTANT_MODEL", "gpt-5-thinking")
FALLBACK_MODEL = "gpt-4o"

def _load_model_name() -> str:
    try:
        if PERSIST_PATH.exists():
            name = PERSIST_PATH.read_text(encoding="utf-8").strip()
            if name:
                return name
    except Exception:
        pass
    return DEFAULT_MODEL

def _save_model_name(name: str):
    try:
        PERSIST_PATH.write_text(name.strip(), encoding="utf-8")
    except Exception as e:
        logging.warning("could not persist model name: %s", e)

def get_current_model() -> str:
    return _load_model_name()

def set_current_model(name: str) -> str:
    name = name.strip()
    _save_model_name(name)
    return name

client = OpenAI(api_key=OPENAI_API_KEY)

def assistant_codegen(user_request: str) -> dict:
    """Generate plan + diffs with preferred model, fallback to gpt-4o on error."""
    model = get_current_model()
    msg = f"User request:\n{user_request}\nProject: Python Telegram bot + Flask on Replit."
    try:
        r = client.chat.completions.create(
            model=model,
            temperature=0.2,
            messages=[{"role":"system","content":SYSTEM},{"role":"user","content":msg}],
        )
    except Exception as e:
        logging.warning("Assistant model %s failed: %s", model, e)
        logging.warning("Falling back to %s", FALLBACK_MODEL)
        r = client.chat.completions.create(
            model=FALLBACK_MODEL,
            temperature=0.2,
            messages=[{"role":"system","content":SYSTEM},{"role":"user","content":msg}],
        )
    content = r.choices[0].message.content
    try:
        return json.loads(content)
    except Exception:
        return {"plan":"parse_error","diffs":[],"commands":[],"restart":"none","raw":content}

# (optional helper exports)
all = ["get_current_model", "set_current_model", "assistant_codegen", "apply_unified_diffs", "maybe_run_commands", "safe_restart_if_needed"]


2) Flask webhook router — /assistant_model writes ENV and persists to file
----------------------------------------------------------------
- In your Flask webhook command routing (where we already added /assistant_model), replace that block with:

   if text.startswith("/assistant_model"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       if len(parts) < 2:
           # Show current from persistence
           try:
               from assistant_dev import get_current_model
               cur = get_current_model()
           except Exception:
               cur = os.environ.get("ASSISTANT_MODEL", "gpt-5-thinking")
           await update.message.reply_text(f"Current model: {cur}"); return "ok"
       new_model = parts[1].strip()
       import os
       from assistant_dev import set_current_model
       os.environ["ASSISTANT_MODEL"] = new_model   # live in-process
       set_current_model(new_model)                # persist to .assistant_model
       logging.info(f"[ADMIN] Assistant model changed to {new_model}")
       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")
       return "ok"'
2025-08-10 10:27:03,433 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:27:03,433 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121145, 'message': {'message_id': 4046, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821623, 'text': 'VALIDATION (after restart)\n- In Telegram:\n  1) /assistant_model\n     Expected: replies with the current model name (from .assistant_model or env).\n  2) /assistant_model gpt-4o\n     Expected: replies “✅ Assistant model changed to: gpt-4o”.\n  3) /assistant say hello (plan only)\n     Expected: DRY-RUN summary reply. If a model error occurs, it silently falls back to gpt-4o.\n  4) /a_logs_tail 80 level=info\n     Expected: you’ll see “[ADMIN] Assistant model changed to gpt-4o” in logs.\n\nNotes\n- No immediate reply is expected to THIS /assistant patch message itself.\n- If you don’t get responses to the validation commands, run: /a_logs_tail 200 level=error and check for tracebacks.', 'entities': [{'offset': 47, 'length': 16, 'type': 'bot_command'}, {'offset': 152, 'length': 16, 'type': 'bot_command'}, {'offset': 244, 'length': 10, 'type': 'bot_command'}, {'offset': 379, 'length': 12, 'type': 'bot_command'}, {'offset': 533, 'length': 10, 'type': 'bot_command'}, {'offset': 628, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:27:03,433 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:27:03,433 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'VALIDATION (after restart)
- In Telegram:
  1) /assistant_model
     Expected: replies with the current model name (from .assistant_model or env).
  2) /assistant_model gpt-4o
     Expected: replies “✅ Assistant model changed to: gpt-4o”.
  3) /assistant say hello (plan only)
     Expected: DRY-RUN summary reply. If a model error occurs, it silently falls back to gpt-4o.
  4) /a_logs_tail 80 level=info
     Expected: you’ll see “[ADMIN] Assistant model changed to gpt-4o” in logs.

Notes
- No immediate reply is expected to THIS /assistant patch message itself.
- If you don’t get responses to the validation commands, run: /a_logs_tail 200 level=error and check for tracebacks.'
2025-08-10 10:27:23,649 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:27:23,650 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121146, 'message': {'message_id': 4047, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821643, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:27:23,650 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:27:23,650 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:27:23,650 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:27:23,650 [INFO] app: [WEBHOOK] Unknown admin command: /assistant_model
2025-08-10 10:27:37,462 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:27:37,462 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121147, 'message': {'message_id': 4048, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821657, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:27:37,463 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:27:37,463 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 10:27:37,463 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 10:27:37,463 [INFO] app: [WEBHOOK] Unknown admin command: /assistant say hello (plan only)
2025-08-10 10:28:06,555 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:28:06,555 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121148, 'message': {'message_id': 4049, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821686, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:28:06,555 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:28:06,555 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:28:06,556 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:28:06,556 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:28:12,272 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:28:12,275 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121149, 'message': {'message_id': 4050, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821692, 'text': 'Inject admin+assistant routing block (with model switching + fallback) directly into the Flask webhook handler.\n\n1) Locate in Flask app (app.py or main.py) where POST webhook is handled and you see logging like:\n    logging.info("[WEBHOOK] Message from ...")\n   Right after text = update.message.text (or equivalent), insert:\n\n   from config import ASSISTANT_ADMIN_TELEGRAM_ID\n   import logging, os\n   from alerts import telegram as tg\n   from assistant_dev import set_current_model, get_current_model\n\n   async def _ensure_reply(func, update, context):\n       try:\n           await func(update, context)\n       except Exception as e:\n           logging.exception("flask router cmd error")\n           try:\n               await update.message.reply_text(f"❌ command failed: {e}")\n           except Exception:\n               pass\n\n   def _is_admin(u):\n       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n   # --- Flask-mode admin routing ---\n   if text.startswith("/a_ping"):\n       await _ensure_reply(tg.cmd_ping, update, context); return "ok"\n\n   if text.startswith("/a_logs_tail"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       context.args = text.split()[1:] if len(text.split()) > 1 else []\n       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"\n\n   if text.startswith("/assistant_model"):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       parts = text.split()\n       if len(parts) < 2:\n           await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"\n       new_model = parts[1].strip()\n       os.environ["ASSISTANT_MODEL"] = new_model\n       set_current_model(new_model)\n       logging.info(f"[ADMIN] Assistant model changed to {new_model}")\n       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")\n       return "ok"\n\n   if text.startswith("/assistant "):\n       if not _is_admin(update.effective_user):\n           await update.message.reply_text("Not authorized."); return "ok"\n       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"\n\n2) Save + restart app.', 'entities': [{'offset': 137, 'length': 6, 'type': 'url'}, {'offset': 147, 'length': 7, 'type': 'url'}, {'offset': 216, 'length': 12, 'type': 'url'}, {'offset': 274, 'length': 26, 'type': 'code'}, {'offset': 980, 'length': 7, 'type': 'bot_command'}, {'offset': 1085, 'length': 12, 'type': 'bot_command'}, {'offset': 1395, 'length': 16, 'type': 'bot_command'}, {'offset': 1817, 'length': 12, 'type': 'url'}, {'offset': 2009, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:28:12,275 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:28:12,275 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Inject admin+assistant routing block (with model switching + fallback) directly into the Flask webhook handler.

1) Locate in Flask app (app.py or main.py) where POST webhook is handled and you see logging like:
    logging.info("[WEBHOOK] Message from ...")
   Right after text = update.message.text (or equivalent), insert:

   from config import ASSISTANT_ADMIN_TELEGRAM_ID
   import logging, os
   from alerts import telegram as tg
   from assistant_dev import set_current_model, get_current_model

   async def _ensure_reply(func, update, context):
       try:
           await func(update, context)
       except Exception as e:
           logging.exception("flask router cmd error")
           try:
               await update.message.reply_text(f"❌ command failed: {e}")
           except Exception:
               pass

   def _is_admin(u):
       return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

   # --- Flask-mode admin routing ---
   if text.startswith("/a_ping"):
       await _ensure_reply(tg.cmd_ping, update, context); return "ok"

   if text.startswith("/a_logs_tail"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       context.args = text.split()[1:] if len(text.split()) > 1 else []
       await _ensure_reply(tg.cmd_logs_tail, update, context); return "ok"

   if text.startswith("/assistant_model"):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       parts = text.split()
       if len(parts) < 2:
           await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"
       new_model = parts[1].strip()
       os.environ["ASSISTANT_MODEL"] = new_model
       set_current_model(new_model)
       logging.info(f"[ADMIN] Assistant model changed to {new_model}")
       await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")
       return "ok"

   if text.startswith("/assistant "):
       if not _is_admin(update.effective_user):
           await update.message.reply_text("Not authorized."); return "ok"
       await _ensure_reply(tg.cmd_assistant_async, update, context); return "ok"

2) Save + restart app.'
2025-08-10 10:28:20,956 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:28:20,956 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:28:20,956 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:28:20,962 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:28:22,217 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:28:32,607 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:28:32,607 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121150, 'message': {'message_id': 4051, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821712, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:28:32,607 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:28:32,607 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:28:32,608 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:28:32,608 [INFO] app: [WEBHOOK] Unknown admin command: /assistant_model
2025-08-10 10:28:43,215 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:28:43,216 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121151, 'message': {'message_id': 4052, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821723, 'text': '/assistant_model gpt-4o', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:28:43,216 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:28:43,217 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model gpt-4o'
2025-08-10 10:28:43,217 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model gpt-4o
2025-08-10 10:28:43,217 [INFO] app: [WEBHOOK] Unknown admin command: /assistant_model gpt-4o
2025-08-10 10:28:51,197 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:28:51,197 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121152, 'message': {'message_id': 4053, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821731, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:28:51,197 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:28:51,198 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 10:28:51,198 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 10:28:51,198 [INFO] app: [WEBHOOK] Unknown admin command: /assistant say hello (plan only)
2025-08-10 10:32:05,965 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:32:05,966 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121153, 'message': {'message_id': 4054, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821925, 'text': '/a_logs_tail 120 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:32:05,966 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:32:05,966 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=info'
2025-08-10 10:32:05,966 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=info
2025-08-10 10:32:06,492 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=info' processed, response sent: 200
2025-08-10 10:33:09,170 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:33:09,170 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121154, 'message': {'message_id': 4056, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821988, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:33:09,171 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:33:09,171 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:33:09,171 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:33:09,171 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:33:17,389 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:33:17,389 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121155, 'message': {'message_id': 4057, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754821997, 'text': 'Open the file that logs "[WEBHOOK] Unknown admin command" and "[WEBHOOK] Received POST".\nShow the full Flask POST webhook handler function, plus 30 lines above and below the first log call.\nAlso print the file path.'}}
2025-08-10 10:33:17,390 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:33:17,390 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Open the file that logs "[WEBHOOK] Unknown admin command" and "[WEBHOOK] Received POST".
Show the full Flask POST webhook handler function, plus 30 lines above and below the first log call.
Also print the file path.'
2025-08-10 10:33:35,567 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:33:35,567 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121156, 'message': {'message_id': 4058, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822015, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:33:35,568 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:33:35,568 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:33:35,568 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:33:35,568 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:33:41,335 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:33:41,335 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121157, 'message': {'message_id': 4059, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822021, 'text': 'In the Flask webhook handler you just displayed (the one that logs "[WEBHOOK] Unknown admin command"),\nright AFTER you set text = ... and BEFORE any "unknown admin command" fallback, insert these branches:\n\nfrom config import ASSISTANT_ADMIN_TELEGRAM_ID\nimport os, logging\nfrom alerts import telegram as tg\nfrom assistant_dev import set_current_model, get_current_model\n\ndef _is_admin(u):\n    return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n# --- assistant model (persist + env) ---\nif text.startswith("/assistant_model"):\n    if not _is_admin(update.effective_user):\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    if len(parts) < 2:\n        await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"\n    new_model = parts[1].strip()\n    os.environ["ASSISTANT_MODEL"] = new_model      # live for this process\n    set_current_model(new_model)                    # persist to .assistant_model\n    logging.info(f"[ADMIN] Assistant model changed to {new_model}")\n    await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")\n    return "ok"\n\n# --- assistant codegen (async-safe via alerts.telegram) ---\nif text.startswith("/assistant "):\n    if not _is_admin(update.effective_user):\n        await update.message.reply_text("Not authorized."); return "ok"\n    try:\n        await tg.cmd_assistant_async(update, context)\n    except Exception as e:\n        logging.exception("assistant handler error")\n        await update.message.reply_text(f"❌ /assistant failed: {e}")\n    return "ok"', 'entities': [{'offset': 123, 'length': 10, 'type': 'code'}, {'offset': 517, 'length': 16, 'type': 'bot_command'}, {'offset': 990, 'length': 12, 'type': 'url'}, {'offset': 1234, 'length': 10, 'type': 'bot_command'}, {'offset': 1553, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:33:41,336 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:33:41,336 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'In the Flask webhook handler you just displayed (the one that logs "[WEBHOOK] Unknown admin command"),
right AFTER you set text = ... and BEFORE any "unknown admin command" fallback, insert these branches:

from config import ASSISTANT_ADMIN_TELEGRAM_ID
import os, logging
from alerts import telegram as tg
from assistant_dev import set_current_model, get_current_model

def _is_admin(u):
    return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

# --- assistant model (persist + env) ---
if text.startswith("/assistant_model"):
    if not _is_admin(update.effective_user):
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    if len(parts) < 2:
        await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"
    new_model = parts[1].strip()
    os.environ["ASSISTANT_MODEL"] = new_model      # live for this process
    set_current_model(new_model)                    # persist to .assistant_model
    logging.info(f"[ADMIN] Assistant model changed to {new_model}")
    await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")
    return "ok"

# --- assistant codegen (async-safe via alerts.telegram) ---
if text.startswith("/assistant "):
    if not _is_admin(update.effective_user):
        await update.message.reply_text("Not authorized."); return "ok"
    try:
        await tg.cmd_assistant_async(update, context)
    except Exception as e:
        logging.exception("assistant handler error")
        await update.message.reply_text(f"❌ /assistant failed: {e}")
    return "ok"'
2025-08-10 10:34:04,094 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:34:04,095 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:34:04,095 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:34:04,098 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:34:04,749 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:34:20,796 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:34:20,796 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121158, 'message': {'message_id': 4060, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822060, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:34:20,797 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:34:20,797 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 10:34:20,797 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 10:34:21,233 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 10:35:18,700 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:35:18,701 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121159, 'message': {'message_id': 4062, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822118, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:35:18,701 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:35:18,702 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:35:18,702 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:35:18,702 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:35:33,359 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:35:33,359 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121160, 'message': {'message_id': 4063, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822133, 'text': 'Locate the Flask webhook function that logs:\n- "[WEBHOOK] Received POST" and\n- "[WEBHOOK] Admin command detected: ..."\n\nIn that same function, immediately AFTER you compute text = ... and BEFORE any "unknown" / fallback branch,\ninsert the following routing for /assistant_model and /assistant (with explicit logs):\n\nfrom config import ASSISTANT_ADMIN_TELEGRAM_ID\nimport os, logging\nfrom alerts import telegram as tg\nfrom assistant_dev import set_current_model, get_current_model\n\ndef _is_admin(u):\n    return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID\n\n# --- assistant model (persist + env) ---\nif text.startswith("/assistant_model"):\n    logging.info("[WEBHOOK] Routing /assistant_model")\n    if not _is_admin(update.effective_user):\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    if len(parts) < 2:\n        await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"\n    new_model = parts[1].strip()\n    os.environ["ASSISTANT_MODEL"] = new_model      # live in-process\n    set_current_model(new_model)                    # persist to .assistant_model\n    logging.info(f"[ADMIN] Assistant model changed to {new_model}")\n    await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")\n    return "ok"\n\n# --- assistant codegen (async-safe via alerts.telegram) ---\nif text.startswith("/assistant "):\n    logging.info("[WEBHOOK] Routing /assistant")\n    if not _is_admin(update.effective_user):\n        await update.message.reply_text("Not authorized."); return "ok"\n    try:\n        await tg.cmd_assistant_async(update, context)\n    except Exception as e:\n        logging.exception("assistant handler error")\n        await update.message.reply_text(f"❌ /assistant failed: {e}")\n    return "ok"\n\nEnsure this block appears BEFORE any "Unknown admin command" path in the same function.\nRestart the app after patch.', 'entities': [{'offset': 173, 'length': 10, 'type': 'code'}, {'offset': 261, 'length': 16, 'type': 'bot_command'}, {'offset': 282, 'length': 10, 'type': 'bot_command'}, {'offset': 626, 'length': 16, 'type': 'bot_command'}, {'offset': 650, 'length': 12, 'type': 'url'}, {'offset': 682, 'length': 16, 'type': 'bot_command'}, {'offset': 1148, 'length': 12, 'type': 'url'}, {'offset': 1392, 'length': 10, 'type': 'bot_command'}, {'offset': 1411, 'length': 12, 'type': 'url'}, {'offset': 1443, 'length': 10, 'type': 'bot_command'}, {'offset': 1760, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:35:33,359 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:35:33,360 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Locate the Flask webhook function that logs:
- "[WEBHOOK] Received POST" and
- "[WEBHOOK] Admin command detected: ..."

In that same function, immediately AFTER you compute text = ... and BEFORE any "unknown" / fallback branch,
insert the following routing for /assistant_model and /assistant (with explicit logs):

from config import ASSISTANT_ADMIN_TELEGRAM_ID
import os, logging
from alerts import telegram as tg
from assistant_dev import set_current_model, get_current_model

def _is_admin(u):
    return getattr(u, "id", None) == ASSISTANT_ADMIN_TELEGRAM_ID

# --- assistant model (persist + env) ---
if text.startswith("/assistant_model"):
    logging.info("[WEBHOOK] Routing /assistant_model")
    if not _is_admin(update.effective_user):
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    if len(parts) < 2:
        await update.message.reply_text(f"Current model: {get_current_model()}"); return "ok"
    new_model = parts[1].strip()
    os.environ["ASSISTANT_MODEL"] = new_model      # live in-process
    set_current_model(new_model)                    # persist to .assistant_model
    logging.info(f"[ADMIN] Assistant model changed to {new_model}")
    await update.message.reply_text(f"✅ Assistant model changed to: {new_model}")
    return "ok"

# --- assistant codegen (async-safe via alerts.telegram) ---
if text.startswith("/assistant "):
    logging.info("[WEBHOOK] Routing /assistant")
    if not _is_admin(update.effective_user):
        await update.message.reply_text("Not authorized."); return "ok"
    try:
        await tg.cmd_assistant_async(update, context)
    except Exception as e:
        logging.exception("assistant handler error")
        await update.message.reply_text(f"❌ /assistant failed: {e}")
    return "ok"

Ensure this block appears BEFORE any "Unknown admin command" path in the same function.
Restart the app after patch.'
2025-08-10 10:36:58,019 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:36:58,020 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:36:58,021 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:36:58,024 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:36:58,766 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:40:15,934 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:15,934 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:15,934 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:40:15,937 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:40:16,798 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:40:19,002 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:19,002 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:19,002 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:40:19,005 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:40:19,917 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:40:20,383 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:40:20,383 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant_model'}}
2025-08-10 10:40:20,384 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:40:20,384 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant_model'
2025-08-10 10:40:20,384 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:40:20,384 [ERROR] app: assistant_model handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 215, in webhook
    from assistant_dev import set_current_model, get_current_model
ImportError: cannot import name 'set_current_model' from 'assistant_dev' (/home/runner/workspace/assistant_dev.py)
2025-08-10 10:40:20,820 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:40:22,043 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:40:22,044 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant_model gpt-4o'}}
2025-08-10 10:40:22,045 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:40:22,045 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant_model gpt-4o'
2025-08-10 10:40:22,045 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model gpt-4o
2025-08-10 10:40:22,045 [ERROR] app: assistant_model handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 215, in webhook
    from assistant_dev import set_current_model, get_current_model
ImportError: cannot import name 'set_current_model' from 'assistant_dev' (/home/runner/workspace/assistant_dev.py)
2025-08-10 10:40:22,424 [INFO] app: [WEBHOOK] Command '/assistant_model gpt-4o' processed, response sent: 200
2025-08-10 10:40:23,589 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:40:23,589 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/help'}}
2025-08-10 10:40:23,590 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:40:23,590 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/help'
2025-08-10 10:40:23,590 [INFO] app: [WEBHOOK] Admin command detected: /help
2025-08-10 10:40:24,001 [INFO] app: [WEBHOOK] Command '/help' processed, response sent: 200
2025-08-10 10:40:31,726 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:31,726 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:40:31,726 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:40:31,729 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:40:32,416 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:41:58,783 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:41:58,784 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121161, 'message': {'message_id': 4067, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822518, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:41:58,784 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:41:58,784 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:41:58,784 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:41:58,784 [ERROR] app: assistant_model handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 215, in webhook
    from assistant_dev import set_current_model, get_current_model
ImportError: cannot import name 'set_current_model' from 'assistant_dev' (/home/runner/workspace/assistant_dev.py)
2025-08-10 10:41:59,232 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:42:10,332 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:42:10,333 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121162, 'message': {'message_id': 4069, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822530, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:42:10,333 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:42:10,333 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:42:10,333 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:42:10,333 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:42:15,425 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:42:15,425 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121163, 'message': {'message_id': 4070, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822535, 'text': '/ping', 'entities': [{'offset': 0, 'length': 5, 'type': 'bot_command'}]}}
2025-08-10 10:42:15,426 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:42:15,426 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/ping'
2025-08-10 10:42:15,426 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 10:42:15,790 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 10:43:55,716 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:43:55,717 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:43:55,717 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:43:55,720 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:43:56,502 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:44:06,141 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:44:06,141 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant_model'}}
2025-08-10 10:44:06,141 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:44:06,142 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant_model'
2025-08-10 10:44:06,142 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:44:06,142 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:44:06,589 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:44:06,626 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:44:06,627 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant_model gpt-4o'}}
2025-08-10 10:44:06,627 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:44:06,627 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant_model gpt-4o'
2025-08-10 10:44:06,627 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model gpt-4o
2025-08-10 10:44:06,627 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:44:06,628 [INFO] root: [ADMIN] Assistant model persisted to gpt-4o
2025-08-10 10:44:06,628 [INFO] app: [ADMIN] Assistant model changed to gpt-4o
2025-08-10 10:44:07,026 [INFO] app: [WEBHOOK] Command '/assistant_model gpt-4o' processed, response sent: 200
2025-08-10 10:45:04,713 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:45:04,714 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121164, 'message': {'message_id': 4074, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822688, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:45:04,714 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:45:04,714 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:45:04,714 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:45:04,714 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:45:05,080 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:45:05,197 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:45:05,197 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121165, 'message': {'message_id': 4075, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822692, 'text': '/ping', 'entities': [{'offset': 0, 'length': 5, 'type': 'bot_command'}]}}
2025-08-10 10:45:05,197 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:45:05,197 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/ping'
2025-08-10 10:45:05,197 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 10:45:05,570 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 10:45:05,686 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:45:05,686 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121166, 'message': {'message_id': 4076, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822703, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:45:05,687 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:45:05,687 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:45:05,687 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:45:05,687 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:45:06,052 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:45:21,245 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:45:21,246 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121167, 'message': {'message_id': 4080, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822721, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:45:21,246 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:45:21,246 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:45:21,246 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:45:21,246 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:45:27,281 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:45:27,282 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121168, 'message': {'message_id': 4081, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822727, 'text': '/assistant_model', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:45:27,282 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:45:27,282 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model'
2025-08-10 10:45:27,282 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model
2025-08-10 10:45:27,282 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:45:27,665 [INFO] app: [WEBHOOK] Command '/assistant_model' processed, response sent: 200
2025-08-10 10:47:00,667 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:47:00,668 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121169, 'message': {'message_id': 4083, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822820, 'text': '/assistant_model gpt-5-thinking', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 10:47:00,668 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:47:00,668 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model gpt-5-thinking'
2025-08-10 10:47:00,668 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model gpt-5-thinking
2025-08-10 10:47:00,668 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 10:47:00,669 [INFO] root: [ADMIN] Assistant model persisted to gpt-5-thinking
2025-08-10 10:47:00,669 [INFO] app: [ADMIN] Assistant model changed to gpt-5-thinking
2025-08-10 10:47:01,052 [INFO] app: [WEBHOOK] Command '/assistant_model gpt-5-thinking' processed, response sent: 200
2025-08-10 10:47:11,276 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:47:11,276 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121170, 'message': {'message_id': 4085, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822831, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:47:11,277 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:47:11,277 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 10:47:11,277 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 10:47:11,277 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:47:11,639 [INFO] app: [WEBHOOK] Command '/assistant say hello (plan only)' processed, response sent: 200
2025-08-10 10:48:24,437 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:48:24,437 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121171, 'message': {'message_id': 4087, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822904, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:48:24,437 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:48:24,437 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:48:24,437 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:48:24,438 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:48:32,261 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:48:32,262 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121172, 'message': {'message_id': 4088, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754822912, 'text': 'Add a Flask-safe assistant handler that works without PTB, with GPT-5 → GPT-4o fallback.\n\nCHANGES\n\n1) alerts/telegram.py – add a PTB-independent async handler\n-----------------------------------------------------------\nAdd this near your other command handlers:\n\nimport logging, json\nfrom assistant_dev import get_current_model, set_current_model\nfrom openai import OpenAI\nimport os\n\n# Ensure we have an API key and client\nOPENAI_API_KEY = os.environ.get("OPENAI_API_KEY") or os.environ.get("OPENAI_APIKEY") or os.environ.get("OPENAI_KEY")\n_client = OpenAI(api_key=OPENAI_API_KEY)\n\nasync def cmd_assistant_async_flask(update, context):\n    """Flask-safe assistant handler: tries current model, falls back to gpt-4o."""\n    try:\n        text = (update.message.text or "")\n        # everything after the first space is the human request\n        req = text.partition(" ")[2].strip()\n        if not req:\n            await update.message.reply_text("Usage: /assistant <request>"); return\n\n        preferred = get_current_model()\n        fallback = "gpt-4o"\n\n        sys = "You are an engineering assistant. Respond concisely. If user says \'(plan only)\', return a high-level plan, no code application."\n\n        def _call(model):\n            return _client.chat.completions.create(\n                model=model,\n                temperature=0.2,\n                messages=[\n                    {"role": "system", "content": sys},\n                    {"role": "user", "content": req},\n                ],\n            ).choices[0].message.content\n\n        try:\n            out = _call(preferred)\n            used = preferred\n        except Exception as e:\n            logging.warning("assistant model %s failed: %s ; falling back to gpt-4o", preferred, e)\n            out = _call(fallback)\n            used = fallback\n\n        # keep under Telegram limits\n        if len(out) > 3500:\n            out = out[:3500] + "\\n\\n…(truncated)…"\n\n        await update.message.reply_text(f"Model: {used}\\n\\n{out}")\n    except Exception as e:\n        logging.exception("cmd_assistant_async_flask error")\n        await update.message.reply_text(f"❌ /assistant failed: {e}")\n\n2) app.py (Flask webhook router) – route /assistant to this new handler\n----------------------------------------------------------------------\nIn the same webhook function where you already route /assistant_model and /a_logs_tail,\nreplace the existing /assistant block with:\n\nif text.startswith("/assistant "):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    from alerts import telegram as tg\n    await tg.cmd_assistant_async_flask(update, context)\n    return "ok"\n\nVALIDATION\n- Restart the app.\n- Send in Telegram:\n  1) /assistant say hello (plan only)\n     Expected: a short plan, prefixed with "Model: gpt-5-thinking" if available, otherwise "Model: gpt-4o".\n  2) /assistant_model gpt-4o\n     Expected: "✅ Assistant model changed to: gpt-4o"\n  3) /assistant say hello (plan only)\n     Expected: "Model: gpt-4o" with a plan.\n- Optional: /a_logs_tail 120 level=info\n  Expected: a warning log about fallback if gpt-5-thinking wasn’t available.', 'entities': [{'offset': 109, 'length': 11, 'type': 'url'}, {'offset': 952, 'length': 10, 'type': 'bot_command'}, {'offset': 2123, 'length': 10, 'type': 'bot_command'}, {'offset': 2152, 'length': 6, 'type': 'url'}, {'offset': 2190, 'length': 10, 'type': 'bot_command'}, {'offset': 2345, 'length': 16, 'type': 'bot_command'}, {'offset': 2366, 'length': 12, 'type': 'bot_command'}, {'offset': 2401, 'length': 10, 'type': 'bot_command'}, {'offset': 2445, 'length': 10, 'type': 'bot_command'}, {'offset': 2780, 'length': 10, 'type': 'bot_command'}, {'offset': 2926, 'length': 16, 'type': 'bot_command'}, {'offset': 3009, 'length': 10, 'type': 'bot_command'}, {'offset': 3098, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:48:32,262 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:48:32,262 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add a Flask-safe assistant handler that works without PTB, with GPT-5 → GPT-4o fallback.

CHANGES

1) alerts/telegram.py – add a PTB-independent async handler
-----------------------------------------------------------
Add this near your other command handlers:

import logging, json
from assistant_dev import get_current_model, set_current_model
from openai import OpenAI
import os

# Ensure we have an API key and client
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY") or os.environ.get("OPENAI_APIKEY") or os.environ.get("OPENAI_KEY")
_client = OpenAI(api_key=OPENAI_API_KEY)

async def cmd_assistant_async_flask(update, context):
    """Flask-safe assistant handler: tries current model, falls back to gpt-4o."""
    try:
        text = (update.message.text or "")
        # everything after the first space is the human request
        req = text.partition(" ")[2].strip()
        if not req:
            await update.message.reply_text("Usage: /assistant <request>"); return

        preferred = get_current_model()
        fallback = "gpt-4o"

        sys = "You are an engineering assistant. Respond concisely. If user says '(plan only)', return a high-level plan, no code application."

        def _call(model):
            return _client.chat.completions.create(
                model=model,
                temperature=0.2,
                messages=[
                    {"role": "system", "content": sys},
                    {"role": "user", "content": req},
                ],
            ).choices[0].message.content

        try:
            out = _call(preferred)
            used = preferred
        except Exception as e:
            logging.warning("assistant model %s failed: %s ; falling back to gpt-4o", preferred, e)
            out = _call(fallback)
            used = fallback

        # keep under Telegram limits
        if len(out) > 3500:
            out = out[:3500] + "\n\n…(truncated)…"

        await update.message.reply_text(f"Model: {used}\n\n{out}")
    except Exception as e:
        logging.exception("cmd_assistant_async_flask error")
        await update.message.reply_text(f"❌ /assistant failed: {e}")

2) app.py (Flask webhook router) – route /assistant to this new handler
----------------------------------------------------------------------
In the same webhook function where you already route /assistant_model and /a_logs_tail,
replace the existing /assistant block with:

if text.startswith("/assistant "):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    from alerts import telegram as tg
    await tg.cmd_assistant_async_flask(update, context)
    return "ok"

VALIDATION
- Restart the app.
- Send in Telegram:
  1) /assistant say hello (plan only)
     Expected: a short plan, prefixed with "Model: gpt-5-thinking" if available, otherwise "Model: gpt-4o".
  2) /assistant_model gpt-4o
     Expected: "✅ Assistant model changed to: gpt-4o"
  3) /assistant say hello (plan only)
     Expected: "Model: gpt-4o" with a plan.
- Optional: /a_logs_tail 120 level=info
  Expected: a warning log about fallback if gpt-5-thinking wasn’t available.'
2025-08-10 10:49:00,018 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:49:00,019 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:49:00,019 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:49:00,022 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:49:00,692 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:50:16,278 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:50:16,279 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121173, 'message': {'message_id': 4089, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823015, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:50:16,279 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:50:16,279 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 10:50:16,279 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 10:50:16,279 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 10:50:28,688 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:50:28,688 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121174, 'message': {'message_id': 4090, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823028, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:50:28,688 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:50:28,688 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 10:50:28,689 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 10:50:28,689 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:50:29,105 [INFO] app: [WEBHOOK] Command '/assistant say hello (plan only)' processed, response sent: 200
2025-08-10 10:55:51,322 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:55:51,322 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:55:51,322 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:55:51,326 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:55:52,058 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:55:53,449 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:55:53,449 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant help me debug a simple issue'}}
2025-08-10 10:55:53,449 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:55:53,449 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant help me debug a simple issue'
2025-08-10 10:55:53,449 [INFO] app: [WEBHOOK] Admin command detected: /assistant help me debug a simple issue
2025-08-10 10:55:53,449 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:55:53,453 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 10:55:53,462 [ERROR] app: assistant handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 258, in webhook
    asyncio.create_task(tg.cmd_assistant_async_flask(mock_update, None))
  File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/asyncio/tasks.py", line 381, in create_task
    loop = events.get_running_loop()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
RuntimeError: no running event loop
2025-08-10 10:55:53,872 [INFO] app: [WEBHOOK] Command '/assistant help me debug a simple issue' processed, response sent: 200
2025-08-10 10:56:01,793 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:56:01,793 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:56:01,794 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:56:01,796 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:56:02,477 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:56:41,500 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:56:41,501 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:56:41,501 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:56:41,503 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:56:42,240 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:56:54,746 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:56:54,746 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121175, 'message': {'message_id': 4093, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823414, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 10:56:54,746 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:56:54,746 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 10:56:54,746 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 10:56:54,747 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:56:54,747 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 10:56:54,755 [ERROR] app: assistant handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 258, in webhook
    asyncio.create_task(tg.cmd_assistant_async_flask(mock_update, None))
  File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/asyncio/tasks.py", line 381, in create_task
    loop = events.get_running_loop()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
RuntimeError: no running event loop
2025-08-10 10:56:55,207 [INFO] app: [WEBHOOK] Command '/assistant say hello (plan only)' processed, response sent: 200
2025-08-10 10:57:22,775 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 10:57:22,775 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121176, 'message': {'message_id': 4095, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823442, 'text': '/a_logs_tail 150 level=error', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 10:57:22,775 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:57:22,775 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=error'
2025-08-10 10:57:22,775 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=error
2025-08-10 10:57:23,154 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=error' processed, response sent: 200
2025-08-10 10:58:46,055 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:58:46,055 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:58:46,055 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:58:46,058 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:58:47,007 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:58:55,183 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:58:55,183 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:58:55,183 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:58:55,186 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:58:55,876 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:58:57,036 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:58:57,037 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant what is 2+2?'}}
2025-08-10 10:58:57,037 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:58:57,037 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant what is 2+2?'
2025-08-10 10:58:57,037 [INFO] app: [WEBHOOK] Admin command detected: /assistant what is 2+2?
2025-08-10 10:58:57,037 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:58:57,045 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 10:58:57,589 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 404 Not Found"
2025-08-10 10:58:57,591 [WARNING] root: assistant gpt-5-thinking failed: Error code: 404 - {'error': {'message': 'The model `gpt-5-thinking` does not exist or you do not have access to it.', 'type': 'invalid_request_error', 'param': None, 'code': 'model_not_found'}}; falling back to gpt-4o
2025-08-10 10:58:58,431 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 10:58:58,859 [INFO] app: [WEBHOOK] Command '/assistant what is 2+2?' processed, response sent: 200
2025-08-10 10:59:47,477 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:59:47,480 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 10:59:47,480 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 10:59:47,483 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 10:59:48,310 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 10:59:49,352 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 10:59:49,353 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/assistant explain what Flask is in 2 sentences'}}
2025-08-10 10:59:49,353 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 10:59:49,353 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/assistant explain what Flask is in 2 sentences'
2025-08-10 10:59:49,353 [INFO] app: [WEBHOOK] Admin command detected: /assistant explain what Flask is in 2 sentences
2025-08-10 10:59:49,353 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 10:59:49,354 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 10:59:49,681 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 404 Not Found"
2025-08-10 10:59:49,682 [WARNING] root: assistant gpt-5-thinking failed: Error code: 404 - {'error': {'message': 'The model `gpt-5-thinking` does not exist or you do not have access to it.', 'type': 'invalid_request_error', 'param': None, 'code': 'model_not_found'}}; falling back to gpt-4o
2025-08-10 10:59:51,331 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 10:59:51,756 [INFO] app: [WEBHOOK] Command '/assistant explain what Flask is in 2 sentences' processed, response sent: 200
2025-08-10 11:00:43,941 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:00:43,943 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:00:43,943 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:00:43,946 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:00:44,621 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:00:45,621 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:00:45,622 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 11:00:45,622 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:00:45,622 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/ping'
2025-08-10 11:00:45,622 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 11:00:46,050 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 11:00:52,587 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:00:52,589 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:00:52,598 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:00:52,600 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:00:53,362 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:01:35,428 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:01:35,428 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121177, 'message': {'message_id': 4100, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823694, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:01:35,428 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:01:35,428 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 11:01:35,428 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 11:01:35,429 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:01:35,429 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:01:35,768 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 404 Not Found"
2025-08-10 11:01:35,769 [WARNING] root: assistant gpt-5-thinking failed: Error code: 404 - {'error': {'message': 'The model `gpt-5-thinking` does not exist or you do not have access to it.', 'type': 'invalid_request_error', 'param': None, 'code': 'model_not_found'}}; falling back to gpt-4o
2025-08-10 11:01:39,152 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:01:39,587 [INFO] app: [WEBHOOK] Command '/assistant say hello (plan only)' processed, response sent: 200
2025-08-10 11:02:06,835 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:02:06,836 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121178, 'message': {'message_id': 4102, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823726, 'text': '/assistant_model gpt-4o', 'entities': [{'offset': 0, 'length': 16, 'type': 'bot_command'}]}}
2025-08-10 11:02:06,836 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:02:06,836 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant_model gpt-4o'
2025-08-10 11:02:06,836 [INFO] app: [WEBHOOK] Admin command detected: /assistant_model gpt-4o
2025-08-10 11:02:06,836 [INFO] app: [WEBHOOK] Routing /assistant_model
2025-08-10 11:02:06,840 [INFO] root: [ADMIN] Assistant model persisted to gpt-4o
2025-08-10 11:02:06,840 [INFO] app: [ADMIN] Assistant model changed to gpt-4o
2025-08-10 11:02:07,216 [INFO] app: [WEBHOOK] Command '/assistant_model gpt-4o' processed, response sent: 200
2025-08-10 11:02:15,301 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:02:15,302 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121179, 'message': {'message_id': 4104, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823735, 'text': '/assistant say hello (plan only)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:02:15,302 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:02:15,302 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant say hello (plan only)'
2025-08-10 11:02:15,302 [INFO] app: [WEBHOOK] Admin command detected: /assistant say hello (plan only)
2025-08-10 11:02:15,302 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:02:17,695 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:02:18,080 [INFO] app: [WEBHOOK] Command '/assistant say hello (plan only)' processed, response sent: 200
2025-08-10 11:02:25,887 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:02:25,887 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121180, 'message': {'message_id': 4106, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754823745, 'text': '/a_logs_tail 120 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 11:02:25,887 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:02:25,887 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=info'
2025-08-10 11:02:25,888 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=info
2025-08-10 11:02:26,272 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=info' processed, response sent: 200
2025-08-10 11:07:20,172 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:07:20,172 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121181, 'message': {'message_id': 4108, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824039, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:07:20,172 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:07:20,173 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 11:07:20,173 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 11:07:20,173 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 11:07:28,171 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:07:28,171 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121182, 'message': {'message_id': 4109, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824048, 'text': 'Add a versioned rules system with three commands: /rules_show, /rules_reload, /fetch_now.\nKeep everything working in Flask webhook mode (no PTB required).\n\nFILES & CHANGES\n===============\n\n1) Create rules.yaml at repo root (only if it doesn\'t exist) with sane defaults:\n\n# rules.yaml\nversion: 1\nupdated_at: "2025-08-10T00:00:00Z"\nnetwork: solana\nsources:\n  - pump.fun\n  - dexscreener\n  - jup.ag\nscan:\n  max_age_minutes: 180           # new tokens only\n  holders_min: 75\n  holders_max: 5000\n  mcap_min_usd: 50000\n  mcap_max_usd: 2000000\n  liquidity_min_usd: 10000\n  renounced_mint_auth: true      # prefer mint auth revoked\n  renounced_freeze_auth: true\n  blacklist_contracts: []        # add addresses to exclude\n  include_keywords: []           # boost tokens matching these words\n  exclude_keywords:\n    - rug\n    - scam\nrisk:\n  max_score: 70                  # lower is safer; 0..100\n  weights:\n    age: 0.2\n    holders: 0.2\n    liquidity: 0.25\n    mcap: 0.25\n    renounce: 0.1\noutput:\n  max_results: 10\n  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]\n\n2) Add rules.py module to load/validate/cache the YAML:\n\n# rules.py\nimport os, time, logging, yaml\nfrom pathlib import Path\nfrom typing import Tuple, Dict, Any\n\nRULES_PATH = Path("rules.yaml")\n_cache: Dict[str, Any] = {"data": None, "mtime": None, "version": None}\n\nDEFAULT_RULES = """version: 1\nupdated_at: "2025-08-10T00:00:00Z"\nnetwork: solana\nsources: [pump.fun, dexscreener, jup.ag]\nscan:\n  max_age_minutes: 180\n  holders_min: 75\n  holders_max: 5000\n  mcap_min_usd: 50000\n  mcap_max_usd: 2000000\n  liquidity_min_usd: 10000\n  renounced_mint_auth: true\n  renounced_freeze_auth: true\n  blacklist_contracts: []\n  include_keywords: []\n  exclude_keywords: [rug, scam]\nrisk:\n  max_score: 70\n  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}\noutput:\n  max_results: 10\n  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]\n"""\n\ndef ensure_default_rules():\n    if not RULES_PATH.exists():\n        RULES_PATH.write_text(DEFAULT_RULES, encoding="utf-8")\n        logging.info("[RULES] Created default rules.yaml")\n\ndef _validate(d: Dict[str, Any]) -> Tuple[bool, str]:\n    try:\n        for k in ["version", "network", "scan", "risk", "output"]:\n            if k not in d: return False, f"Missing key: {k}"\n        return True, "ok"\n    except Exception as e:\n        return False, str(e)\n\ndef load_rules(force: bool=False) -> Dict[str, Any]:\n    ensure_default_rules()\n    mtime = RULES_PATH.stat().st_mtime\n    if not force and _cache["data"] is not None and _cache["mtime"] == mtime:\n        return _cache["data"]\n    data = yaml.safe_load(RULES_PATH.read_text(encoding="utf-8"))\n    ok, msg = _validate(data)\n    if not ok:\n        raise ValueError(f"rules.yaml invalid: {msg}")\n    _cache.update({"data": data, "mtime": mtime, "version": data.get("version")})\n    logging.info("[RULES] Loaded (v%s, mtime=%s)", data.get("version"), mtime)\n    return data\n\ndef render_rules() -> str:\n    try:\n        text = RULES_PATH.read_text(encoding="utf-8")\n        # keep replies under ~3.8k chars for Telegram\n        return text if len(text) < 3800 else text[:3700] + "\\n…(truncated)…"\n    except Exception as e:\n        return f"# rules.yaml read error: {e}"\n\ndef get_rules_version() -> str:\n    if _cache["version"] is None:\n        load_rules()\n    return str(_cache["version"])\n\n3) Extend alerts/telegram.py with sync helpers the webhook can call:\n\n# in alerts/telegram.py\nimport logging\nfrom rules import load_rules, render_rules, get_rules_version\n\ndef cmd_rules_show_sync() -> str:\n    try:\n        load_rules()\n        body = render_rules()\n        return f"*rules.yaml (v{get_rules_version()})*:\\n```\\n{body}\\n```"\n    except Exception as e:\n        logging.exception("rules_show error")\n        return f"❌ rules_show failed: {e}"', 'entities': [{'offset': 50, 'length': 11, 'type': 'bot_command'}, {'offset': 63, 'length': 13, 'type': 'bot_command'}, {'offset': 78, 'length': 10, 'type': 'bot_command'}, {'offset': 359, 'length': 8, 'type': 'url'}, {'offset': 388, 'length': 6, 'type': 'url'}, {'offset': 1090, 'length': 8, 'type': 'url'}, {'offset': 1142, 'length': 8, 'type': 'url'}, {'offset': 1440, 'length': 8, 'type': 'url'}, {'offset': 1463, 'length': 6, 'type': 'url'}, {'offset': 2089, 'length': 12, 'type': 'url'}, {'offset': 2894, 'length': 12, 'type': 'url'}, {'offset': 3421, 'length': 11, 'type': 'url'}, {'offset': 3486, 'length': 11, 'type': 'url'}]}}
2025-08-10 11:07:28,171 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:07:28,171 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Add a versioned rules system with three commands: /rules_show, /rules_reload, /fetch_now.
Keep everything working in Flask webhook mode (no PTB required).

FILES & CHANGES
===============

1) Create rules.yaml at repo root (only if it doesn't exist) with sane defaults:

# rules.yaml
version: 1
updated_at: "2025-08-10T00:00:00Z"
network: solana
sources:
  - pump.fun
  - dexscreener
  - jup.ag
scan:
  max_age_minutes: 180           # new tokens only
  holders_min: 75
  holders_max: 5000
  mcap_min_usd: 50000
  mcap_max_usd: 2000000
  liquidity_min_usd: 10000
  renounced_mint_auth: true      # prefer mint auth revoked
  renounced_freeze_auth: true
  blacklist_contracts: []        # add addresses to exclude
  include_keywords: []           # boost tokens matching these words
  exclude_keywords:
    - rug
    - scam
risk:
  max_score: 70                  # lower is safer; 0..100
  weights:
    age: 0.2
    holders: 0.2
    liquidity: 0.25
    mcap: 0.25
    renounce: 0.1
output:
  max_results: 10
  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]

2) Add rules.py module to load/validate/cache the YAML:

# rules.py
import os, time, logging, yaml
from pathlib import Path
from typing import Tuple, Dict, Any

RULES_PATH = Path("rules.yaml")
_cache: Dict[str, Any] = {"data": None, "mtime": None, "version": None}

DEFAULT_RULES = """version: 1
updated_at: "2025-08-10T00:00:00Z"
network: solana
sources: [pump.fun, dexscreener, jup.ag]
scan:
  max_age_minutes: 180
  holders_min: 75
  holders_max: 5000
  mcap_min_usd: 50000
  mcap_max_usd: 2000000
  liquidity_min_usd: 10000
  renounced_mint_auth: true
  renounced_freeze_auth: true
  blacklist_contracts: []
  include_keywords: []
  exclude_keywords: [rug, scam]
risk:
  max_score: 70
  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}
output:
  max_results: 10
  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]
"""

def ensure_default_rules():
    if not RULES_PATH.exists():
        RULES_PATH.write_text(DEFAULT_RULES, encoding="utf-8")
        logging.info("[RULES] Created default rules.yaml")

def _validate(d: Dict[str, Any]) -> Tuple[bool, str]:
    try:
        for k in ["version", "network", "scan", "risk", "output"]:
            if k not in d: return False, f"Missing key: {k}"
        return True, "ok"
    except Exception as e:
        return False, str(e)

def load_rules(force: bool=False) -> Dict[str, Any]:
    ensure_default_rules()
    mtime = RULES_PATH.stat().st_mtime
    if not force and _cache["data"] is not None and _cache["mtime"] == mtime:
        return _cache["data"]
    data = yaml.safe_load(RULES_PATH.read_text(encoding="utf-8"))
    ok, msg = _validate(data)
    if not ok:
        raise ValueError(f"rules.yaml invalid: {msg}")
    _cache.update({"data": data, "mtime": mtime, "version": data.get("version")})
    logging.info("[RULES] Loaded (v%s, mtime=%s)", data.get("version"), mtime)
    return data

def render_rules() -> str:
    try:
        text = RULES_PATH.read_text(encoding="utf-8")
        # keep replies under ~3.8k chars for Telegram
        return text if len(text) < 3800 else text[:3700] + "\n…(truncated)…"
    except Exception as e:
        return f"# rules.yaml read error: {e}"

def get_rules_version() -> str:
    if _cache["version"] is None:
        load_rules()
    return str(_cache["version"])

3) Extend alerts/telegram.py with sync helpers the webhook can call:

# in alerts/telegram.py
import logging
from rules import load_rules, render_rules, get_rules_version

def cmd_rules_show_sync() -> str:
    try:
        load_rules()
        body = render_rules()
        return f"*rules.yaml (v{get_rules_version()})*:\n```\n{body}\n```"
    except Exception as e:
        logging.exception("rules_show error")
        return f"❌ rules_show failed: {e}"'
2025-08-10 11:07:28,287 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:07:28,301 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121183, 'message': {'message_id': 4110, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824048, 'text': 'def cmd_rules_reload_sync() -> str:\n    try:\n        load_rules(force=True)\n        return f"✅ Rules reloaded (v{get_rules_version()})"\n    except Exception as e:\n        logging.exception("rules_reload error")\n        return f"❌ rules_reload failed: {e}"\n\ndef cmd_fetch_now_sync() -> str:\n    """\n    Stub: score and return up to N tokens using current rules.\n    Replace the mock list with real Solana data sources next.\n    """\n    try:\n        rules = load_rules()\n        N = int(rules.get("output",{}).get("max_results", 10))\n        scan = rules.get("scan", {})\n        # --- MOCK DATA (replace later) ---\n        items = [\n            {"symbol":"FNM","name":"FennecMan","holders":210,"mcap_usd":120000,"liquidity_usd":18000,"age_min":45,"risk":38},\n            {"symbol":"YOLO","name":"YoloCat","holders":560,"mcap_usd":350000,"liquidity_usd":42000,"age_min":70,"risk":52},\n            {"symbol":"ZAP","name":"ZapFox","holders":95,"mcap_usd":80000,"liquidity_usd":12000,"age_min":30,"risk":41},\n        ]\n        # simple filtering based on rules\n        out = []\n        for t in items:\n            if t["holders"] < scan.get("holders_min", 0): continue\n            if t["holders"] > scan.get("holders_max", 10**9): continue\n            if t["mcap_usd"] < scan.get("mcap_min_usd", 0): continue\n            if t["mcap_usd"] > scan.get("mcap_max_usd", 10**12): continue\n            if t["liquidity_usd"] < scan.get("liquidity_min_usd", 0): continue\n            if t["age_min"] > scan.get("max_age_minutes", 10**9): continue\n            out.append(t)\n        out = sorted(out, key=lambda x: (x["risk"], -x["liquidity_usd"]))[:N]\n        # render\n        if not out:\n            return "No candidates under current rules."\n        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in out:\n            lines.append(f"{t[\'symbol\']} | {t[\'name\']} | {t[\'holders\']} | {t[\'mcap_usd\']:,} | {t[\'liquidity_usd\']:,} | {t[\'age_min\']} | {t[\'risk\']}")\n        body = "\\n".join(lines)\n        if len(body) > 3800: body = body[:3800] + "\\n…(truncated)…"\n        return f"*F.E.T.C.H results (v{get_rules_version()})*\\n```\\n{body}\\n```"\n    except Exception as e:\n        logging.exception("fetch_now error")\n        return f"❌ fetch_now failed: {e}"\n\n4) Update the Flask webhook router in app.py to add three branches.\nFind where you already handle /assistant_model and /assistant.\nRight there, ADD these branches (admin-only):\n\n# /rules_show\nif text.strip() == "/rules_show":\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_rules_show_sync\n    _reply(cmd_rules_show_sync()); return "ok"\n\n# /rules_reload\nif text.startswith("/rules_reload"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_rules_reload_sync\n    _reply(cmd_rules_reload_sync()); return "ok"\n\n# /fetch_now\nif text.startswith("/fetch_now"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_fetch_now_sync\n    _reply(cmd_fetch_now_sync()); return "ok"\n\nMake sure these appear BEFORE any "unknown" fallback.\n\nVALIDATION\n==========\n- Restart the app after patch.\n- In Telegram (DM with your bot), send:\n  1) /rules_show\n     EXPECTED: YAML printed in a code block with version.\n  2) /rules_reload\n     EXPECTED: "✅ Rules reloaded (v1)" (or your current version).\n  3) /fetch_now\n     EXPECTED: A small table of mock candidates filtered by your rules.\n- Check logs via /a_logs_tail 120 level=info for lines like:\n  "[RULES] Loaded ..." and "Command \'/fetch_now\' processed, response sent: 200"', 'entities': [{'offset': 2310, 'length': 6, 'type': 'url'}, {'offset': 2370, 'length': 16, 'type': 'bot_command'}, {'offset': 2391, 'length': 10, 'type': 'bot_command'}, {'offset': 2452, 'length': 11, 'type': 'bot_command'}, {'offset': 2484, 'length': 11, 'type': 'bot_command'}, {'offset': 2729, 'length': 13, 'type': 'bot_command'}, {'offset': 2763, 'length': 13, 'type': 'bot_command'}, {'offset': 3015, 'length': 10, 'type': 'bot_command'}, {'offset': 3046, 'length': 10, 'type': 'bot_command'}, {'offset': 3440, 'length': 11, 'type': 'bot_command'}, {'offset': 3515, 'length': 13, 'type': 'bot_command'}, {'offset': 3600, 'length': 10, 'type': 'bot_command'}, {'offset': 3700, 'length': 12, 'type': 'bot_command'}, {'offset': 3781, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:07:28,302 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:07:28,302 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def cmd_rules_reload_sync() -> str:
    try:
        load_rules(force=True)
        return f"✅ Rules reloaded (v{get_rules_version()})"
    except Exception as e:
        logging.exception("rules_reload error")
        return f"❌ rules_reload failed: {e}"

def cmd_fetch_now_sync() -> str:
    """
    Stub: score and return up to N tokens using current rules.
    Replace the mock list with real Solana data sources next.
    """
    try:
        rules = load_rules()
        N = int(rules.get("output",{}).get("max_results", 10))
        scan = rules.get("scan", {})
        # --- MOCK DATA (replace later) ---
        items = [
            {"symbol":"FNM","name":"FennecMan","holders":210,"mcap_usd":120000,"liquidity_usd":18000,"age_min":45,"risk":38},
            {"symbol":"YOLO","name":"YoloCat","holders":560,"mcap_usd":350000,"liquidity_usd":42000,"age_min":70,"risk":52},
            {"symbol":"ZAP","name":"ZapFox","holders":95,"mcap_usd":80000,"liquidity_usd":12000,"age_min":30,"risk":41},
        ]
        # simple filtering based on rules
        out = []
        for t in items:
            if t["holders"] < scan.get("holders_min", 0): continue
            if t["holders"] > scan.get("holders_max", 10**9): continue
            if t["mcap_usd"] < scan.get("mcap_min_usd", 0): continue
            if t["mcap_usd"] > scan.get("mcap_max_usd", 10**12): continue
            if t["liquidity_usd"] < scan.get("liquidity_min_usd", 0): continue
            if t["age_min"] > scan.get("max_age_minutes", 10**9): continue
            out.append(t)
        out = sorted(out, key=lambda x: (x["risk"], -x["liquidity_usd"]))[:N]
        # render
        if not out:
            return "No candidates under current rules."
        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in out:
            lines.append(f"{t['symbol']} | {t['name']} | {t['holders']} | {t['mcap_usd']:,} | {t['liquidity_usd']:,} | {t['age_min']} | {t['risk']}")
        body = "\n".join(lines)
        if len(body) > 3800: body = body[:3800] + "\n…(truncated)…"
        return f"*F.E.T.C.H results (v{get_rules_version()})*\n```\n{body}\n```"
    except Exception as e:
        logging.exception("fetch_now error")
        return f"❌ fetch_now failed: {e}"

4) Update the Flask webhook router in app.py to add three branches.
Find where you already handle /assistant_model and /assistant.
Right there, ADD these branches (admin-only):

# /rules_show
if text.strip() == "/rules_show":
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_rules_show_sync
    _reply(cmd_rules_show_sync()); return "ok"

# /rules_reload
if text.startswith("/rules_reload"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_rules_reload_sync
    _reply(cmd_rules_reload_sync()); return "ok"

# /fetch_now
if text.startswith("/fetch_now"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_fetch_now_sync
    _reply(cmd_fetch_now_sync()); return "ok"

Make sure these appear BEFORE any "unknown" fallback.

VALIDATION
==========
- Restart the app after patch.
- In Telegram (DM with your bot), send:
  1) /rules_show
     EXPECTED: YAML printed in a code block with version.
  2) /rules_reload
     EXPECTED: "✅ Rules reloaded (v1)" (or your current version).
  3) /fetch_now
     EXPECTED: A small table of mock candidates filtered by your rules.
- Check logs via /a_logs_tail 120 level=info for lines like:
  "[RULES] Loaded ..." and "Command '/fetch_now' processed, response sent: 200"'
2025-08-10 11:07:49,236 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:07:49,236 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121184, 'message': {'message_id': 4111, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824069, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:07:49,237 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:07:49,237 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:07:49,237 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:07:49,237 [INFO] app: [WEBHOOK] Unknown admin command: /rules_show
2025-08-10 11:08:10,512 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:08:10,512 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:08:10,513 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:08:10,523 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:08:11,825 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:08:18,364 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:08:18,364 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121185, 'message': {'message_id': 4112, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824098, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:08:18,364 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:08:18,364 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:08:18,364 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:08:18,364 [INFO] app: [WEBHOOK] Unknown admin command: /rules_show
2025-08-10 11:08:26,877 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:08:26,877 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121186, 'message': {'message_id': 4113, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824106, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:08:26,878 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:08:26,878 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:08:26,878 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:08:26,878 [INFO] app: [WEBHOOK] Unknown admin command: /fetch_now
2025-08-10 11:13:23,929 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:13:23,930 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121187, 'message': {'message_id': 4114, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824403, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:13:23,930 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:13:23,930 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 11:13:23,930 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 11:13:23,930 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 11:13:32,118 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:13:32,118 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121188, 'message': {'message_id': 4115, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824412, 'text': 'Create/patch F.E.T.C.H rules and wire three commands into Flask webhook: /rules_show, /rules_reload, /fetch_now.\n\n1) Create file rules.yaml at repo root if missing (keep existing if present):\n\nversion: 1\nupdated_at: "2025-08-10T00:00:00Z"\nnetwork: solana\nsources: [pump.fun, dexscreener, jup.ag]\nscan:\n  max_age_minutes: 180\n  holders_min: 75\n  holders_max: 5000\n  mcap_min_usd: 50000\n  mcap_max_usd: 2000000\n  liquidity_min_usd: 10000\n  renounced_mint_auth: true\n  renounced_freeze_auth: true\n  blacklist_contracts: []\n  include_keywords: []\n  exclude_keywords: [rug, scam]\nrisk:\n  max_score: 70\n  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}\noutput:\n  max_results: 10\n  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]\n\n2) Create/patch rules.py (idempotent):\n\nimport logging, yaml\nfrom pathlib import Path\nfrom typing import Tuple, Dict, Any\n\nRULES_PATH = Path("rules.yaml")\n_cache: Dict[str, Any] = {"data": None, "mtime": None, "version": None}\n\nDEFAULT_RULES = """version: 1\nupdated_at: "2025-08-10T00:00:00Z"\nnetwork: solana\nsources: [pump.fun, dexscreener, jup.ag]\nscan:\n  max_age_minutes: 180\n  holders_min: 75\n  holders_max: 5000\n  mcap_min_usd: 50000\n  mcap_max_usd: 2000000\n  liquidity_min_usd: 10000\n  renounced_mint_auth: true\n  renounced_freeze_auth: true\n  blacklist_contracts: []\n  include_keywords: []\n  exclude_keywords: [rug, scam]\nrisk:\n  max_score: 70\n  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}\noutput:\n  max_results: 10\n  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]\n"""\n\ndef ensure_default_rules():\n    if not RULES_PATH.exists():\n        RULES_PATH.write_text(DEFAULT_RULES, encoding="utf-8")\n        logging.info("[RULES] Created default rules.yaml")\n\ndef _validate(d: Dict[str, Any]) -> Tuple[bool, str]:\n    for k in ["version", "network", "scan", "risk", "output"]:\n        if k not in d:\n            return False, f"Missing key: {k}"\n    return True, "ok"\n\ndef load_rules(force: bool=False) -> Dict[str, Any]:\n    ensure_default_rules()\n    m = RULES_PATH.stat().st_mtime\n    if not force and _cache["data"] is not None and _cache["mtime"] == m:\n        return _cache["data"]\n    data = yaml.safe_load(RULES_PATH.read_text(encoding="utf-8")) or {}\n    ok, msg = _validate(data)\n    if not ok:\n        raise ValueError(f"rules.yaml invalid: {msg}")\n    _cache.update({"data": data, "mtime": m, "version": data.get("version")})\n    logging.info("[RULES] Loaded (v%s)", data.get("version"))\n    return data\n\ndef render_rules() -> str:\n    try:\n        txt = RULES_PATH.read_text(encoding="utf-8")\n        return txt if len(txt) < 3800 else txt[:3700] + "\\n…(truncated)…"\n    except Exception as e:\n        return f"# rules.yaml read error: {e}"\n\ndef get_rules_version() -> str:\n    if _cache["version"] is None:\n        load_rules()\n    return str(_cache["version"])\n\n3) Ensure alerts/telegram.py has these sync helpers (add if missing; safe to re-run):\n\nimport logging\nfrom rules import load_rules, render_rules, get_rules_version\n\ndef cmd_rules_show_sync() -> str:\n    try:\n        load_rules()\n        body = render_rules()\n        return f"*rules.yaml (v{get_rules_version()})*:\\\\n```\\\\n{body}\\\\n```"\n    except Exception as e:\n        logging.exception("rules_show error")\n        return f"❌ rules_show failed: {e}"\n\ndef cmd_rules_reload_sync() -> str:\n    try:\n        load_rules(force=True)\n        return f"✅ Rules reloaded (v{get_rules_version()})"\n    except Exception as e:\n        logging.exception("rules_reload error")\n        return f"❌ rules_reload failed: {e}"', 'entities': [{'offset': 73, 'length': 11, 'type': 'bot_command'}, {'offset': 86, 'length': 13, 'type': 'bot_command'}, {'offset': 101, 'length': 10, 'type': 'bot_command'}, {'offset': 265, 'length': 8, 'type': 'url'}, {'offset': 288, 'length': 6, 'type': 'url'}, {'offset': 795, 'length': 8, 'type': 'url'}, {'offset': 1098, 'length': 8, 'type': 'url'}, {'offset': 1121, 'length': 6, 'type': 'url'}, {'offset': 1747, 'length': 12, 'type': 'url'}, {'offset': 2481, 'length': 12, 'type': 'url'}, {'offset': 2933, 'length': 11, 'type': 'url'}]}}
2025-08-10 11:13:32,119 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:13:32,119 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'Create/patch F.E.T.C.H rules and wire three commands into Flask webhook: /rules_show, /rules_reload, /fetch_now.

1) Create file rules.yaml at repo root if missing (keep existing if present):

version: 1
updated_at: "2025-08-10T00:00:00Z"
network: solana
sources: [pump.fun, dexscreener, jup.ag]
scan:
  max_age_minutes: 180
  holders_min: 75
  holders_max: 5000
  mcap_min_usd: 50000
  mcap_max_usd: 2000000
  liquidity_min_usd: 10000
  renounced_mint_auth: true
  renounced_freeze_auth: true
  blacklist_contracts: []
  include_keywords: []
  exclude_keywords: [rug, scam]
risk:
  max_score: 70
  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}
output:
  max_results: 10
  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]

2) Create/patch rules.py (idempotent):

import logging, yaml
from pathlib import Path
from typing import Tuple, Dict, Any

RULES_PATH = Path("rules.yaml")
_cache: Dict[str, Any] = {"data": None, "mtime": None, "version": None}

DEFAULT_RULES = """version: 1
updated_at: "2025-08-10T00:00:00Z"
network: solana
sources: [pump.fun, dexscreener, jup.ag]
scan:
  max_age_minutes: 180
  holders_min: 75
  holders_max: 5000
  mcap_min_usd: 50000
  mcap_max_usd: 2000000
  liquidity_min_usd: 10000
  renounced_mint_auth: true
  renounced_freeze_auth: true
  blacklist_contracts: []
  include_keywords: []
  exclude_keywords: [rug, scam]
risk:
  max_score: 70
  weights: {age: 0.2, holders: 0.2, liquidity: 0.25, mcap: 0.25, renounce: 0.1}
output:
  max_results: 10
  columns: [symbol, name, holders, mcap_usd, liquidity_usd, age_min, risk]
"""

def ensure_default_rules():
    if not RULES_PATH.exists():
        RULES_PATH.write_text(DEFAULT_RULES, encoding="utf-8")
        logging.info("[RULES] Created default rules.yaml")

def _validate(d: Dict[str, Any]) -> Tuple[bool, str]:
    for k in ["version", "network", "scan", "risk", "output"]:
        if k not in d:
            return False, f"Missing key: {k}"
    return True, "ok"

def load_rules(force: bool=False) -> Dict[str, Any]:
    ensure_default_rules()
    m = RULES_PATH.stat().st_mtime
    if not force and _cache["data"] is not None and _cache["mtime"] == m:
        return _cache["data"]
    data = yaml.safe_load(RULES_PATH.read_text(encoding="utf-8")) or {}
    ok, msg = _validate(data)
    if not ok:
        raise ValueError(f"rules.yaml invalid: {msg}")
    _cache.update({"data": data, "mtime": m, "version": data.get("version")})
    logging.info("[RULES] Loaded (v%s)", data.get("version"))
    return data

def render_rules() -> str:
    try:
        txt = RULES_PATH.read_text(encoding="utf-8")
        return txt if len(txt) < 3800 else txt[:3700] + "\n…(truncated)…"
    except Exception as e:
        return f"# rules.yaml read error: {e}"

def get_rules_version() -> str:
    if _cache["version"] is None:
        load_rules()
    return str(_cache["version"])

3) Ensure alerts/telegram.py has these sync helpers (add if missing; safe to re-run):

import logging
from rules import load_rules, render_rules, get_rules_version

def cmd_rules_show_sync() -> str:
    try:
        load_rules()
        body = render_rules()
        return f"*rules.yaml (v{get_rules_version()})*:\\n```\\n{body}\\n```"
    except Exception as e:
        logging.exception("rules_show error")
        return f"❌ rules_show failed: {e}"

def cmd_rules_reload_sync() -> str:
    try:
        load_rules(force=True)
        return f"✅ Rules reloaded (v{get_rules_version()})"
    except Exception as e:
        logging.exception("rules_reload error")
        return f"❌ rules_reload failed: {e}"'
2025-08-10 11:13:32,235 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:13:32,236 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121189, 'message': {'message_id': 4116, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824412, 'text': 'def cmd_fetch_now_sync() -> str:\n    try:\n        rules = load_rules()\n        N = int(rules.get("output",{}).get("max_results", 10))\n        items = [\n            {"symbol":"FNM","name":"FennecMan","holders":210,"mcap_usd":120000,"liquidity_usd":18000,"age_min":45,"risk":38},\n            {"symbol":"YOLO","name":"YoloCat","holders":560,"mcap_usd":350000,"liquidity_usd":42000,"age_min":70,"risk":52},\n            {"symbol":"ZAP","name":"ZapFox","holders":95,"mcap_usd":80000,"liquidity_usd":12000,"age_min":30,"risk":41},\n        ]\n        scan = rules.get("scan", {})\n        out = []\n        for t in items:\n            if t["holders"] < scan.get("holders_min", 0): continue\n            if t["holders"] > scan.get("holders_max", 10**9): continue\n            if t["mcap_usd"] < scan.get("mcap_min_usd", 0): continue\n            if t["mcap_usd"] > scan.get("mcap_max_usd", 10**12): continue\n            if t["liquidity_usd"] < scan.get("liquidity_min_usd", 0): continue\n            if t["age_min"] > scan.get("max_age_minutes", 10**9): continue\n            out.append(t)\n        out = sorted(out, key=lambda x: (x["risk"], -x["liquidity_usd"]))[:N]\n        if not out: return "No candidates under current rules."\n        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in out:\n            lines.append(f"{t[\'symbol\']} | {t[\'name\']} | {t[\'holders\']} | {t[\'mcap_usd\']:,} | {t[\'liquidity_usd\']:,} | {t[\'age_min\']} | {t[\'risk\']}")\n        body = "\\\\n".join(lines)\n        if len(body) > 3800: body = body[:3800] + "\\\\n…(truncated)…"\n        return f"*F.E.T.C.H results (v{get_rules_version()})*\\\\n```\\\\n{body}\\\\n```"\n    except Exception as e:\n        logging.exception("fetch_now error")\n        return f"❌ fetch_now failed: {e}"\n\n4) In app.py (Flask webhook), add routing RIGHT AFTER you derive text = ...\nand BEFORE the "unknown admin" fallback:\n\n# /rules_show\nif text.strip() == "/rules_show":\n    logging.info("[WEBHOOK] Routing /rules_show")\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_rules_show_sync\n    _reply(cmd_rules_show_sync()); return "ok"\n\n# /rules_reload\nif text.startswith("/rules_reload"):\n    logging.info("[WEBHOOK] Routing /rules_reload")\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_rules_reload_sync\n    _reply(cmd_rules_reload_sync()); return "ok"\n\n# /fetch_now\nif text.startswith("/fetch_now"):\n    logging.info("[WEBHOOK] Routing /fetch_now")\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_fetch_now_sync\n    _reply(cmd_fetch_now_sync()); return "ok"\n\nMake sure these three branches are ABOVE any "Unknown admin command" return.\n\nVALIDATION\n- Restart app.\n- In Telegram:\n  /rules_show   → expect YAML in a code block (v1)\n  /rules_reload → expect “✅ Rules reloaded (v1)”\n  /fetch_now    → expect a small table of mock candidates\n- Then run: /a_logs_tail 120 level=info → expect routing logs for the above.', 'entities': [{'offset': 1770, 'length': 6, 'type': 'url'}, {'offset': 1829, 'length': 10, 'type': 'code'}, {'offset': 1884, 'length': 11, 'type': 'bot_command'}, {'offset': 1916, 'length': 11, 'type': 'bot_command'}, {'offset': 1934, 'length': 12, 'type': 'url'}, {'offset': 1966, 'length': 11, 'type': 'bot_command'}, {'offset': 2211, 'length': 13, 'type': 'bot_command'}, {'offset': 2245, 'length': 13, 'type': 'bot_command'}, {'offset': 2266, 'length': 12, 'type': 'url'}, {'offset': 2298, 'length': 13, 'type': 'bot_command'}, {'offset': 2549, 'length': 10, 'type': 'bot_command'}, {'offset': 2580, 'length': 10, 'type': 'bot_command'}, {'offset': 2598, 'length': 12, 'type': 'url'}, {'offset': 2630, 'length': 10, 'type': 'bot_command'}, {'offset': 2991, 'length': 11, 'type': 'bot_command'}, {'offset': 3042, 'length': 13, 'type': 'bot_command'}, {'offset': 3091, 'length': 10, 'type': 'bot_command'}, {'offset': 3159, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 11:13:32,236 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:13:32,236 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def cmd_fetch_now_sync() -> str:
    try:
        rules = load_rules()
        N = int(rules.get("output",{}).get("max_results", 10))
        items = [
            {"symbol":"FNM","name":"FennecMan","holders":210,"mcap_usd":120000,"liquidity_usd":18000,"age_min":45,"risk":38},
            {"symbol":"YOLO","name":"YoloCat","holders":560,"mcap_usd":350000,"liquidity_usd":42000,"age_min":70,"risk":52},
            {"symbol":"ZAP","name":"ZapFox","holders":95,"mcap_usd":80000,"liquidity_usd":12000,"age_min":30,"risk":41},
        ]
        scan = rules.get("scan", {})
        out = []
        for t in items:
            if t["holders"] < scan.get("holders_min", 0): continue
            if t["holders"] > scan.get("holders_max", 10**9): continue
            if t["mcap_usd"] < scan.get("mcap_min_usd", 0): continue
            if t["mcap_usd"] > scan.get("mcap_max_usd", 10**12): continue
            if t["liquidity_usd"] < scan.get("liquidity_min_usd", 0): continue
            if t["age_min"] > scan.get("max_age_minutes", 10**9): continue
            out.append(t)
        out = sorted(out, key=lambda x: (x["risk"], -x["liquidity_usd"]))[:N]
        if not out: return "No candidates under current rules."
        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in out:
            lines.append(f"{t['symbol']} | {t['name']} | {t['holders']} | {t['mcap_usd']:,} | {t['liquidity_usd']:,} | {t['age_min']} | {t['risk']}")
        body = "\\n".join(lines)
        if len(body) > 3800: body = body[:3800] + "\\n…(truncated)…"
        return f"*F.E.T.C.H results (v{get_rules_version()})*\\n```\\n{body}\\n```"
    except Exception as e:
        logging.exception("fetch_now error")
        return f"❌ fetch_now failed: {e}"

4) In app.py (Flask webhook), add routing RIGHT AFTER you derive text = ...
and BEFORE the "unknown admin" fallback:

# /rules_show
if text.strip() == "/rules_show":
    logging.info("[WEBHOOK] Routing /rules_show")
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_rules_show_sync
    _reply(cmd_rules_show_sync()); return "ok"

# /rules_reload
if text.startswith("/rules_reload"):
    logging.info("[WEBHOOK] Routing /rules_reload")
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_rules_reload_sync
    _reply(cmd_rules_reload_sync()); return "ok"

# /fetch_now
if text.startswith("/fetch_now"):
    logging.info("[WEBHOOK] Routing /fetch_now")
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_fetch_now_sync
    _reply(cmd_fetch_now_sync()); return "ok"

Make sure these three branches are ABOVE any "Unknown admin command" return.

VALIDATION
- Restart app.
- In Telegram:
  /rules_show   → expect YAML in a code block (v1)
  /rules_reload → expect “✅ Rules reloaded (v1)”
  /fetch_now    → expect a small table of mock candidates
- Then run: /a_logs_tail 120 level=info → expect routing logs for the above.'
2025-08-10 11:13:52,723 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:13:52,723 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:13:52,724 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:13:52,734 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:13:53,540 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:14:01,412 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:14:01,412 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121190, 'message': {'message_id': 4117, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824441, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:14:01,413 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:14:01,413 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:14:01,413 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:14:01,413 [INFO] app: [WEBHOOK] Unknown admin command: /rules_show
2025-08-10 11:14:04,918 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:14:04,919 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121191, 'message': {'message_id': 4118, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824444, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:14:04,919 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:14:04,919 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:14:04,919 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:14:04,919 [INFO] app: [WEBHOOK] Unknown admin command: /rules_reload
2025-08-10 11:14:06,644 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:14:06,644 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121192, 'message': {'message_id': 4119, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824446, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:14:06,644 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:14:06,644 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:14:06,644 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:14:06,645 [INFO] app: [WEBHOOK] Unknown admin command: /fetch_now
2025-08-10 11:14:16,759 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:14:16,759 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121193, 'message': {'message_id': 4120, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824456, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 11:14:16,759 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:14:16,760 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 11:14:16,760 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 11:14:17,248 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 11:15:41,296 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:15:41,297 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:15:41,297 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:15:41,300 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:15:41,995 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:15:50,181 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:15:50,181 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:15:50,181 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:15:50,184 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:15:50,889 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:15:51,290 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:15:51,291 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_show'}}
2025-08-10 11:15:51,291 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:15:51,291 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_show'
2025-08-10 11:15:51,291 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:15:51,291 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:15:51,359 [ERROR] app: rules_show handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 268, in webhook
    from fetch_rules_helpers import cmd_rules_show_sync
  File "/home/runner/workspace/fetch_rules_helpers.py", line 3, in <module>
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:15:51,764 [INFO] app: [WEBHOOK] Command '/rules_show' processed, response sent: 200
2025-08-10 11:15:52,945 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:15:52,946 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 11:15:52,946 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:15:52,947 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 11:15:52,947 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:15:52,947 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:15:52,948 [ERROR] app: fetch_now handler error
Traceback (most recent call last):
  File "/home/runner/workspace/app.py", line 286, in webhook
    from fetch_rules_helpers import cmd_fetch_now_sync
  File "/home/runner/workspace/fetch_rules_helpers.py", line 3, in <module>
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:15:53,324 [INFO] app: [WEBHOOK] Command '/fetch_now' processed, response sent: 200
2025-08-10 11:18:17,158 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:18:17,158 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:18:17,160 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:18:17,169 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:18:18,990 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:18:19,862 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:18:19,862 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_show'}}
2025-08-10 11:18:19,862 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:18:19,862 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_show'
2025-08-10 11:18:19,863 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:18:19,863 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:18:19,874 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:18:19,895 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 574, in cmd_rules_show_sync
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:18:21,553 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:18:21,554 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 11:18:21,554 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:18:21,554 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 11:18:21,554 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:18:21,554 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:18:21,554 [ERROR] root: fetch_now error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 596, in cmd_fetch_now_sync
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:18:29,179 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:18:29,180 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:18:29,180 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:18:29,182 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:18:30,010 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:18:49,534 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:18:49,535 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121194, 'message': {'message_id': 4126, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824729, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:18:49,535 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:18:49,535 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:18:49,535 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:18:49,535 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:18:49,536 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:18:49,561 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 574, in cmd_rules_show_sync
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:19:01,577 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:19:01,578 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121195, 'message': {'message_id': 4128, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824741, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:19:01,578 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:19:01,578 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:19:01,579 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:19:01,579 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:19:01,579 [ERROR] root: rules_reload error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 585, in cmd_rules_reload_sync
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:19:05,214 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:19:05,215 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121196, 'message': {'message_id': 4130, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824745, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:19:05,215 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:19:05,215 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:19:05,215 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:19:05,215 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:19:05,215 [ERROR] root: fetch_now error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 596, in cmd_fetch_now_sync
    from rules_loader import load_rules
ImportError: cannot import name 'load_rules' from 'rules_loader' (/home/runner/workspace/rules_loader.py)
2025-08-10 11:21:29,395 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:21:29,396 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:21:29,396 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:21:29,406 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:21:31,340 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:21:31,358 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:21:31,359 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_show'}}
2025-08-10 11:21:31,359 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:21:31,359 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_show'
2025-08-10 11:21:31,359 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:21:31,359 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:21:31,377 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:21:31,384 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 575, in cmd_rules_show_sync
    from rulesloader import (
ModuleNotFoundError: No module named 'rulesloader'
2025-08-10 11:21:32,993 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:21:32,994 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_reload'}}
2025-08-10 11:21:32,994 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:21:32,995 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_reload'
2025-08-10 11:21:32,995 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:21:32,996 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:21:32,996 [ERROR] root: rules_reload error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 590, in cmd_rules_reload_sync
    from rulesloader import (
ModuleNotFoundError: No module named 'rulesloader'
2025-08-10 11:22:14,003 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:22:14,004 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:22:14,004 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:22:14,007 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:22:15,102 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:22:29,589 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:22:29,589 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121197, 'message': {'message_id': 4132, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824949, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:22:29,589 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:22:29,589 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:22:29,590 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:22:29,590 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:22:29,591 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:22:29,603 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 575, in cmd_rules_show_sync
    from rulesloader import (
ModuleNotFoundError: No module named 'rulesloader'
2025-08-10 11:22:35,821 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:22:35,821 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121198, 'message': {'message_id': 4133, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824955, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:22:35,822 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:22:35,822 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:22:35,822 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:22:35,822 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:22:35,823 [ERROR] root: rules_reload error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 590, in cmd_rules_reload_sync
    from rulesloader import (
ModuleNotFoundError: No module named 'rulesloader'
2025-08-10 11:22:36,932 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:22:36,932 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121199, 'message': {'message_id': 4134, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824956, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:22:36,932 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:22:36,932 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:22:36,932 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:22:36,932 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:22:36,933 [ERROR] root: fetch_now error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 604, in cmd_fetch_now_sync
    from rulesloader import (
ModuleNotFoundError: No module named 'rulesloader'
2025-08-10 11:22:45,992 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:22:45,993 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121200, 'message': {'message_id': 4135, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754824965, 'text': '/a_logs_tail 120 level=error', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 11:22:45,993 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:22:45,994 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=error'
2025-08-10 11:22:45,994 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=error
2025-08-10 11:22:46,391 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=error' processed, response sent: 200
2025-08-10 11:24:01,922 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:24:01,923 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:24:01,923 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:24:01,928 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:24:02,685 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:24:04,196 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:24:04,197 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_show'}}
2025-08-10 11:24:04,197 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:24:04,197 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_show'
2025-08-10 11:24:04,197 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:24:04,197 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:24:04,206 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:24:04,267 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 575, in cmd_rules_show_sync
    load_rules()
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:24:05,714 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:24:05,715 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_reload'}}
2025-08-10 11:24:05,715 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:24:05,715 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_reload'
2025-08-10 11:24:05,715 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:24:05,715 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:24:05,728 [ERROR] root: rules_reload error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 585, in cmd_rules_reload_sync
    load_rules(force=True)
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:24:07,534 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:24:07,534 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 11:24:07,534 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:24:07,534 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 11:24:07,534 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:24:07,535 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:24:07,550 [ERROR] root: fetch_now error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 595, in cmd_fetch_now_sync
    rules = load_rules()
            ^^^^^^^^^^^^
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:24:23,165 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:24:23,165 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:24:23,165 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:24:23,168 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:24:23,831 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:25:02,331 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:25:02,332 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121201, 'message': {'message_id': 4137, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825101, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:25:02,332 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:25:02,332 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:25:02,332 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:25:02,332 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:25:02,333 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:25:02,369 [ERROR] root: rules_show error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 575, in cmd_rules_show_sync
    load_rules()
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:25:04,630 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:25:04,631 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121202, 'message': {'message_id': 4138, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825104, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:25:04,631 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:25:04,631 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:25:04,631 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:25:04,631 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:25:04,647 [ERROR] root: rules_reload error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 585, in cmd_rules_reload_sync
    load_rules(force=True)
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:25:06,595 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:25:06,596 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121203, 'message': {'message_id': 4139, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825106, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:25:06,596 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:25:06,596 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:25:06,596 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:25:06,596 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:25:06,610 [ERROR] root: fetch_now error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 595, in cmd_fetch_now_sync
    rules = load_rules()
            ^^^^^^^^^^^^
  File "/home/runner/workspace/rules.py", line 52, in load_rules
    raise ValueError(f"rules.yaml invalid: {msg}")
ValueError: rules.yaml invalid: Missing key: version
2025-08-10 11:25:31,227 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:25:31,228 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121204, 'message': {'message_id': 4140, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825131, 'text': '/a_logs_tail', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 11:25:31,228 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:25:31,228 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail'
2025-08-10 11:25:31,229 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail
2025-08-10 11:25:31,639 [INFO] app: [WEBHOOK] Command '/a_logs_tail' processed, response sent: 200
2025-08-10 11:26:23,830 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:26:23,832 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/rules_show'}}
2025-08-10 11:26:23,832 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:26:23,833 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/rules_show'
2025-08-10 11:26:23,833 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:26:23,834 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:26:23,839 [INFO] root: [RULES] Loaded (v1)
2025-08-10 11:26:25,755 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 11:26:25,756 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 11:26:25,756 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:26:25,756 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 11:26:25,756 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:26:25,756 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:26:51,252 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:26:51,401 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:27:46,271 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:27:46,271 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121205, 'message': {'message_id': 4144, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825265, 'text': '/rules_show', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 11:27:46,271 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:27:46,272 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_show'
2025-08-10 11:27:46,272 [INFO] app: [WEBHOOK] Admin command detected: /rules_show
2025-08-10 11:27:46,272 [INFO] app: [WEBHOOK] Routing /rules_show
2025-08-10 11:27:49,611 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:27:49,611 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121206, 'message': {'message_id': 4146, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825269, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:27:49,611 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:27:49,611 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:27:49,611 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:27:49,611 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:27:49,614 [INFO] root: [RULES] Loaded (v1)
2025-08-10 11:27:52,872 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:27:52,873 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121207, 'message': {'message_id': 4148, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825272, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:27:52,873 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:27:52,873 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:27:52,873 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:27:52,873 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:34:56,537 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:34:56,539 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121208, 'message': {'message_id': 4150, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825696, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:34:56,539 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:34:56,540 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 11:34:56,540 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 11:34:56,540 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 11:35:15,064 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:35:15,064 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121209, 'message': {'message_id': 4151, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825714, 'text': '/assistant Create live Solana data fetch with Dexscreener and wire it into /fetch_now.\n\nFILES & CHANGES\n===============\n\n1) Create a new module: data_fetcher.py (project root)\n\n# data_fetcher.py\nimport time, logging, math, requests\nfrom datetime import datetime, timezone\n\nDEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"\n\ndef _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):\n    for i in range(retries+1):\n        try:\n            r = requests.get(url, params=params or {}, timeout=timeout)\n            if r.status_code == 200:\n                return r.json()\n            logging.warning("fetch %s -> HTTP %s", url, r.status_code)\n        except Exception as e:\n            logging.warning("fetch %s error: %s", url, e)\n        time.sleep(backoff * (2 ** i))\n    return None\n\ndef _minutes_since_ms(ms):\n    try:\n        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)\n        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)\n    except Exception:\n        return None\n\ndef fetch_candidates_from_dexscreener(max_pairs=500):\n    """Return a list of normalized token dicts from Dexscreener Solana pairs."""\n    js = _get_json(DEXSCREENER_PAIRS)\n    out = []\n    if not js or "pairs" not in js:\n        logging.warning("Dexscreener: no pairs payload")\n        return out\n\n    for p in js.get("pairs", [])[:max_pairs]:\n        base = (p.get("baseToken") or {})\n        sym  = base.get("symbol") or "?"\n        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")\n        if not mint:\n            continue\n\n        liq_usd = None\n        if isinstance(p.get("liquidity"), dict):\n            liq_usd = p["liquidity"].get("usd")\n        elif isinstance(p.get("liquidity"), (int, float)):\n            liq_usd = p.get("liquidity")\n\n        mcap = p.get("marketCap") or p.get("fdv")\n        age_min = _minutes_since_ms(p.get("pairCreatedAt"))\n\n        # holders not provided by this feed; keep None (scoring will down-weight unknown)\n        obj = {\n            "symbol": sym,\n            "name": base.get("name") or sym,\n            "mint": mint,\n            "holders": None,\n            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n            "age_min": age_min,\n            "renounced_mint_auth": None,\n            "renounced_freeze_auth": None,\n        }\n        out.append(obj)\n    return out\n\ndef _passes_rules(t, rules):\n    s = rules.get("scan", {})\n    # age: keep only tokens younger than threshold if age_min known, else include but penalize later\n    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):\n        return False\n    # holders (unknown passes but will be penalized)\n    if t["holders"] is not None:\n        if t["holders"] < s.get("holders_min", 0): return False\n        if t["holders"] > s.get("holders_max", 10**12): return False\n    # market cap\n    if t["mcap_usd"] is not None:\n        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False\n        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False\n    # liquidity\n    if t["liquidity_usd"] is not None:\n        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False\n    # keyword filters\n    inc_kw = [k.lower() for k in s.get("include_keywords", [])]\n    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]\n    text = f"{t[\'symbol\']} {t[\'name\']}".lower()\n    if exc_kw and any(k in text for k in exc_kw): return False\n    if inc_kw and not any(k in text for k in inc_kw): return False\n    # blacklist contracts\n    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False\n    return True\n\ndef _score_token(t, rules):\n    """Lower is safer. Combine weighted components with simple normalizers."""\n    w = (rules.get("risk", {}) or {}).get("weights", {})\n    score = 0.0', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 75, 'length': 10, 'type': 'bot_command'}, {'offset': 294, 'length': 51, 'type': 'url'}, {'offset': 938, 'length': 12, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 11:35:15,065 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:35:15,065 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Create live Solana data fetch with Dexscreener and wire it into /fetch_now.

FILES & CHANGES
===============

1) Create a new module: data_fetcher.py (project root)

# data_fetcher.py
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    """Return a list of normalized token dicts from Dexscreener Solana pairs."""
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        # holders not provided by this feed; keep None (scoring will down-weight unknown)
        obj = {
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        }
        out.append(obj)
    return out

def _passes_rules(t, rules):
    s = rules.get("scan", {})
    # age: keep only tokens younger than threshold if age_min known, else include but penalize later
    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):
        return False
    # holders (unknown passes but will be penalized)
    if t["holders"] is not None:
        if t["holders"] < s.get("holders_min", 0): return False
        if t["holders"] > s.get("holders_max", 10**12): return False
    # market cap
    if t["mcap_usd"] is not None:
        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False
        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False
    # liquidity
    if t["liquidity_usd"] is not None:
        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False
    # keyword filters
    inc_kw = [k.lower() for k in s.get("include_keywords", [])]
    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]
    text = f"{t['symbol']} {t['name']}".lower()
    if exc_kw and any(k in text for k in exc_kw): return False
    if inc_kw and not any(k in text for k in inc_kw): return False
    # blacklist contracts
    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False
    return True

def _score_token(t, rules):
    """Lower is safer. Combine weighted components with simple normalizers."""
    w = (rules.get("risk", {}) or {}).get("weights", {})
    score = 0.0'
2025-08-10 11:35:15,065 [INFO] app: [WEBHOOK] Admin command detected: /assistant Create live Solana data fetch with Dexscreener and wire it into /fetch_now.

FILES & CHANGES
===============

1) Create a new module: data_fetcher.py (project root)

# data_fetcher.py
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    """Return a list of normalized token dicts from Dexscreener Solana pairs."""
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        # holders not provided by this feed; keep None (scoring will down-weight unknown)
        obj = {
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        }
        out.append(obj)
    return out

def _passes_rules(t, rules):
    s = rules.get("scan", {})
    # age: keep only tokens younger than threshold if age_min known, else include but penalize later
    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):
        return False
    # holders (unknown passes but will be penalized)
    if t["holders"] is not None:
        if t["holders"] < s.get("holders_min", 0): return False
        if t["holders"] > s.get("holders_max", 10**12): return False
    # market cap
    if t["mcap_usd"] is not None:
        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False
        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False
    # liquidity
    if t["liquidity_usd"] is not None:
        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False
    # keyword filters
    inc_kw = [k.lower() for k in s.get("include_keywords", [])]
    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]
    text = f"{t['symbol']} {t['name']}".lower()
    if exc_kw and any(k in text for k in exc_kw): return False
    if inc_kw and not any(k in text for k in inc_kw): return False
    # blacklist contracts
    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False
    return True

def _score_token(t, rules):
    """Lower is safer. Combine weighted components with simple normalizers."""
    w = (rules.get("risk", {}) or {}).get("weights", {})
    score = 0.0
2025-08-10 11:35:15,065 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:35:21,794 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:35:22,179 [INFO] app: [WEBHOOK] Command '/assistant Create live Solana data fetch with Dexscreener and wire it into /fetch_now.

FILES & CHANGES
===============

1) Create a new module: data_fetcher.py (project root)

# data_fetcher.py
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    """Return a list of normalized token dicts from Dexscreener Solana pairs."""
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        # holders not provided by this feed; keep None (scoring will down-weight unknown)
        obj = {
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        }
        out.append(obj)
    return out

def _passes_rules(t, rules):
    s = rules.get("scan", {})
    # age: keep only tokens younger than threshold if age_min known, else include but penalize later
    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):
        return False
    # holders (unknown passes but will be penalized)
    if t["holders"] is not None:
        if t["holders"] < s.get("holders_min", 0): return False
        if t["holders"] > s.get("holders_max", 10**12): return False
    # market cap
    if t["mcap_usd"] is not None:
        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False
        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False
    # liquidity
    if t["liquidity_usd"] is not None:
        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False
    # keyword filters
    inc_kw = [k.lower() for k in s.get("include_keywords", [])]
    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]
    text = f"{t['symbol']} {t['name']}".lower()
    if exc_kw and any(k in text for k in exc_kw): return False
    if inc_kw and not any(k in text for k in inc_kw): return False
    # blacklist contracts
    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False
    return True

def _score_token(t, rules):
    """Lower is safer. Combine weighted components with simple normalizers."""
    w = (rules.get("risk", {}) or {}).get("weights", {})
    score = 0.0' processed, response sent: 200
2025-08-10 11:35:22,295 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:35:22,309 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121210, 'message': {'message_id': 4152, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825715, 'text': '# age (younger == lower risk here because your rules target new launches)\n    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1\n    if t["age_min"] is None:\n        age_part = 0.6  # unknown age: moderate penalty\n    else:\n        age_part = min(1.0, t["age_min"] / max_age)\n    score += 100.0 * w.get("age", 0.0) * age_part\n\n    # holders (more holders => safer => lower)\n    if t["holders"] is None:\n        holders_part = 0.7\n    else:\n        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)\n        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))\n        rng = max(1, hmax - hmin)\n        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))\n    score += 100.0 * w.get("holders", 0.0) * holders_part\n\n    # liquidity (more liquidity => safer)\n    if t["liquidity_usd"] is None:\n        liq_part = 0.7\n    else:\n        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)\n        # normalize vs 10x of min threshold\n        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))\n    score += 100.0 * w.get("liquidity", 0.0) * liq_part\n\n    # mcap (inside band => safer)\n    if t["mcap_usd"] is None:\n        mcap_part = 0.6\n    else:\n        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)\n        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)\n        if t["mcap_usd"] < mmin:\n            mcap_part = 1.0\n        elif t["mcap_usd"] > mmax:\n            mcap_part = 0.8\n        else:\n            # the closer to geometric mean, the safer\n            g = math.sqrt(max(mmin,1) * max(mmax,1))\n            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)\n    score += 100.0 * w.get("mcap", 0.0) * mcap_part\n\n    # renounce (unknown -> small penalty)\n    ren_part = 0.3\n    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:\n        ren_part = 0.0\n    score += 100.0 * w.get("renounce", 0.0) * ren_part\n\n    return round(score, 2)\n\ndef fetch_and_rank(rules):\n    """Return filtered & ranked tokens using live Dexscreener; sorted by ascending risk."""\n    raw = fetch_candidates_from_dexscreener()\n    filtered = [t for t in raw if _passes_rules(t, rules)]\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        # coerce printable numbers\n        if t["mcap_usd"] is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t["liquidity_usd"] is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t["age_min"] is not None: t["age_min"] = int(t["age_min"])\n        if t["holders"] is None: t["holders"] = -1  # display as "?" later\n    filtered.sort(key=lambda x: (x["risk"], -(x["liquidity_usd"] or 0)))\n    return filtered\n\n2) Update alerts/telegram.py: rewire /fetch_now to use live data\n\n- Find the function: cmd_fetch_now_sync()\n- Replace its body with the following:\n\nfrom rules import load_rules, get_rules_version\nfrom data_fetcher import fetch_and_rank\n\ndef cmd_fetch_now_sync() -> str:\n    try:\n        rules = load_rules()\n        N = int(rules.get("output",{}).get("max_results", 10))\n        items = fetch_and_rank(rules)[:N]\n        if not items:\n            return "No candidates under current rules."\n\n        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in items:\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd")\n            liq  = t.get("liquidity_usd")\n            age  = t.get("age_min")\n            lines.append(f"{t[\'symbol\']} | {t[\'name\'][:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'} | {t[\'risk\']}")\n\n        body = "\\\\n".join(lines)\n        if len(body) > 3800: body = body[:3800] + "\\\\n…(truncated)…"\n        return f"*F.E.T.C.H results (v{get_rules_version()}) – live Dexscreener*\\n```\\n{body}\\n```"\n    except Exception as e:\n        logging.exception("fetch_now error")\n        return f"❌ fetch_now failed: {e}"', 'entities': [{'offset': 2768, 'length': 11, 'type': 'url'}, {'offset': 2788, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:35:22,309 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:35:22,310 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# age (younger == lower risk here because your rules target new launches)
    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1
    if t["age_min"] is None:
        age_part = 0.6  # unknown age: moderate penalty
    else:
        age_part = min(1.0, t["age_min"] / max_age)
    score += 100.0 * w.get("age", 0.0) * age_part

    # holders (more holders => safer => lower)
    if t["holders"] is None:
        holders_part = 0.7
    else:
        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)
        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))
        rng = max(1, hmax - hmin)
        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))
    score += 100.0 * w.get("holders", 0.0) * holders_part

    # liquidity (more liquidity => safer)
    if t["liquidity_usd"] is None:
        liq_part = 0.7
    else:
        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)
        # normalize vs 10x of min threshold
        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))
    score += 100.0 * w.get("liquidity", 0.0) * liq_part

    # mcap (inside band => safer)
    if t["mcap_usd"] is None:
        mcap_part = 0.6
    else:
        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)
        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)
        if t["mcap_usd"] < mmin:
            mcap_part = 1.0
        elif t["mcap_usd"] > mmax:
            mcap_part = 0.8
        else:
            # the closer to geometric mean, the safer
            g = math.sqrt(max(mmin,1) * max(mmax,1))
            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)
    score += 100.0 * w.get("mcap", 0.0) * mcap_part

    # renounce (unknown -> small penalty)
    ren_part = 0.3
    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:
        ren_part = 0.0
    score += 100.0 * w.get("renounce", 0.0) * ren_part

    return round(score, 2)

def fetch_and_rank(rules):
    """Return filtered & ranked tokens using live Dexscreener; sorted by ascending risk."""
    raw = fetch_candidates_from_dexscreener()
    filtered = [t for t in raw if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        # coerce printable numbers
        if t["mcap_usd"] is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t["liquidity_usd"] is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t["age_min"] is not None: t["age_min"] = int(t["age_min"])
        if t["holders"] is None: t["holders"] = -1  # display as "?" later
    filtered.sort(key=lambda x: (x["risk"], -(x["liquidity_usd"] or 0)))
    return filtered

2) Update alerts/telegram.py: rewire /fetch_now to use live data

- Find the function: cmd_fetch_now_sync()
- Replace its body with the following:

from rules import load_rules, get_rules_version
from data_fetcher import fetch_and_rank

def cmd_fetch_now_sync() -> str:
    try:
        rules = load_rules()
        N = int(rules.get("output",{}).get("max_results", 10))
        items = fetch_and_rank(rules)[:N]
        if not items:
            return "No candidates under current rules."

        lines = ["symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            lines.append(f"{t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")

        body = "\\n".join(lines)
        if len(body) > 3800: body = body[:3800] + "\\n…(truncated)…"
        return f"*F.E.T.C.H results (v{get_rules_version()}) – live Dexscreener*\n```\n{body}\n```"
    except Exception as e:
        logging.exception("fetch_now error")
        return f"❌ fetch_now failed: {e}"'
2025-08-10 11:35:22,426 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:35:22,426 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121211, 'message': {'message_id': 4153, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825715, 'text': "NOTES\n=====\n- Uses only Dexscreener (public). Jupiter/Pump.fun hooks are stubbed for later.\n- Timeouts & retries included; failures return an empty shortlist rather than crash.\n- No extra dependencies needed beyond 'requests'.\n\nDONE", 'entities': [{'offset': 54, 'length': 8, 'type': 'url'}]}}
2025-08-10 11:35:22,427 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:35:22,427 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'NOTES
=====
- Uses only Dexscreener (public). Jupiter/Pump.fun hooks are stubbed for later.
- Timeouts & retries included; failures return an empty shortlist rather than crash.
- No extra dependencies needed beyond 'requests'.

DONE'
2025-08-10 11:36:20,119 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:36:20,120 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121212, 'message': {'message_id': 4155, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754825780, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:36:20,120 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:36:20,120 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:36:20,120 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:36:20,120 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:41:27,563 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:41:27,563 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121213, 'message': {'message_id': 4157, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826087, 'text': '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.\n\nPATCH\n=====\n\n1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport time, logging, math, requests\nfrom datetime import datetime, timezone\n\nDEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"\n\n# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):\nPUMPFUN_ENDPOINTS = [\n    # Unofficial frontend API (commonly used by trackers); newest first\n    # returns JSON list of coins; we only read a few fields if present\n    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we\'ll add params)\n    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here\n]\n\ndef _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):\n    for i in range(retries+1):\n        try:\n            r = requests.get(url, params=params or {}, timeout=timeout)\n            if r.status_code == 200:\n                return r.json()\n            logging.warning("fetch %s -> HTTP %s", url, r.status_code)\n        except Exception as e:\n            logging.warning("fetch %s error: %s", url, e)\n        time.sleep(backoff * (2 ** i))\n    return None\n\ndef _minutes_since_ms(ms):\n    try:\n        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)\n        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)\n    except Exception:\n        return None\n\ndef fetch_candidates_from_dexscreener(max_pairs=500):\n    js = _get_json(DEXSCREENER_PAIRS)\n    out = []\n    if not js or "pairs" not in js:\n        logging.warning("Dexscreener: no pairs payload")\n        return out\n\n    for p in js.get("pairs", [])[:max_pairs]:\n        base = (p.get("baseToken") or {})\n        sym  = base.get("symbol") or "?"\n        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")\n        if not mint:\n            continue\n\n        liq_usd = None\n        if isinstance(p.get("liquidity"), dict):\n            liq_usd = p["liquidity"].get("usd")\n        elif isinstance(p.get("liquidity"), (int, float)):\n            liq_usd = p.get("liquidity")\n\n        mcap = p.get("marketCap") or p.get("fdv")\n        age_min = _minutes_since_ms(p.get("pairCreatedAt"))\n\n        out.append({\n            "source": "dexscreener",\n            "symbol": sym,\n            "name": base.get("name") or sym,\n            "mint": mint,\n            "holders": None,\n            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n            "age_min": age_min,\n            "renounced_mint_auth": None,\n            "renounced_freeze_auth": None,\n        })\n    return out\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    """\n    Attempt to pull newest Pump.fun launches.\n    This is best-effort; if endpoints change, we fail gracefully and return [].\n    """\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 8, 'type': 'url'}, {'offset': 226, 'length': 8, 'type': 'url'}, {'offset': 399, 'length': 51, 'type': 'url'}, {'offset': 478, 'length': 8, 'type': 'url'}, {'offset': 717, 'length': 43, 'type': 'url'}, {'offset': 1500, 'length': 12, 'type': 'url'}, {'offset': 2988, 'length': 8, 'type': 'url'}], 'link_preview_options': {'url': 'https://frontend-api.pump.fun/coins/created'}}}
2025-08-10 11:41:27,563 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:41:27,564 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue'
2025-08-10 11:41:27,564 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
2025-08-10 11:41:27,564 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:41:40,213 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:41:40,603 [INFO] app: [WEBHOOK] Command '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue' processed, response sent: 200
2025-08-10 11:41:40,729 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:41:40,730 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121214, 'message': {'message_id': 4158, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826087, 'text': '# Normalize a few known shapes:\n            items = []\n            # Case A: list of dicts under top-level\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                # timestamps frequently in seconds; convert to ms if looks small\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000:  # seconds -> ms\n                    ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n\n                # optional numeric fields\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n\ndef _passes_rules(t, rules):\n    s = rules.get("scan", {})\n    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):\n        return False\n    if t["holders"] is not None:\n        if t["holders"] < s.get("holders_min", 0): return False\n        if t["holders"] > s.get("holders_max", 10**12): return False\n    if t["mcap_usd"] is not None:\n        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False\n        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False\n    if t["liquidity_usd"] is not None:\n        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False\n    inc_kw = [k.lower() for k in s.get("include_keywords", [])]\n    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]\n    text = f"{t[\'symbol\']} {t[\'name\']}".lower()\n    if exc_kw and any(k in text for k in exc_kw): return False\n    if inc_kw and not any(k in text for k in inc_kw): return False\n    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False\n    return True\n\ndef _score_token(t, rules):\n    w = (rules.get("risk", {}) or {}).get("weights", {})\n    score = 0.0\n    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1\n    age_part = 0.6 if t["age_min"] is None else min(1.0, t["age_min"] / max_age)\n    score += 100.0 * w.get("age", 0.0) * age_part\n\n    if t["holders"] is None:\n        holders_part = 0.7\n    else:\n        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)\n        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))\n        rng  = max(1, hmax - hmin)\n        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))\n    score += 100.0 * w.get("holders", 0.0) * holders_part\n\n    if t["liquidity_usd"] is None:\n        liq_part = 0.7\n    else:\n        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)\n        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))\n    score += 100.0 * w.get("liquidity", 0.0) * liq_part', 'entities': [{'offset': 1772, 'length': 8, 'type': 'url'}]}}
2025-08-10 11:41:40,730 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:41:40,731 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# Normalize a few known shapes:
            items = []
            # Case A: list of dicts under top-level
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                # timestamps frequently in seconds; convert to ms if looks small
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                # optional numeric fields
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def _passes_rules(t, rules):
    s = rules.get("scan", {})
    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):
        return False
    if t["holders"] is not None:
        if t["holders"] < s.get("holders_min", 0): return False
        if t["holders"] > s.get("holders_max", 10**12): return False
    if t["mcap_usd"] is not None:
        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False
        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False
    if t["liquidity_usd"] is not None:
        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False
    inc_kw = [k.lower() for k in s.get("include_keywords", [])]
    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]
    text = f"{t['symbol']} {t['name']}".lower()
    if exc_kw and any(k in text for k in exc_kw): return False
    if inc_kw and not any(k in text for k in inc_kw): return False
    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False
    return True

def _score_token(t, rules):
    w = (rules.get("risk", {}) or {}).get("weights", {})
    score = 0.0
    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1
    age_part = 0.6 if t["age_min"] is None else min(1.0, t["age_min"] / max_age)
    score += 100.0 * w.get("age", 0.0) * age_part

    if t["holders"] is None:
        holders_part = 0.7
    else:
        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)
        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))
        rng  = max(1, hmax - hmin)
        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))
    score += 100.0 * w.get("holders", 0.0) * holders_part

    if t["liquidity_usd"] is None:
        liq_part = 0.7
    else:
        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)
        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))
    score += 100.0 * w.get("liquidity", 0.0) * liq_part'
2025-08-10 11:41:40,847 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:41:40,854 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121215, 'message': {'message_id': 4159, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826087, 'text': 'if t["mcap_usd"] is None:\n        mcap_part = 0.6\n    else:\n        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)\n        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)\n        if t["mcap_usd"] < mmin: mcap_part = 1.0\n        elif t["mcap_usd"] > mmax: mcap_part = 0.8\n        else:\n            g = math.sqrt(max(mmin,1) * max(mmax,1))\n            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)\n    score += 100.0 * w.get("mcap", 0.0) * mcap_part\n\n    ren_part = 0.3\n    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:\n        ren_part = 0.0\n    score += 100.0 * w.get("renounce", 0.0) * ren_part\n\n    return round(score, 2)\n\ndef _dedupe_keep_best(items):\n    """De-dupe by mint; prefer Pump.fun for very new (age_min smaller), else lowest risk."""\n    by_mint = {}\n    for t in items:\n        m = t.get("mint")\n        if not m:\n            continue\n        if m not in by_mint:\n            by_mint[m] = t\n        else:\n            a, b = by_mint[m], t\n            # If one is Pump.fun and looks newer, prefer it; else lower risk\n            if (b.get("source") == "pumpfun" and (b.get("age_min") or 1e9) < (a.get("age_min") or 1e9)):\n                by_mint[m] = b\n            elif b.get("risk", 999) < a.get("risk", 999):\n                by_mint[m] = b\n    return list(by_mint.values())\n\ndef fetch_and_rank(rules):\n    """Merge Pump.fun + Dexscreener, filter by rules, score, de-dupe, sort by ascending risk."""\n    all_items = []\n    try:\n        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)\n        all_items.extend(pf)\n    except Exception as e:\n        logging.warning("Pump.fun source failed: %s", e)\n\n    try:\n        dx = fetch_candidates_from_dexscreener(max_pairs=500)\n        all_items.extend(dx)\n    except Exception as e:\n        logging.warning("Dexscreener source failed: %s", e)\n\n    # Filter\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n\n    # Score\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    # De-dupe and final sort\n    filtered = _dedupe_keep_best(filtered)\n    filtered.sort(key=lambda x: (x["risk"], -(x.get("liquidity_usd") or 0)))\n    return filtered\n# --- END PATCH: data_fetcher.py ---\n\n2) No changes needed to rules.yaml. If you want stricter “ultra-new” filtering, lower scan.max_age_minutes and/or liquidity/mcap floors, then /rules_reload.\n\nVALIDATION\n==========\n- Restart the app (Replit → Run).\n- In Telegram:\n  /rules_reload  -> expect ✅ Rules reloaded (v1)\n  /fetch_now     -> expect table titled \'live Dexscreener\' OR mixed with Pump.fun (source is internal, but newer coins should appear)\n- If no results, loosen rules (e.g., holders_min: 0, liquidity_min_usd: 1000), then /rules_reload and /fetch_now.', 'entities': [{'offset': 767, 'length': 8, 'type': 'url'}, {'offset': 1058, 'length': 8, 'type': 'url'}, {'offset': 1411, 'length': 8, 'type': 'url'}, {'offset': 1668, 'length': 8, 'type': 'url'}, {'offset': 2694, 'length': 13, 'type': 'bot_command'}, {'offset': 2783, 'length': 13, 'type': 'bot_command'}, {'offset': 2832, 'length': 10, 'type': 'bot_command'}, {'offset': 2903, 'length': 8, 'type': 'url'}, {'offset': 3048, 'length': 13, 'type': 'bot_command'}, {'offset': 3066, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:41:40,854 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:41:40,854 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'if t["mcap_usd"] is None:
        mcap_part = 0.6
    else:
        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)
        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)
        if t["mcap_usd"] < mmin: mcap_part = 1.0
        elif t["mcap_usd"] > mmax: mcap_part = 0.8
        else:
            g = math.sqrt(max(mmin,1) * max(mmax,1))
            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)
    score += 100.0 * w.get("mcap", 0.0) * mcap_part

    ren_part = 0.3
    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:
        ren_part = 0.0
    score += 100.0 * w.get("renounce", 0.0) * ren_part

    return round(score, 2)

def _dedupe_keep_best(items):
    """De-dupe by mint; prefer Pump.fun for very new (age_min smaller), else lowest risk."""
    by_mint = {}
    for t in items:
        m = t.get("mint")
        if not m:
            continue
        if m not in by_mint:
            by_mint[m] = t
        else:
            a, b = by_mint[m], t
            # If one is Pump.fun and looks newer, prefer it; else lower risk
            if (b.get("source") == "pumpfun" and (b.get("age_min") or 1e9) < (a.get("age_min") or 1e9)):
                by_mint[m] = b
            elif b.get("risk", 999) < a.get("risk", 999):
                by_mint[m] = b
    return list(by_mint.values())

def fetch_and_rank(rules):
    """Merge Pump.fun + Dexscreener, filter by rules, score, de-dupe, sort by ascending risk."""
    all_items = []
    try:
        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)
        all_items.extend(pf)
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        dx = fetch_candidates_from_dexscreener(max_pairs=500)
        all_items.extend(dx)
    except Exception as e:
        logging.warning("Dexscreener source failed: %s", e)

    # Filter
    filtered = [t for t in all_items if _passes_rules(t, rules)]

    # Score
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    # De-dupe and final sort
    filtered = _dedupe_keep_best(filtered)
    filtered.sort(key=lambda x: (x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH: data_fetcher.py ---

2) No changes needed to rules.yaml. If you want stricter “ultra-new” filtering, lower scan.max_age_minutes and/or liquidity/mcap floors, then /rules_reload.

VALIDATION
==========
- Restart the app (Replit → Run).
- In Telegram:
  /rules_reload  -> expect ✅ Rules reloaded (v1)
  /fetch_now     -> expect table titled 'live Dexscreener' OR mixed with Pump.fun (source is internal, but newer coins should appear)
- If no results, loosen rules (e.g., holders_min: 0, liquidity_min_usd: 1000), then /rules_reload and /fetch_now.'
2025-08-10 11:42:02,803 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:42:02,804 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121216, 'message': {'message_id': 4161, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826122, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:42:02,804 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:42:02,804 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:42:02,804 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:42:02,804 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:42:51,296 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:42:51,296 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121217, 'message': {'message_id': 4163, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826171, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:42:51,296 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:42:51,296 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 11:42:51,296 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 11:42:51,296 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 11:42:57,785 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:42:57,788 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121218, 'message': {'message_id': 4164, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826177, 'text': '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.\n\nPATCH\n=====\n\n1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport time, logging, math, requests\nfrom datetime import datetime, timezone\n\nDEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"\n\n# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):\nPUMPFUN_ENDPOINTS = [\n    # Unofficial frontend API (commonly used by trackers); newest first\n    # returns JSON list of coins; we only read a few fields if present\n    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we\'ll add params)\n    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here\n]\n\ndef _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):\n    for i in range(retries+1):\n        try:\n            r = requests.get(url, params=params or {}, timeout=timeout)\n            if r.status_code == 200:\n                return r.json()\n            logging.warning("fetch %s -> HTTP %s", url, r.status_code)\n        except Exception as e:\n            logging.warning("fetch %s error: %s", url, e)\n        time.sleep(backoff * (2 ** i))\n    return None\n\ndef _minutes_since_ms(ms):\n    try:\n        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)\n        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)\n    except Exception:\n        return None\n\ndef fetch_candidates_from_dexscreener(max_pairs=500):\n    js = _get_json(DEXSCREENER_PAIRS)\n    out = []\n    if not js or "pairs" not in js:\n        logging.warning("Dexscreener: no pairs payload")\n        return out\n\n    for p in js.get("pairs", [])[:max_pairs]:\n        base = (p.get("baseToken") or {})\n        sym  = base.get("symbol") or "?"\n        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")\n        if not mint:\n            continue\n\n        liq_usd = None\n        if isinstance(p.get("liquidity"), dict):\n            liq_usd = p["liquidity"].get("usd")\n        elif isinstance(p.get("liquidity"), (int, float)):\n            liq_usd = p.get("liquidity")\n\n        mcap = p.get("marketCap") or p.get("fdv")\n        age_min = _minutes_since_ms(p.get("pairCreatedAt"))\n\n        out.append({\n            "source": "dexscreener",\n            "symbol": sym,\n            "name": base.get("name") or sym,\n            "mint": mint,\n            "holders": None,\n            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n            "age_min": age_min,\n            "renounced_mint_auth": None,\n            "renounced_freeze_auth": None,\n        })\n    return out\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    """\n    Attempt to pull newest Pump.fun launches.\n    This is best-effort; if endpoints change, we fail gracefully and return [].\n    """\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 8, 'type': 'url'}, {'offset': 226, 'length': 8, 'type': 'url'}, {'offset': 399, 'length': 51, 'type': 'url'}, {'offset': 478, 'length': 8, 'type': 'url'}, {'offset': 717, 'length': 43, 'type': 'url'}, {'offset': 1500, 'length': 12, 'type': 'url'}, {'offset': 2988, 'length': 8, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 11:42:57,788 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:42:57,788 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue'
2025-08-10 11:42:57,788 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
2025-08-10 11:42:57,788 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:43:05,900 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:43:06,298 [INFO] app: [WEBHOOK] Command '/assistant Add Pump.fun as a second live source and merge with Dexscreener in data_fetcher.py, with safe fallbacks and mint-level de-dupe.

PATCH
=====

1) Update data_fetcher.py (create if missing; augment if present). Add a Pump.fun fetcher and merge logic.

# --- BEGIN PATCH: data_fetcher.py ---
import time, logging, math, requests
from datetime import datetime, timezone

DEXSCREENER_PAIRS = "https://api.dexscreener.com/latest/dex/pairs/solana"

# Try a couple of public Pump.fun endpoints (they may change; we handle failures gracefully):
PUMPFUN_ENDPOINTS = [
    # Unofficial frontend API (commonly used by trackers); newest first
    # returns JSON list of coins; we only read a few fields if present
    "https://frontend-api.pump.fun/coins/created",      # ?limit=200&offset=0 (we'll add params)
    # Legacy tRPC/aggregated endpoints sometimes mirrored by third parties could be inserted here
]

def _get_json(url, params=None, timeout=8, retries=2, backoff=0.6):
    for i in range(retries+1):
        try:
            r = requests.get(url, params=params or {}, timeout=timeout)
            if r.status_code == 200:
                return r.json()
            logging.warning("fetch %s -> HTTP %s", url, r.status_code)
        except Exception as e:
            logging.warning("fetch %s error: %s", url, e)
        time.sleep(backoff * (2 ** i))
    return None

def _minutes_since_ms(ms):
    try:
        dt = datetime.fromtimestamp(ms/1000, tz=timezone.utc)
        return max(0, (datetime.now(timezone.utc) - dt).total_seconds() / 60.0)
    except Exception:
        return None

def fetch_candidates_from_dexscreener(max_pairs=500):
    js = _get_json(DEXSCREENER_PAIRS)
    out = []
    if not js or "pairs" not in js:
        logging.warning("Dexscreener: no pairs payload")
        return out

    for p in js.get("pairs", [])[:max_pairs]:
        base = (p.get("baseToken") or {})
        sym  = base.get("symbol") or "?"
        mint = base.get("address") or p.get("baseTokenAddress") or p.get("pairAddress")
        if not mint:
            continue

        liq_usd = None
        if isinstance(p.get("liquidity"), dict):
            liq_usd = p["liquidity"].get("usd")
        elif isinstance(p.get("liquidity"), (int, float)):
            liq_usd = p.get("liquidity")

        mcap = p.get("marketCap") or p.get("fdv")
        age_min = _minutes_since_ms(p.get("pairCreatedAt"))

        out.append({
            "source": "dexscreener",
            "symbol": sym,
            "name": base.get("name") or sym,
            "mint": mint,
            "holders": None,
            "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
            "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
            "age_min": age_min,
            "renounced_mint_auth": None,
            "renounced_freeze_auth": None,
        })
    return out

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Attempt to pull newest Pump.fun launches.
    This is best-effort; if endpoints change, we fail gracefully and return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue' processed, response sent: 200
2025-08-10 11:43:06,428 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:43:06,429 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121219, 'message': {'message_id': 4165, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826177, 'text': '# Normalize a few known shapes:\n            items = []\n            # Case A: list of dicts under top-level\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                # timestamps frequently in seconds; convert to ms if looks small\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000:  # seconds -> ms\n                    ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n\n                # optional numeric fields\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n\ndef _passes_rules(t, rules):\n    s = rules.get("scan", {})\n    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):\n        return False\n    if t["holders"] is not None:\n        if t["holders"] < s.get("holders_min", 0): return False\n        if t["holders"] > s.get("holders_max", 10**12): return False\n    if t["mcap_usd"] is not None:\n        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False\n        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False\n    if t["liquidity_usd"] is not None:\n        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False\n    inc_kw = [k.lower() for k in s.get("include_keywords", [])]\n    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]\n    text = f"{t[\'symbol\']} {t[\'name\']}".lower()\n    if exc_kw and any(k in text for k in exc_kw): return False\n    if inc_kw and not any(k in text for k in inc_kw): return False\n    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False\n    return True\n\ndef _score_token(t, rules):\n    w = (rules.get("risk", {}) or {}).get("weights", {})\n    score = 0.0\n    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1\n    age_part = 0.6 if t["age_min"] is None else min(1.0, t["age_min"] / max_age)\n    score += 100.0 * w.get("age", 0.0) * age_part\n\n    if t["holders"] is None:\n        holders_part = 0.7\n    else:\n        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)\n        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))\n        rng  = max(1, hmax - hmin)\n        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))\n    score += 100.0 * w.get("holders", 0.0) * holders_part\n\n    if t["liquidity_usd"] is None:\n        liq_part = 0.7\n    else:\n        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)\n        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))\n    score += 100.0 * w.get("liquidity", 0.0) * liq_part', 'entities': [{'offset': 1772, 'length': 8, 'type': 'url'}]}}
2025-08-10 11:43:06,429 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:43:06,429 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# Normalize a few known shapes:
            items = []
            # Case A: list of dicts under top-level
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                # timestamps frequently in seconds; convert to ms if looks small
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                # optional numeric fields
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def _passes_rules(t, rules):
    s = rules.get("scan", {})
    if t["age_min"] is not None and t["age_min"] > s.get("max_age_minutes", 10**9):
        return False
    if t["holders"] is not None:
        if t["holders"] < s.get("holders_min", 0): return False
        if t["holders"] > s.get("holders_max", 10**12): return False
    if t["mcap_usd"] is not None:
        if t["mcap_usd"] < s.get("mcap_min_usd", 0): return False
        if t["mcap_usd"] > s.get("mcap_max_usd", 10**15): return False
    if t["liquidity_usd"] is not None:
        if t["liquidity_usd"] < s.get("liquidity_min_usd", 0): return False
    inc_kw = [k.lower() for k in s.get("include_keywords", [])]
    exc_kw = [k.lower() for k in s.get("exclude_keywords", [])]
    text = f"{t['symbol']} {t['name']}".lower()
    if exc_kw and any(k in text for k in exc_kw): return False
    if inc_kw and not any(k in text for k in inc_kw): return False
    if t["mint"] and t["mint"] in set(s.get("blacklist_contracts", [])): return False
    return True

def _score_token(t, rules):
    w = (rules.get("risk", {}) or {}).get("weights", {})
    score = 0.0
    max_age = (rules.get("scan", {}) or {}).get("max_age_minutes", 180) or 1
    age_part = 0.6 if t["age_min"] is None else min(1.0, t["age_min"] / max_age)
    score += 100.0 * w.get("age", 0.0) * age_part

    if t["holders"] is None:
        holders_part = 0.7
    else:
        hmin = (rules.get("scan", {}) or {}).get("holders_min", 1)
        hmax = (rules.get("scan", {}) or {}).get("holders_max", max(1000, hmin+1))
        rng  = max(1, hmax - hmin)
        holders_part = 1.0 - min(1.0, max(0.0, (t["holders"] - hmin) / rng))
    score += 100.0 * w.get("holders", 0.0) * holders_part

    if t["liquidity_usd"] is None:
        liq_part = 0.7
    else:
        lmin = (rules.get("scan", {}) or {}).get("liquidity_min_usd", 0)
        liq_part = 1.0 - min(1.0, max(0.0, (t["liquidity_usd"] - lmin) / max(1, 10*lmin or 1)))
    score += 100.0 * w.get("liquidity", 0.0) * liq_part'
2025-08-10 11:43:06,545 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:43:06,552 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121220, 'message': {'message_id': 4166, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826177, 'text': 'if t["mcap_usd"] is None:\n        mcap_part = 0.6\n    else:\n        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)\n        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)\n        if t["mcap_usd"] < mmin: mcap_part = 1.0\n        elif t["mcap_usd"] > mmax: mcap_part = 0.8\n        else:\n            g = math.sqrt(max(mmin,1) * max(mmax,1))\n            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)\n    score += 100.0 * w.get("mcap", 0.0) * mcap_part\n\n    ren_part = 0.3\n    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:\n        ren_part = 0.0\n    score += 100.0 * w.get("renounce", 0.0) * ren_part\n\n    return round(score, 2)\n\ndef _dedupe_keep_best(items):\n    """De-dupe by mint; prefer Pump.fun for very new (age_min smaller), else lowest risk."""\n    by_mint = {}\n    for t in items:\n        m = t.get("mint")\n        if not m:\n            continue\n        if m not in by_mint:\n            by_mint[m] = t\n        else:\n            a, b = by_mint[m], t\n            # If one is Pump.fun and looks newer, prefer it; else lower risk\n            if (b.get("source") == "pumpfun" and (b.get("age_min") or 1e9) < (a.get("age_min") or 1e9)):\n                by_mint[m] = b\n            elif b.get("risk", 999) < a.get("risk", 999):\n                by_mint[m] = b\n    return list(by_mint.values())\n\ndef fetch_and_rank(rules):\n    """Merge Pump.fun + Dexscreener, filter by rules, score, de-dupe, sort by ascending risk."""\n    all_items = []\n    try:\n        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)\n        all_items.extend(pf)\n    except Exception as e:\n        logging.warning("Pump.fun source failed: %s", e)\n\n    try:\n        dx = fetch_candidates_from_dexscreener(max_pairs=500)\n        all_items.extend(dx)\n    except Exception as e:\n        logging.warning("Dexscreener source failed: %s", e)\n\n    # Filter\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n\n    # Score\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    # De-dupe and final sort\n    filtered = _dedupe_keep_best(filtered)\n    filtered.sort(key=lambda x: (x["risk"], -(x.get("liquidity_usd") or 0)))\n    return filtered\n# --- END PATCH: data_fetcher.py ---\n\n2) No changes needed to rules.yaml. If you want stricter “ultra-new” filtering, lower scan.max_age_minutes and/or liquidity/mcap floors, then /rules_reload.\n\nVALIDATION\n==========\n- Restart the app (Replit → Run).\n- In Telegram:\n  /rules_reload  -> expect ✅ Rules reloaded (v1)\n  /fetch_now     -> expect table titled \'live Dexscreener\' OR mixed with Pump.fun (source is internal, but newer coins should appear)\n- If no results, loosen rules (e.g., holders_min: 0, liquidity_min_usd: 1000), then /rules_reload and /fetch_now.', 'entities': [{'offset': 767, 'length': 8, 'type': 'url'}, {'offset': 1058, 'length': 8, 'type': 'url'}, {'offset': 1411, 'length': 8, 'type': 'url'}, {'offset': 1668, 'length': 8, 'type': 'url'}, {'offset': 2694, 'length': 13, 'type': 'bot_command'}, {'offset': 2783, 'length': 13, 'type': 'bot_command'}, {'offset': 2832, 'length': 10, 'type': 'bot_command'}, {'offset': 2903, 'length': 8, 'type': 'url'}, {'offset': 3048, 'length': 13, 'type': 'bot_command'}, {'offset': 3066, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:43:06,552 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:43:06,552 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'if t["mcap_usd"] is None:
        mcap_part = 0.6
    else:
        mmin = (rules.get("scan", {}) or {}).get("mcap_min_usd", 0)
        mmax = (rules.get("scan", {}) or {}).get("mcap_max_usd", 10**12)
        if t["mcap_usd"] < mmin: mcap_part = 1.0
        elif t["mcap_usd"] > mmax: mcap_part = 0.8
        else:
            g = math.sqrt(max(mmin,1) * max(mmax,1))
            mcap_part = min(1.0, abs(math.log((t["mcap_usd"]+1)/(g+1))) / 2.5)
    score += 100.0 * w.get("mcap", 0.0) * mcap_part

    ren_part = 0.3
    if t["renounced_mint_auth"] is True and t["renounced_freeze_auth"] is True:
        ren_part = 0.0
    score += 100.0 * w.get("renounce", 0.0) * ren_part

    return round(score, 2)

def _dedupe_keep_best(items):
    """De-dupe by mint; prefer Pump.fun for very new (age_min smaller), else lowest risk."""
    by_mint = {}
    for t in items:
        m = t.get("mint")
        if not m:
            continue
        if m not in by_mint:
            by_mint[m] = t
        else:
            a, b = by_mint[m], t
            # If one is Pump.fun and looks newer, prefer it; else lower risk
            if (b.get("source") == "pumpfun" and (b.get("age_min") or 1e9) < (a.get("age_min") or 1e9)):
                by_mint[m] = b
            elif b.get("risk", 999) < a.get("risk", 999):
                by_mint[m] = b
    return list(by_mint.values())

def fetch_and_rank(rules):
    """Merge Pump.fun + Dexscreener, filter by rules, score, de-dupe, sort by ascending risk."""
    all_items = []
    try:
        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)
        all_items.extend(pf)
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        dx = fetch_candidates_from_dexscreener(max_pairs=500)
        all_items.extend(dx)
    except Exception as e:
        logging.warning("Dexscreener source failed: %s", e)

    # Filter
    filtered = [t for t in all_items if _passes_rules(t, rules)]

    # Score
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    # De-dupe and final sort
    filtered = _dedupe_keep_best(filtered)
    filtered.sort(key=lambda x: (x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH: data_fetcher.py ---

2) No changes needed to rules.yaml. If you want stricter “ultra-new” filtering, lower scan.max_age_minutes and/or liquidity/mcap floors, then /rules_reload.

VALIDATION
==========
- Restart the app (Replit → Run).
- In Telegram:
  /rules_reload  -> expect ✅ Rules reloaded (v1)
  /fetch_now     -> expect table titled 'live Dexscreener' OR mixed with Pump.fun (source is internal, but newer coins should appear)
- If no results, loosen rules (e.g., holders_min: 0, liquidity_min_usd: 1000), then /rules_reload and /fetch_now.'
2025-08-10 11:43:10,982 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:43:10,982 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121221, 'message': {'message_id': 4168, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826190, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:43:10,983 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:43:10,983 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:43:10,984 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:43:10,984 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:46:16,092 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:46:16,092 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121222, 'message': {'message_id': 4170, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826375, 'text': '/assistant Update live fetch to (1) add a visible \'source\' column and (2) use a confirmed Pump.fun endpoint for ultra-new launches.\n\nPATCH\n=====\n\n1) data_fetcher.py — set a stable Pump.fun endpoint and keep graceful fallback; no other deps.\n\n# --- BEGIN PATCH: data_fetcher.py (only the Pump.fun section changes) ---\n# Try a confirmed Pump.fun endpoint (newest launches). We still keep the list for future fallbacks.\nPUMPFUN_ENDPOINTS = [\n    # confirmed public frontend endpoint; supports ?limit=&offset=\n    "https://frontend-api.pump.fun/coins/created",\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    """\n    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].\n    """\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue\n\n            items = []\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000:  # seconds -> ms\n                    ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n# --- END PATCH ---\n \n2) alerts/telegram.py — show \'source\' in /fetch_now output.\n\n# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---\n# Replace the header + line builder in cmd_fetch_now_sync with:\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in items:\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd")\n            liq  = t.get("liquidity_usd")\n            age  = t.get("age_min")\n            src  = t.get("source", "?")\n            lines.append(f"{src} | {t[\'symbol\']} | {t[\'name\'][:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'} | {t[\'risk\']}")\n# --- END PATCH ---\n\nNOTES\n=====\n- No new libraries required.\n- If the Pump.fun endpoint is temporarily empty, Dexscreener results will still appear (we log a warning).\n- You can loosen rules (holders_min: 0, liquidity_min_usd: 1000) to see more ultra-new Pump.fun tokens during testing.\n\nDONE', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 90, 'length': 8, 'type': 'url'}, {'offset': 180, 'length': 8, 'type': 'url'}, {'offset': 287, 'length': 8, 'type': 'url'}, {'offset': 335, 'length': 8, 'type': 'url'}, {'offset': 511, 'length': 43, 'type': 'url'}, {'offset': 640, 'length': 8, 'type': 'url'}, {'offset': 2493, 'length': 8, 'type': 'url'}, {'offset': 2591, 'length': 11, 'type': 'url'}, {'offset': 2622, 'length': 10, 'type': 'bot_command'}, {'offset': 2668, 'length': 11, 'type': 'url'}, {'offset': 3397, 'length': 8, 'type': 'url'}, {'offset': 3582, 'length': 8, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 11:46:16,092 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:46:16,092 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Update live fetch to (1) add a visible 'source' column and (2) use a confirmed Pump.fun endpoint for ultra-new launches.

PATCH
=====

1) data_fetcher.py — set a stable Pump.fun endpoint and keep graceful fallback; no other deps.

# --- BEGIN PATCH: data_fetcher.py (only the Pump.fun section changes) ---
# Try a confirmed Pump.fun endpoint (newest launches). We still keep the list for future fallbacks.
PUMPFUN_ENDPOINTS = [
    # confirmed public frontend endpoint; supports ?limit=&offset=
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' in /fetch_now output.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            lines.append(f"{src} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No new libraries required.
- If the Pump.fun endpoint is temporarily empty, Dexscreener results will still appear (we log a warning).
- You can loosen rules (holders_min: 0, liquidity_min_usd: 1000) to see more ultra-new Pump.fun tokens during testing.

DONE'
2025-08-10 11:46:16,092 [INFO] app: [WEBHOOK] Admin command detected: /assistant Update live fetch to (1) add a visible 'source' column and (2) use a confirmed Pump.fun endpoint for ultra-new launches.

PATCH
=====

1) data_fetcher.py — set a stable Pump.fun endpoint and keep graceful fallback; no other deps.

# --- BEGIN PATCH: data_fetcher.py (only the Pump.fun section changes) ---
# Try a confirmed Pump.fun endpoint (newest launches). We still keep the list for future fallbacks.
PUMPFUN_ENDPOINTS = [
    # confirmed public frontend endpoint; supports ?limit=&offset=
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' in /fetch_now output.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            lines.append(f"{src} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No new libraries required.
- If the Pump.fun endpoint is temporarily empty, Dexscreener results will still appear (we log a warning).
- You can loosen rules (holders_min: 0, liquidity_min_usd: 1000) to see more ultra-new Pump.fun tokens during testing.

DONE
2025-08-10 11:46:16,092 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:46:19,832 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:46:20,274 [INFO] app: [WEBHOOK] Command '/assistant Update live fetch to (1) add a visible 'source' column and (2) use a confirmed Pump.fun endpoint for ultra-new launches.

PATCH
=====

1) data_fetcher.py — set a stable Pump.fun endpoint and keep graceful fallback; no other deps.

# --- BEGIN PATCH: data_fetcher.py (only the Pump.fun section changes) ---
# Try a confirmed Pump.fun endpoint (newest launches). We still keep the list for future fallbacks.
PUMPFUN_ENDPOINTS = [
    # confirmed public frontend endpoint; supports ?limit=&offset=
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' in /fetch_now output.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            lines.append(f"{src} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No new libraries required.
- If the Pump.fun endpoint is temporarily empty, Dexscreener results will still appear (we log a warning).
- You can loosen rules (holders_min: 0, liquidity_min_usd: 1000) to see more ultra-new Pump.fun tokens during testing.

DONE' processed, response sent: 200
2025-08-10 11:46:47,091 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:46:47,092 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121223, 'message': {'message_id': 4172, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826407, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:46:47,092 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:46:47,092 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:46:47,092 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:46:47,092 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:50:09,072 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:50:09,073 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121224, 'message': {'message_id': 4174, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826608, 'text': '/assistant Update live fetch to add a \'source\' column, use the confirmed Pump.fun endpoint, and highlight Pump.fun rows with a green marker.\n\nPATCH\n=====\n\n1) data_fetcher.py — set stable Pump.fun endpoint (still graceful if empty).\n\n# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits only) ---\nPUMPFUN_ENDPOINTS = [\n    "https://frontend-api.pump.fun/coins/created",  # supports ?limit=&offset=\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    """\n    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].\n    """\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue\n            items = []\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000:  # seconds -> ms\n                    ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n# --- END PATCH ---\n\n2) alerts/telegram.py — show source column and mark Pump.fun rows with 🟢.\n\n# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---\n# Replace the header + line builder in cmd_fetch_now_sync with:\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in items:\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd")\n            liq  = t.get("liquidity_usd")\n            age  = t.get("age_min")\n            src  = t.get("source", "?")\n            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"\n            lines.append(f"{src_label} | {t[\'symbol\']} | {t[\'name\'][:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'} | {t[\'risk\']}")\n# --- END PATCH ---\n\nNOTES\n=====\n- No real green text in Telegram code blocks; the 🟢 marker is the reliable cross-client highlight.\n- If Pump.fun is quiet or the endpoint changes, you’ll still see Dexscreener results (warnings logged).\n- To surface more ultra-new tokens while testing, temporarily set in rules.yaml:\n  holders_min: 0\n  liquidity_min_usd: 1000\n  mcap_min_usd: 0\nThen /rules_reload and /fetch_now.\n\nDONE', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 73, 'length': 8, 'type': 'url'}, {'offset': 106, 'length': 8, 'type': 'url'}, {'offset': 187, 'length': 8, 'type': 'url'}, {'offset': 269, 'length': 8, 'type': 'url'}, {'offset': 320, 'length': 43, 'type': 'url'}, {'offset': 477, 'length': 8, 'type': 'url'}, {'offset': 2326, 'length': 8, 'type': 'url'}, {'offset': 2423, 'length': 11, 'type': 'url'}, {'offset': 2465, 'length': 8, 'type': 'url'}, {'offset': 2515, 'length': 11, 'type': 'url'}, {'offset': 3393, 'length': 8, 'type': 'url'}, {'offset': 3639, 'length': 13, 'type': 'bot_command'}, {'offset': 3657, 'length': 10, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 11:50:09,073 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:50:09,073 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Update live fetch to add a 'source' column, use the confirmed Pump.fun endpoint, and highlight Pump.fun rows with a green marker.

PATCH
=====

1) data_fetcher.py — set stable Pump.fun endpoint (still graceful if empty).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits only) ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",  # supports ?limit=&offset=
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---

2) alerts/telegram.py — show source column and mark Pump.fun rows with 🟢.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No real green text in Telegram code blocks; the 🟢 marker is the reliable cross-client highlight.
- If Pump.fun is quiet or the endpoint changes, you’ll still see Dexscreener results (warnings logged).
- To surface more ultra-new tokens while testing, temporarily set in rules.yaml:
  holders_min: 0
  liquidity_min_usd: 1000
  mcap_min_usd: 0
Then /rules_reload and /fetch_now.

DONE'
2025-08-10 11:50:09,073 [INFO] app: [WEBHOOK] Admin command detected: /assistant Update live fetch to add a 'source' column, use the confirmed Pump.fun endpoint, and highlight Pump.fun rows with a green marker.

PATCH
=====

1) data_fetcher.py — set stable Pump.fun endpoint (still graceful if empty).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits only) ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",  # supports ?limit=&offset=
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---

2) alerts/telegram.py — show source column and mark Pump.fun rows with 🟢.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No real green text in Telegram code blocks; the 🟢 marker is the reliable cross-client highlight.
- If Pump.fun is quiet or the endpoint changes, you’ll still see Dexscreener results (warnings logged).
- To surface more ultra-new tokens while testing, temporarily set in rules.yaml:
  holders_min: 0
  liquidity_min_usd: 1000
  mcap_min_usd: 0
Then /rules_reload and /fetch_now.

DONE
2025-08-10 11:50:09,073 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:50:12,732 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:50:13,118 [INFO] app: [WEBHOOK] Command '/assistant Update live fetch to add a 'source' column, use the confirmed Pump.fun endpoint, and highlight Pump.fun rows with a green marker.

PATCH
=====

1) data_fetcher.py — set stable Pump.fun endpoint (still graceful if empty).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits only) ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",  # supports ?limit=&offset=
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []
# --- END PATCH ---

2) alerts/telegram.py — show source column and mark Pump.fun rows with 🟢.

# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync) ---
# Replace the header + line builder in cmd_fetch_now_sync with:
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No real green text in Telegram code blocks; the 🟢 marker is the reliable cross-client highlight.
- If Pump.fun is quiet or the endpoint changes, you’ll still see Dexscreener results (warnings logged).
- To surface more ultra-new tokens while testing, temporarily set in rules.yaml:
  holders_min: 0
  liquidity_min_usd: 1000
  mcap_min_usd: 0
Then /rules_reload and /fetch_now.

DONE' processed, response sent: 200
2025-08-10 11:50:43,365 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:50:43,365 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:50:43,366 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:50:43,373 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:50:44,538 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:50:59,262 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:50:59,262 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121225, 'message': {'message_id': 4176, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826659, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:50:59,263 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:50:59,263 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:50:59,263 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:50:59,263 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:50:59,272 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:50:59,320 [INFO] root: [RULES] Loaded (v1)
2025-08-10 11:51:10,935 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:51:10,935 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121226, 'message': {'message_id': 4178, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826670, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:51:10,935 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:51:10,935 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:51:10,935 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:51:10,936 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 11:51:58,934 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:51:58,935 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:51:58,935 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:51:58,938 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:51:59,790 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:54:45,994 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:54:45,994 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121227, 'message': {'message_id': 4180, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826885, 'text': '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.\n\nPATCH\n=====\n\n1) data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).\n\n# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---\n# Confirmed public Pump.fun endpoint (supports ?limit=&offset=)\nPUMPFUN_ENDPOINTS = [\n    "https://frontend-api.pump.fun/coins/created",\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    """\n    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].\n    """\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue\n\n            items = []\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000:  # seconds -> ms\n                    ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n\ndef fetch_and_rank(rules):\n    """Merge Pump.fun + Dexscreener, filter, score, de-dupe, and order with Pump.fun first."""\n    all_items = []\n    try:\n        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)\n        all_items.extend(pf)  # Pump.fun ingested first\n    except Exception as e:\n        logging.warning("Pump.fun source failed: %s", e)\n\n    try:\n        dx = fetch_candidates_from_dexscreener(max_pairs=500)\n        all_items.extend(dx)\n    except Exception as e:\n        logging.warning("Dexscreener source failed: %s", e)\n\n    # Filter by rules\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n\n    # Score and coerce\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    # De-dupe by mint (keeps newer Pump.fun when available, else lowest risk)\n    filtered = _dedupe_keep_best(filtered)\n\n    # Pump.fun first, then lowest risk, then higher liquidity\n    def _src_priority(src): return 0 if src == "pumpfun" else 1\n    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))\n    return filtered\n# --- END PATCH ---\n \n2) alerts/telegram.py — show \'source\' and mark Pump.fun with 🟢 in /fetch_now.', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 8, 'type': 'url'}, {'offset': 75, 'length': 8, 'type': 'url'}, {'offset': 138, 'length': 8, 'type': 'url'}, {'offset': 176, 'length': 8, 'type': 'url'}, {'offset': 247, 'length': 8, 'type': 'url'}, {'offset': 302, 'length': 8, 'type': 'url'}, {'offset': 374, 'length': 43, 'type': 'url'}, {'offset': 503, 'length': 8, 'type': 'url'}, {'offset': 2356, 'length': 8, 'type': 'url'}, {'offset': 2463, 'length': 8, 'type': 'url'}, {'offset': 2526, 'length': 8, 'type': 'url'}, {'offset': 2669, 'length': 8, 'type': 'url'}, {'offset': 2745, 'length': 8, 'type': 'url'}, {'offset': 3477, 'length': 8, 'type': 'url'}, {'offset': 3570, 'length': 8, 'type': 'url'}, {'offset': 3851, 'length': 11, 'type': 'url'}, {'offset': 3888, 'length': 8, 'type': 'url'}, {'offset': 3908, 'length': 10, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 11:54:45,995 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:54:45,995 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

1) data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
# Confirmed public Pump.fun endpoint (supports ?limit=&offset=)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    """Merge Pump.fun + Dexscreener, filter, score, de-dupe, and order with Pump.fun first."""
    all_items = []
    try:
        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)
        all_items.extend(pf)  # Pump.fun ingested first
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        dx = fetch_candidates_from_dexscreener(max_pairs=500)
        all_items.extend(dx)
    except Exception as e:
        logging.warning("Dexscreener source failed: %s", e)

    # Filter by rules
    filtered = [t for t in all_items if _passes_rules(t, rules)]

    # Score and coerce
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    # De-dupe by mint (keeps newer Pump.fun when available, else lowest risk)
    filtered = _dedupe_keep_best(filtered)

    # Pump.fun first, then lowest risk, then higher liquidity
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' and mark Pump.fun with 🟢 in /fetch_now.'
2025-08-10 11:54:45,995 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

1) data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
# Confirmed public Pump.fun endpoint (supports ?limit=&offset=)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    """Merge Pump.fun + Dexscreener, filter, score, de-dupe, and order with Pump.fun first."""
    all_items = []
    try:
        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)
        all_items.extend(pf)  # Pump.fun ingested first
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        dx = fetch_candidates_from_dexscreener(max_pairs=500)
        all_items.extend(dx)
    except Exception as e:
        logging.warning("Dexscreener source failed: %s", e)

    # Filter by rules
    filtered = [t for t in all_items if _passes_rules(t, rules)]

    # Score and coerce
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    # De-dupe by mint (keeps newer Pump.fun when available, else lowest risk)
    filtered = _dedupe_keep_best(filtered)

    # Pump.fun first, then lowest risk, then higher liquidity
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' and mark Pump.fun with 🟢 in /fetch_now.
2025-08-10 11:54:45,995 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 11:54:45,997 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:54:49,789 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 11:54:50,280 [INFO] app: [WEBHOOK] Command '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

1) data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

# --- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
# Confirmed public Pump.fun endpoint (supports ?limit=&offset=)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    """
    Pull newest Pump.fun launches. Best-effort; if endpoint shape changes we log + return [].
    """
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue

            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")

                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000:  # seconds -> ms
                    ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None

                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")

                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    """Merge Pump.fun + Dexscreener, filter, score, de-dupe, and order with Pump.fun first."""
    all_items = []
    try:
        pf = fetch_candidates_from_pumpfun(limit=200, offset=0)
        all_items.extend(pf)  # Pump.fun ingested first
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        dx = fetch_candidates_from_dexscreener(max_pairs=500)
        all_items.extend(dx)
    except Exception as e:
        logging.warning("Dexscreener source failed: %s", e)

    # Filter by rules
    filtered = [t for t in all_items if _passes_rules(t, rules)]

    # Score and coerce
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    # De-dupe by mint (keeps newer Pump.fun when available, else lowest risk)
    filtered = _dedupe_keep_best(filtered)

    # Pump.fun first, then lowest risk, then higher liquidity
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH ---
 
2) alerts/telegram.py — show 'source' and mark Pump.fun with 🟢 in /fetch_now.' processed, response sent: 200
2025-08-10 11:54:50,398 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:54:50,398 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121228, 'message': {'message_id': 4181, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826885, 'text': '# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync output block) ---\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in items:\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd")\n            liq  = t.get("liquidity_usd")\n            age  = t.get("age_min")\n            src  = t.get("source", "?")\n            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"\n            lines.append(f"{src_label} | {t[\'symbol\']} | {t[\'name\'][:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'} | {t[\'risk\']}")\n# --- END PATCH ---\n\nNOTES\n=====\n- No new dependencies.\n- If Pump.fun is quiet or changes, you’ll still see Dexscreener rows (warnings are logged).\n- To surface more ultra-new Pump.fun tokens while testing, temporarily set in rules.yaml:\n  holders_min: 0\n  liquidity_min_usd: 1000\n  mcap_min_usd: 0\nThen /rules_reload and /fetch_now.\n\nDONE', 'entities': [{'offset': 26, 'length': 11, 'type': 'url'}, {'offset': 776, 'length': 8, 'type': 'url'}, {'offset': 891, 'length': 8, 'type': 'url'}, {'offset': 1019, 'length': 13, 'type': 'bot_command'}, {'offset': 1037, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:54:50,398 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:54:50,398 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# --- BEGIN PATCH: alerts/telegram.py (inside cmd_fetch_now_sync output block) ---
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
# --- END PATCH ---

NOTES
=====
- No new dependencies.
- If Pump.fun is quiet or changes, you’ll still see Dexscreener rows (warnings are logged).
- To surface more ultra-new Pump.fun tokens while testing, temporarily set in rules.yaml:
  holders_min: 0
  liquidity_min_usd: 1000
  mcap_min_usd: 0
Then /rules_reload and /fetch_now.

DONE'
2025-08-10 11:55:15,253 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:55:15,254 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 11:55:15,254 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 11:55:15,256 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 11:55:15,902 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 11:55:30,715 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:55:30,716 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121229, 'message': {'message_id': 4183, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826930, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 11:55:30,716 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:55:30,716 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 11:55:30,716 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 11:55:30,716 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 11:55:30,717 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 11:55:30,739 [INFO] root: [RULES] Loaded (v1)
2025-08-10 11:55:44,093 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 11:55:44,093 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121230, 'message': {'message_id': 4185, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754826944, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 11:55:44,093 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 11:55:44,093 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 11:55:44,093 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 11:55:44,094 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:03:10,853 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:03:10,854 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121231, 'message': {'message_id': 4187, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827390, 'text': '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.\n\nPATCH\ndata_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).\n\n--- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---\nPUMPFUN_ENDPOINTS = [\n"https://frontend-api.pump.fun/coins/created",\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\nfor base in PUMPFUN_ENDPOINTS:\ntry:\nparams = {"limit": limit, "offset": offset}\njs = _get_json(base, params=params)\nif not js:\ncontinue\nitems = []\nrows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\nfor c in rows:\nmint = c.get("mint") or c.get("mintAddress") or c.get("address")\nif not mint:\ncontinue\nname = c.get("name") or c.get("tokenName") or "Pump"\nsym = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\nts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\nif ts is not None and ts < 10_000_000_000: ts *= 1000\nage_min = _minutes_since_ms(ts) if ts else None\nmcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\nliq = c.get("liquidity_usd") or c.get("liquidity")\nitems.append({\n"source": "pumpfun",\n"symbol": sym or "?",\n"name": name or sym or "Pump",\n"mint": mint,\n"holders": c.get("holders") or None,\n"mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n"liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n"age_min": age_min,\n"renounced_mint_auth": None,\n"renounced_freeze_auth": None,\n})\nif items: return items\nexcept Exception as e:\nlogging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\nreturn []\n\ndef fetch_and_rank(rules):\nall_items = []\ntry: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))\nexcept Exception as e: logging.warning("Pump.fun source failed: %s", e)\ntry: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))\nexcept Exception as e: logging.warning("Dexscreener source failed: %s", e)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 8, 'type': 'url'}, {'offset': 75, 'length': 8, 'type': 'url'}, {'offset': 128, 'length': 8, 'type': 'url'}, {'offset': 166, 'length': 8, 'type': 'url'}, {'offset': 235, 'length': 8, 'type': 'url'}, {'offset': 294, 'length': 43, 'type': 'url'}, {'offset': 1579, 'length': 8, 'type': 'url'}, {'offset': 1798, 'length': 8, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 12:03:10,854 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:03:10,854 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

--- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
PUMPFUN_ENDPOINTS = [
"https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
for base in PUMPFUN_ENDPOINTS:
try:
params = {"limit": limit, "offset": offset}
js = _get_json(base, params=params)
if not js:
continue
items = []
rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
for c in rows:
mint = c.get("mint") or c.get("mintAddress") or c.get("address")
if not mint:
continue
name = c.get("name") or c.get("tokenName") or "Pump"
sym = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
if ts is not None and ts < 10_000_000_000: ts *= 1000
age_min = _minutes_since_ms(ts) if ts else None
mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
liq = c.get("liquidity_usd") or c.get("liquidity")
items.append({
"source": "pumpfun",
"symbol": sym or "?",
"name": name or sym or "Pump",
"mint": mint,
"holders": c.get("holders") or None,
"mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
"liquidity_usd": liq if isinstance(liq, (int, float)) else None,
"age_min": age_min,
"renounced_mint_auth": None,
"renounced_freeze_auth": None,
})
if items: return items
except Exception as e:
logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
return []

def fetch_and_rank(rules):
all_items = []
try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
except Exception as e: logging.warning("Pump.fun source failed: %s", e)
try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
except Exception as e: logging.warning("Dexscreener source failed: %s", e)'
2025-08-10 12:03:10,854 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

--- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
PUMPFUN_ENDPOINTS = [
"https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
for base in PUMPFUN_ENDPOINTS:
try:
params = {"limit": limit, "offset": offset}
js = _get_json(base, params=params)
if not js:
continue
items = []
rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
for c in rows:
mint = c.get("mint") or c.get("mintAddress") or c.get("address")
if not mint:
continue
name = c.get("name") or c.get("tokenName") or "Pump"
sym = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
if ts is not None and ts < 10_000_000_000: ts *= 1000
age_min = _minutes_since_ms(ts) if ts else None
mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
liq = c.get("liquidity_usd") or c.get("liquidity")
items.append({
"source": "pumpfun",
"symbol": sym or "?",
"name": name or sym or "Pump",
"mint": mint,
"holders": c.get("holders") or None,
"mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
"liquidity_usd": liq if isinstance(liq, (int, float)) else None,
"age_min": age_min,
"renounced_mint_auth": None,
"renounced_freeze_auth": None,
})
if items: return items
except Exception as e:
logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
return []

def fetch_and_rank(rules):
all_items = []
try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
except Exception as e: logging.warning("Pump.fun source failed: %s", e)
try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
except Exception as e: logging.warning("Dexscreener source failed: %s", e)
2025-08-10 12:03:10,854 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 12:03:19,824 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 12:03:20,212 [INFO] app: [WEBHOOK] Command '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
data_fetcher.py — ensure Pump.fun endpoint + merge + ordering (Pump.fun first, then lower risk).

--- BEGIN PATCH: data_fetcher.py (Pump.fun bits and final sorter) ---
PUMPFUN_ENDPOINTS = [
"https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
for base in PUMPFUN_ENDPOINTS:
try:
params = {"limit": limit, "offset": offset}
js = _get_json(base, params=params)
if not js:
continue
items = []
rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
for c in rows:
mint = c.get("mint") or c.get("mintAddress") or c.get("address")
if not mint:
continue
name = c.get("name") or c.get("tokenName") or "Pump"
sym = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
if ts is not None and ts < 10_000_000_000: ts *= 1000
age_min = _minutes_since_ms(ts) if ts else None
mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
liq = c.get("liquidity_usd") or c.get("liquidity")
items.append({
"source": "pumpfun",
"symbol": sym or "?",
"name": name or sym or "Pump",
"mint": mint,
"holders": c.get("holders") or None,
"mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
"liquidity_usd": liq if isinstance(liq, (int, float)) else None,
"age_min": age_min,
"renounced_mint_auth": None,
"renounced_freeze_auth": None,
})
if items: return items
except Exception as e:
logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
return []

def fetch_and_rank(rules):
all_items = []
try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
except Exception as e: logging.warning("Pump.fun source failed: %s", e)
try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
except Exception as e: logging.warning("Dexscreener source failed: %s", e)' processed, response sent: 200
2025-08-10 12:05:04,186 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:05:04,187 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121232, 'message': {'message_id': 4189, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827503, 'text': '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.\n\nPATCH\n=====\n\n# --- data_fetcher.py ---\nPUMPFUN_ENDPOINTS = [\n    "https://frontend-api.pump.fun/coins/created",\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json(base, params=params)\n            if not js:\n                continue\n            items = []\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000: ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items: return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    return []\n\ndef fetch_and_rank(rules):\n    all_items = []\n    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))\n    except Exception as e: logging.warning("Pump.fun source failed: %s", e)\n    try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))\n    except Exception as e: logging.warning("Dexscreener source failed: %s", e)\n\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    filtered = _dedupe_keep_best(filtered)\n    def _src_priority(src): return 0 if src == "pumpfun" else 1\n    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))\n    return filtered\n\n# --- alerts/telegram.py ---\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]\n        for t in items:\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd")\n            liq  = t.get("liquidity_usd")\n            age  = t.get("age_min")\n            src  = t.get("source", "?")\n            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"\n            lines.append(f"{src_label} | {t[\'symbol\']} | {t[\'name\'][:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'} | {t[\'risk\']}")', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 8, 'type': 'url'}, {'offset': 75, 'length': 8, 'type': 'url'}, {'offset': 163, 'length': 43, 'type': 'url'}, {'offset': 1978, 'length': 8, 'type': 'url'}, {'offset': 2213, 'length': 8, 'type': 'url'}, {'offset': 3081, 'length': 11, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 12:05:04,187 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:05:04,187 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

# --- data_fetcher.py ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items: return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    all_items = []
    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e: logging.warning("Pump.fun source failed: %s", e)
    try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
    except Exception as e: logging.warning("Dexscreener source failed: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered

# --- alerts/telegram.py ---
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")'
2025-08-10 12:05:04,187 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

# --- data_fetcher.py ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items: return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    all_items = []
    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e: logging.warning("Pump.fun source failed: %s", e)
    try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
    except Exception as e: logging.warning("Dexscreener source failed: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered

# --- alerts/telegram.py ---
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")
2025-08-10 12:05:04,187 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 12:05:10,899 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 12:05:11,269 [INFO] app: [WEBHOOK] Command '/assistant Add Pump.fun source + source column + green highlight, and show Pump.fun rows first.

PATCH
=====

# --- data_fetcher.py ---
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json(base, params=params)
            if not js:
                continue
            items = []
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items: return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    return []

def fetch_and_rank(rules):
    all_items = []
    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e: logging.warning("Pump.fun source failed: %s", e)
    try: all_items.extend(fetch_candidates_from_dexscreener(max_pairs=500))
    except Exception as e: logging.warning("Dexscreener source failed: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered

# --- alerts/telegram.py ---
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min | risk"]
        for t in items:
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd")
            liq  = t.get("liquidity_usd")
            age  = t.get("age_min")
            src  = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else "dexscreener"
            lines.append(f"{src_label} | {t['symbol']} | {t['name'][:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'} | {t['risk']}")' processed, response sent: 200
2025-08-10 12:05:22,192 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:05:22,193 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121233, 'message': {'message_id': 4191, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827522, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:05:22,193 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:05:22,194 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 12:05:22,195 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 12:05:22,195 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 12:05:22,267 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:05:31,913 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:05:31,913 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121234, 'message': {'message_id': 4193, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827531, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 12:05:31,913 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:05:31,914 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 12:05:31,914 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:05:31,914 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:05:42,424 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:05:42,425 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:05:42,425 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:05:42,428 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:05:43,274 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:05:56,306 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:05:56,307 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121235, 'message': {'message_id': 4195, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827556, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 12:05:56,307 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:05:56,307 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 12:05:56,307 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:05:56,307 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:05:56,308 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:05:56,339 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:08:26,199 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:08:26,199 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121236, 'message': {'message_id': 4197, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827705, 'text': '/assistant Add a diagnostic /fetch_source command to verify Pump.fun ingestion and show the source column with a green tag.\n\nPATCH\n=====\n\n1) alerts/telegram.py — add a debug command to fetch Pump.fun directly (no rules), and format with a source column.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\n# Put near other imports:\nfrom data_fetcher import fetch_candidates_from_pumpfun\n\n# Add this helper where other sync handlers live:\nasync def cmd_fetch_source_sync(update, context):\n    try:\n        text = update.message.text.strip()\n        parts = text.split(maxsplit=1)\n        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"\n\n        items = []\n        if wanted in ("pumpfun", "pf", "pump"):\n            items = fetch_candidates_from_pumpfun(limit=50, offset=0)\n        else:\n            await update.message.reply_text("Usage: /fetch_source pumpfun")\n            return "ok"\n\n        # Basic table with source + green tag for pumpfun\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]\n        for t in items[:20]:\n            src = t.get("source", "?")\n            src_label = "🟢 pumpfun" if src == "pumpfun" else src\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")\n            lines.append(f"{src_label} | {t.get(\'symbol\',\'?\')} | {t.get(\'name\',\'?\')[:20]} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'}")\n\n        block = "```\\n" + "\\n".join(lines) + "\\n```"\n        await update.message.reply_text(block, parse_mode="Markdown")\n        return "ok"\n    except Exception as e:\n        logging.exception("fetch_source error")\n        await update.message.reply_text(f"❌ fetch_source failed: {e}")\n        return "ok"\n# --- END PATCH ---\n\n2) app.py (Flask webhook router) — route the new command (place with the other admin routes, BEFORE the unknown fallback).\n\n# --- BEGIN PATCH: app.py ---\n        if text.startswith("/fetch_source"):\n            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n                _reply("Not authorized."); return "ok"\n            from alerts.telegram import cmd_fetch_source_sync\n            _reply(await cmd_fetch_source_sync(update, None)); return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 28, 'length': 13, 'type': 'bot_command'}, {'offset': 60, 'length': 8, 'type': 'url'}, {'offset': 148, 'length': 11, 'type': 'url'}, {'offset': 191, 'length': 8, 'type': 'url'}, {'offset': 281, 'length': 11, 'type': 'url'}, {'offset': 849, 'length': 13, 'type': 'bot_command'}, {'offset': 1887, 'length': 6, 'type': 'url'}, {'offset': 2027, 'length': 6, 'type': 'url'}, {'offset': 2066, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:08:26,199 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:08:26,200 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add a diagnostic /fetch_source command to verify Pump.fun ingestion and show the source column with a green tag.

PATCH
=====

1) alerts/telegram.py — add a debug command to fetch Pump.fun directly (no rules), and format with a source column.

# --- BEGIN PATCH: alerts/telegram.py ---
# Put near other imports:
from data_fetcher import fetch_candidates_from_pumpfun

# Add this helper where other sync handlers live:
async def cmd_fetch_source_sync(update, context):
    try:
        text = update.message.text.strip()
        parts = text.split(maxsplit=1)
        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"

        items = []
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
        else:
            await update.message.reply_text("Usage: /fetch_source pumpfun")
            return "ok"

        # Basic table with source + green tag for pumpfun
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]
        for t in items[:20]:
            src = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else src
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")
            lines.append(f"{src_label} | {t.get('symbol','?')} | {t.get('name','?')[:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'}")

        block = "```\n" + "\n".join(lines) + "\n```"
        await update.message.reply_text(block, parse_mode="Markdown")
        return "ok"
    except Exception as e:
        logging.exception("fetch_source error")
        await update.message.reply_text(f"❌ fetch_source failed: {e}")
        return "ok"
# --- END PATCH ---

2) app.py (Flask webhook router) — route the new command (place with the other admin routes, BEFORE the unknown fallback).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/fetch_source"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_fetch_source_sync
            _reply(await cmd_fetch_source_sync(update, None)); return "ok"
# --- END PATCH ---'
2025-08-10 12:08:26,200 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add a diagnostic /fetch_source command to verify Pump.fun ingestion and show the source column with a green tag.

PATCH
=====

1) alerts/telegram.py — add a debug command to fetch Pump.fun directly (no rules), and format with a source column.

# --- BEGIN PATCH: alerts/telegram.py ---
# Put near other imports:
from data_fetcher import fetch_candidates_from_pumpfun

# Add this helper where other sync handlers live:
async def cmd_fetch_source_sync(update, context):
    try:
        text = update.message.text.strip()
        parts = text.split(maxsplit=1)
        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"

        items = []
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
        else:
            await update.message.reply_text("Usage: /fetch_source pumpfun")
            return "ok"

        # Basic table with source + green tag for pumpfun
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]
        for t in items[:20]:
            src = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else src
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")
            lines.append(f"{src_label} | {t.get('symbol','?')} | {t.get('name','?')[:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'}")

        block = "```\n" + "\n".join(lines) + "\n```"
        await update.message.reply_text(block, parse_mode="Markdown")
        return "ok"
    except Exception as e:
        logging.exception("fetch_source error")
        await update.message.reply_text(f"❌ fetch_source failed: {e}")
        return "ok"
# --- END PATCH ---

2) app.py (Flask webhook router) — route the new command (place with the other admin routes, BEFORE the unknown fallback).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/fetch_source"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_fetch_source_sync
            _reply(await cmd_fetch_source_sync(update, None)); return "ok"
# --- END PATCH ---
2025-08-10 12:08:26,200 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 12:08:33,207 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 12:08:33,629 [INFO] app: [WEBHOOK] Command '/assistant Add a diagnostic /fetch_source command to verify Pump.fun ingestion and show the source column with a green tag.

PATCH
=====

1) alerts/telegram.py — add a debug command to fetch Pump.fun directly (no rules), and format with a source column.

# --- BEGIN PATCH: alerts/telegram.py ---
# Put near other imports:
from data_fetcher import fetch_candidates_from_pumpfun

# Add this helper where other sync handlers live:
async def cmd_fetch_source_sync(update, context):
    try:
        text = update.message.text.strip()
        parts = text.split(maxsplit=1)
        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"

        items = []
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
        else:
            await update.message.reply_text("Usage: /fetch_source pumpfun")
            return "ok"

        # Basic table with source + green tag for pumpfun
        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]
        for t in items[:20]:
            src = t.get("source", "?")
            src_label = "🟢 pumpfun" if src == "pumpfun" else src
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")
            lines.append(f"{src_label} | {t.get('symbol','?')} | {t.get('name','?')[:20]} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'}")

        block = "```\n" + "\n".join(lines) + "\n```"
        await update.message.reply_text(block, parse_mode="Markdown")
        return "ok"
    except Exception as e:
        logging.exception("fetch_source error")
        await update.message.reply_text(f"❌ fetch_source failed: {e}")
        return "ok"
# --- END PATCH ---

2) app.py (Flask webhook router) — route the new command (place with the other admin routes, BEFORE the unknown fallback).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/fetch_source"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_fetch_source_sync
            _reply(await cmd_fetch_source_sync(update, None)); return "ok"
# --- END PATCH ---' processed, response sent: 200
2025-08-10 12:08:40,648 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:08:40,648 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121237, 'message': {'message_id': 4199, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827720, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:08:40,648 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:08:40,648 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 12:08:40,648 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:08:40,649 [INFO] app: [WEBHOOK] Unknown admin command: /fetch_source pumpfun
2025-08-10 12:09:05,204 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:09:05,204 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:09:05,204 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:09:05,207 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:09:05,984 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:09:19,431 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:09:19,432 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121238, 'message': {'message_id': 4200, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827759, 'text': '/fetch_source', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:09:19,432 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:09:19,432 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source'
2025-08-10 12:09:19,432 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source
2025-08-10 12:09:19,432 [INFO] app: [WEBHOOK] Unknown admin command: /fetch_source
2025-08-10 12:09:37,529 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:09:37,529 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121239, 'message': {'message_id': 4201, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754827777, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:09:37,530 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:09:37,530 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 12:09:37,530 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:09:37,530 [INFO] app: [WEBHOOK] Unknown admin command: /fetch_source pumpfun
2025-08-10 12:16:36,701 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:16:36,701 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:16:36,701 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:16:36,711 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:16:37,952 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:16:37,957 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:16:37,958 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 12:16:37,958 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:16:37,958 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 12:16:37,958 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:16:37,958 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:16:37,974 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:16:38,100 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:16:38,184 [ERROR] root: [FETCH] Pump.fun API error: 530 Server Error:  for url: https://frontend-api.pump.fun/coins?offset=0&limit=50&sort=created_timestamp&order=DESC
2025-08-10 12:16:39,595 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:16:39,595 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 12:16:39,595 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:16:39,595 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 12:16:39,595 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:16:39,595 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:16:39,596 [ERROR] app: Webhook error: 'MockMessage' object is not subscriptable
2025-08-10 12:16:51,455 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:16:51,455 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:16:51,455 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:16:51,458 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:16:52,203 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:17:09,410 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:17:09,410 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:17:09,411 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:17:09,414 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:17:10,091 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:17:10,516 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:17:10,517 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 12:17:10,518 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:17:10,518 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 12:17:10,518 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:17:10,518 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:17:10,519 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:17:10,658 [ERROR] root: [FETCH] Pump.fun API error: 530 Server Error:  for url: https://frontend-api.pump.fun/coins?offset=0&limit=50&sort=created_timestamp&order=DESC
2025-08-10 12:17:27,468 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:17:27,611 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:17:41,423 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:17:41,424 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121240, 'message': {'message_id': 4203, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754828200, 'text': '/assistant Install fetch_source (Pump.fun direct) and force source column + green tag in /fetch_now.', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 33, 'length': 8, 'type': 'url'}, {'offset': 89, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 12:17:41,424 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:17:41,424 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Install fetch_source (Pump.fun direct) and force source column + green tag in /fetch_now.'
2025-08-10 12:17:41,424 [INFO] app: [WEBHOOK] Admin command detected: /assistant Install fetch_source (Pump.fun direct) and force source column + green tag in /fetch_now.
2025-08-10 12:17:41,424 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 12:17:50,175 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 12:17:50,578 [INFO] app: [WEBHOOK] Command '/assistant Install fetch_source (Pump.fun direct) and force source column + green tag in /fetch_now.' processed, response sent: 200
2025-08-10 12:18:34,553 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:18:34,553 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121241, 'message': {'message_id': 4206, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754828314, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:18:34,553 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:18:34,553 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 12:18:34,553 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:18:34,554 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:18:34,627 [ERROR] root: [FETCH] Pump.fun API error: 530 Server Error:  for url: https://frontend-api.pump.fun/coins?offset=0&limit=50&sort=created_timestamp&order=DESC
2025-08-10 12:28:05,523 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:05,523 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:05,523 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:28:05,537 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:28:07,049 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:28:18,127 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:28:18,127 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 12:28:18,128 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:28:18,128 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 12:28:18,128 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:28:18,128 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:28:18,138 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:28:18,333 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:28:18,417 [ERROR] root: [FETCH] Pump.fun API error: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?offset=0&limit=50&sort=created_timestamp&order=DESC
2025-08-10 12:28:27,493 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:27,494 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:27,494 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:28:27,498 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:28:28,791 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:28:54,829 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:54,831 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:28:54,832 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:28:54,835 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:28:55,830 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:29:52,179 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:29:52,180 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 12:29:52,181 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:29:52,182 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 12:29:52,183 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:29:52,183 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:29:52,185 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:29:52,301 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:29:52,371 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 12:29:52,371 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:30:41,962 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:30:41,962 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:30:41,962 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:30:41,966 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:30:43,152 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:31:55,712 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:31:55,713 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:31:55,713 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:31:55,716 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:31:56,450 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:32:10,767 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:32:10,768 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 12:32:10,769 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:32:10,770 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 12:32:10,770 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:32:10,770 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:32:10,784 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:32:10,862 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:32:10,929 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 12:32:10,930 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:32:11,010 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 12:32:11,011 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 12:33:44,653 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:33:44,654 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:33:44,654 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:33:44,659 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:33:45,885 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:34:30,055 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:34:30,056 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 12:34:30,056 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:34:30,056 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 12:34:30,056 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:34:30,056 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:34:30,068 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:34:30,215 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 12:34:30,216 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:35:15,778 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:35:15,779 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:35:15,779 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:35:15,782 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:35:17,254 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:35:25,475 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:35:25,477 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 12:35:25,477 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:35:25,477 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 12:35:25,477 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:35:25,477 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:35:25,496 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:35:25,595 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:35:35,687 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 12:35:35,688 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:35:35,761 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 12:35:35,762 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 12:36:27,033 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 12:36:27,033 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 12:36:27,034 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:36:27,034 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 12:36:27,034 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:36:27,034 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:36:27,102 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 12:36:27,102 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:37:01,639 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:37:01,639 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 12:37:01,640 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 12:37:01,643 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 12:37:02,615 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 12:51:07,656 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:51:07,656 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121242, 'message': {'message_id': 4214, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830267, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:51:07,656 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:51:07,657 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 12:51:07,657 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:51:07,657 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:51:07,658 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 12:51:07,843 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 12:51:07,844 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:51:24,002 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:51:24,003 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121243, 'message': {'message_id': 4216, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830283, 'text': '/rules_reload', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:51:24,003 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:51:24,003 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/rules_reload'
2025-08-10 12:51:24,003 [INFO] app: [WEBHOOK] Admin command detected: /rules_reload
2025-08-10 12:51:24,003 [INFO] app: [WEBHOOK] Routing /rules_reload
2025-08-10 12:51:24,020 [INFO] root: [RULES] Loaded (v1)
2025-08-10 12:51:33,555 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:51:33,555 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121244, 'message': {'message_id': 4218, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830293, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 12:51:33,555 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:51:33,555 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 12:51:33,556 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 12:51:33,556 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 12:51:33,709 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 12:51:33,710 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:51:33,791 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 12:51:33,792 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 12:51:43,735 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:51:43,737 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121245, 'message': {'message_id': 4220, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830303, 'text': '/a_logs_tail 120 level=warn', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 12:51:43,738 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:51:43,739 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=warn'
2025-08-10 12:51:43,740 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=warn
2025-08-10 12:51:44,155 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=warn' processed, response sent: 200
2025-08-10 12:56:55,313 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:56:55,313 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121246, 'message': {'message_id': 4222, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830614, 'text': '/assistant Make live sources robust: add retries/backoff, Dexscreener search fallback, and /fetch_source dexscreener.\n\nPATCH\n=====\n\n1) data_fetcher.py — add a retrying JSON helper and harden both sources.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport time\nimport httpx\n\n# Retry-aware JSON fetch (wrapper around httpx)\ndef _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):\n    last_exc = None\n    for attempt in range(retries):\n        try:\n            r = httpx.get(url, params=params, headers=headers, timeout=timeout)\n            # Retry on common transient cases\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError("transient", request=r.request, response=r)\n            r.raise_for_status()\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            time.sleep(backoff * (attempt + 1))\n    logging.warning("JSON fetch failed for %s: %s", url, last_exc)\n    return None\n\n# Pump.fun live endpoints\nPUMPFUN_ENDPOINTS = [\n    "https://frontend-api.pump.fun/coins/created",\n]\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": limit, "offset": offset}\n            js = _get_json_retry(base, params=params)\n            if not js:\n                continue\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            items = []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000: ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    logging.error("[FETCH] All Pump.fun endpoints failed")\n    return []\n\n# Dexscreener fallback using search (broad, but works without pair id)\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 91, 'length': 13, 'type': 'bot_command'}, {'offset': 1000, 'length': 8, 'type': 'url'}, {'offset': 1051, 'length': 43, 'type': 'url'}, {'offset': 2888, 'length': 8, 'type': 'url'}, {'offset': 2971, 'length': 8, 'type': 'url'}, {'offset': 3107, 'length': 45, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 12:56:55,313 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:56:55,313 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Make live sources robust: add retries/backoff, Dexscreener search fallback, and /fetch_source dexscreener.

PATCH
=====

1) data_fetcher.py — add a retrying JSON helper and harden both sources.

# --- BEGIN PATCH: data_fetcher.py ---
import time
import httpx

# Retry-aware JSON fetch (wrapper around httpx)
def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=headers, timeout=timeout)
            # Retry on common transient cases
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep(backoff * (attempt + 1))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

# Pump.fun live endpoints
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json_retry(base, params=params)
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []

# Dexscreener fallback using search (broad, but works without pair id)
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"'
2025-08-10 12:56:55,313 [INFO] app: [WEBHOOK] Admin command detected: /assistant Make live sources robust: add retries/backoff, Dexscreener search fallback, and /fetch_source dexscreener.

PATCH
=====

1) data_fetcher.py — add a retrying JSON helper and harden both sources.

# --- BEGIN PATCH: data_fetcher.py ---
import time
import httpx

# Retry-aware JSON fetch (wrapper around httpx)
def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=headers, timeout=timeout)
            # Retry on common transient cases
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep(backoff * (attempt + 1))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

# Pump.fun live endpoints
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json_retry(base, params=params)
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []

# Dexscreener fallback using search (broad, but works without pair id)
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"
2025-08-10 12:56:55,313 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 12:57:04,697 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 12:57:05,090 [INFO] app: [WEBHOOK] Command '/assistant Make live sources robust: add retries/backoff, Dexscreener search fallback, and /fetch_source dexscreener.

PATCH
=====

1) data_fetcher.py — add a retrying JSON helper and harden both sources.

# --- BEGIN PATCH: data_fetcher.py ---
import time
import httpx

# Retry-aware JSON fetch (wrapper around httpx)
def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=headers, timeout=timeout)
            # Retry on common transient cases
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep(backoff * (attempt + 1))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

# Pump.fun live endpoints
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": limit, "offset": offset}
            js = _get_json_retry(base, params=params)
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []

# Dexscreener fallback using search (broad, but works without pair id)
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"' processed, response sent: 200
2025-08-10 12:57:05,207 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:57:05,207 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121247, 'message': {'message_id': 4223, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830614, 'text': 'def _fetch_pairs_from_dexscreener_search(query="solana", limit=200):\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            # Map to our schema\n            base = p.get("baseToken", {}) or {}\n            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            token_name   = base.get("name") or token_symbol\n            mint = base.get("address") or p.get("pairAddress")\n            liq_usd = p.get("liquidity", {}).get("usd")\n            mcap_usd = p.get("fdv")  # DS often gives FDV instead of mcap\n            # DS doesn’t give age; leave None\n            out.append({\n                "source": "dexscreener",\n                "symbol": token_symbol,\n                "name": token_name,\n                "mint": mint,\n                "holders": None,  # not available here\n                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,\n                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    return out\n\n# Merge + rank (Pump.fun first)\ndef fetch_and_rank(rules):\n    all_items = []\n    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))\n    except Exception as e: logging.warning("Pump.fun source failed: %s", e)\n\n    try: all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))\n    except Exception as e: logging.error("[FETCH] DexScreener API error: %s", e)\n\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    filtered = _dedupe_keep_best(filtered)\n    def _src_priority(src): return 0 if src == "pumpfun" else 1\n    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))\n    return filtered\n# --- END PATCH ---', 'entities': [{'offset': 1334, 'length': 8, 'type': 'url'}, {'offset': 1518, 'length': 8, 'type': 'url'}]}}
2025-08-10 12:57:05,207 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:57:05,209 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def _fetch_pairs_from_dexscreener_search(query="solana", limit=200):
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            # Map to our schema
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = p.get("liquidity", {}).get("usd")
            mcap_usd = p.get("fdv")  # DS often gives FDV instead of mcap
            # DS doesn’t give age; leave None
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,  # not available here
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    return out

# Merge + rank (Pump.fun first)
def fetch_and_rank(rules):
    all_items = []
    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e: logging.warning("Pump.fun source failed: %s", e)

    try: all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
    except Exception as e: logging.error("[FETCH] DexScreener API error: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)
    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    return filtered
# --- END PATCH ---'
2025-08-10 12:57:05,334 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:57:05,335 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121248, 'message': {'message_id': 4224, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830619, 'text': '2) alerts/telegram.py — support /fetch_source dexscreener alongside pumpfun.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\nfrom data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search\n\nasync def cmd_fetch_source_sync(update, context):\n    """\n    Debug: /fetch_source pumpfun|dexscreener\n    Bypasses rules to verify live intake & shows source column + green tag for Pump.fun.\n    """\n    try:\n        text = update.message.text.strip()\n        parts = text.split(maxsplit=1)\n        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"\n\n        if wanted in ("pumpfun", "pf", "pump"):\n            items = fetch_candidates_from_pumpfun(limit=50, offset=0)\n        elif wanted in ("dex", "dexscreener", "ds"):\n            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=50)\n        else:\n            await update.message.reply_text("Usage: /fetch_source pumpfun|dexscreener")\n            return "ok"\n\n        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]\n        for t in items[:20]:\n            src  = t.get("source", "?")\n            tag  = "🟢 pumpfun" if src == "pumpfun" else src\n            sym  = t.get("symbol", "?")\n            name = (t.get("name") or sym)[:20]\n            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")\n            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")\n            lines.append(f"{tag} | {sym} | {name} | {holders} | {mcap if mcap is not None else \'?\'} | {liq if liq is not None else \'?\'} | {age if age is not None else \'?\'}")\n\n        block = "```\\n" + "\\n".join(lines) + "\\n```"\n        await update.message.reply_text(block, parse_mode="Markdown")\n        return "ok"\n    except Exception as e:\n        logging.exception("fetch_source error")\n        await update.message.reply_text(f"❌ fetch_source failed: {e}")\n        return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 10, 'length': 11, 'type': 'url'}, {'offset': 32, 'length': 25, 'type': 'code'}, {'offset': 104, 'length': 11, 'type': 'url'}, {'offset': 283, 'length': 13, 'type': 'bot_command'}, {'offset': 396, 'length': 8, 'type': 'url'}, {'offset': 901, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:57:05,335 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:57:05,335 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '2) alerts/telegram.py — support /fetch_source dexscreener alongside pumpfun.

# --- BEGIN PATCH: alerts/telegram.py ---
from data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search

async def cmd_fetch_source_sync(update, context):
    """
    Debug: /fetch_source pumpfun|dexscreener
    Bypasses rules to verify live intake & shows source column + green tag for Pump.fun.
    """
    try:
        text = update.message.text.strip()
        parts = text.split(maxsplit=1)
        wanted = parts[1].strip().lower() if len(parts) > 1 else "pumpfun"

        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
        elif wanted in ("dex", "dexscreener", "ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=50)
        else:
            await update.message.reply_text("Usage: /fetch_source pumpfun|dexscreener")
            return "ok"

        lines = ["source | symbol | name | holders | mcap$ | liq$ | age_min"]
        for t in items[:20]:
            src  = t.get("source", "?")
            tag  = "🟢 pumpfun" if src == "pumpfun" else src
            sym  = t.get("symbol", "?")
            name = (t.get("name") or sym)[:20]
            holders = "?" if (t.get("holders", -1) == -1) else t.get("holders")
            mcap = t.get("mcap_usd"); liq = t.get("liquidity_usd"); age = t.get("age_min")
            lines.append(f"{tag} | {sym} | {name} | {holders} | {mcap if mcap is not None else '?'} | {liq if liq is not None else '?'} | {age if age is not None else '?'}")

        block = "```\n" + "\n".join(lines) + "\n```"
        await update.message.reply_text(block, parse_mode="Markdown")
        return "ok"
    except Exception as e:
        logging.exception("fetch_source error")
        await update.message.reply_text(f"❌ fetch_source failed: {e}")
        return "ok"
# --- END PATCH ---'
2025-08-10 12:57:05,548 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:57:05,548 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121249, 'message': {'message_id': 4226, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830625, 'text': '3) app.py — ensure the Flask router has a branch for /fetch_source (if not already present).\n\n# --- BEGIN PATCH: app.py ---\n        if text.startswith("/fetch_source"):\n            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n                _reply("Not authorized."); return "ok"\n            from alerts.telegram import cmd_fetch_source_sync\n            _reply(await cmd_fetch_source_sync(update, None)); return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 3, 'length': 6, 'type': 'url'}, {'offset': 53, 'length': 13, 'type': 'bot_command'}, {'offset': 113, 'length': 6, 'type': 'url'}, {'offset': 152, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:57:05,549 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:57:05,549 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '3) app.py — ensure the Flask router has a branch for /fetch_source (if not already present).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/fetch_source"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_fetch_source_sync
            _reply(await cmd_fetch_source_sync(update, None)); return "ok"
# --- END PATCH ---'
2025-08-10 12:57:42,510 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:57:42,511 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121250, 'message': {'message_id': 4227, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830662, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 12:57:42,511 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:57:42,511 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 12:57:42,511 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 12:57:42,511 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 12:57:42,680 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 12:57:42,681 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 12:57:56,527 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 12:57:56,529 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121251, 'message': {'message_id': 4229, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830676, 'text': '/a_logs_tail 150 level=warn', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 12:57:56,530 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 12:57:56,531 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=warn'
2025-08-10 12:57:56,533 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=warn
2025-08-10 12:57:56,936 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=warn' processed, response sent: 200
2025-08-10 13:01:28,308 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:01:28,309 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121252, 'message': {'message_id': 4231, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830887, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:01:28,311 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:01:28,312 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:01:28,313 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:01:28,313 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:02:00,544 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:02:00,544 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121253, 'message': {'message_id': 4232, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830920, 'text': '/assistant Harden Pump.fun: add UA + jitter + clearer empty-state.\n\nPATCH\n=====\n\n1) data_fetcher.py — improve _get_json_retry and pumpfun fetch.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport random\n\ndef _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):\n    ua = {\n        "User-Agent": headers.get("User-Agent") if headers else None\n    }\n    if ua["User-Agent"] is None:\n        ua["User-Agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36"\n    hdrs = {}\n    if headers:\n        hdrs.update(headers)\n    hdrs.update({k:v for k,v in ua.items() if v})\n\n    last_exc = None\n    for attempt in range(retries):\n        try:\n            r = httpx.get(url, params=params, headers=hdrs, timeout=timeout)\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError("transient", request=r.request, response=r)\n            r.raise_for_status()\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            # jittered backoff to play nicer with CF/edges\n            time.sleep((backoff * (attempt + 1)) + random.uniform(0, 0.6))\n    logging.warning("JSON fetch failed for %s: %s", url, last_exc)\n    return None\n\ndef fetch_candidates_from_pumpfun(limit=200, offset=0):\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            params = {"limit": min(limit, 200), "offset": max(0, offset)}\n            js = _get_json_retry(base, params=params, headers={})\n            if not js:\n                continue\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            items = []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint:\n                    continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000: ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n                items.append({\n                    "source": "pumpfun",\n                    "symbol": sym or "?",\n                    "name": name or sym or "Pump",\n                    "mint": mint,\n                    "holders": c.get("holders") or None,\n                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,\n                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,\n                    "age_min": age_min,\n                    "renounced_mint_auth": None,\n                    "renounced_freeze_auth": None,\n                })\n            if items:\n                return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    logging.error("[FETCH] All Pump.fun endpoints failed")\n    return []\n# --- END PATCH ---\n\n2) alerts/telegram.py — show a clear message if Pump.fun is temporarily unavailable.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\nasync def cmd_fetch_source_sync(update, context):\n    ...\n        if wanted in ("pumpfun", "pf", "pump"):\n            items = fetch_candidates_from_pumpfun(limit=50, offset=0)\n            if not items:\n                await update.message.reply_text(\n                    "Pump.fun is temporarily unavailable (edge 5xx). Try again in ~30–60s.",\n                )\n                return "ok"\n    ...\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 18, 'length': 8, 'type': 'url'}, {'offset': 3088, 'length': 8, 'type': 'url'}, {'offset': 3171, 'length': 8, 'type': 'url'}, {'offset': 3244, 'length': 11, 'type': 'url'}, {'offset': 3282, 'length': 8, 'type': 'url'}, {'offset': 3346, 'length': 11, 'type': 'url'}, {'offset': 3634, 'length': 8, 'type': 'url'}]}}
2025-08-10 13:02:00,545 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:02:00,545 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Harden Pump.fun: add UA + jitter + clearer empty-state.

PATCH
=====

1) data_fetcher.py — improve _get_json_retry and pumpfun fetch.

# --- BEGIN PATCH: data_fetcher.py ---
import random

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    ua = {
        "User-Agent": headers.get("User-Agent") if headers else None
    }
    if ua["User-Agent"] is None:
        ua["User-Agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36"
    hdrs = {}
    if headers:
        hdrs.update(headers)
    hdrs.update({k:v for k,v in ua.items() if v})

    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=hdrs, timeout=timeout)
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            # jittered backoff to play nicer with CF/edges
            time.sleep((backoff * (attempt + 1)) + random.uniform(0, 0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": min(limit, 200), "offset": max(0, offset)}
            js = _get_json_retry(base, params=params, headers={})
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []
# --- END PATCH ---

2) alerts/telegram.py — show a clear message if Pump.fun is temporarily unavailable.

# --- BEGIN PATCH: alerts/telegram.py ---
async def cmd_fetch_source_sync(update, context):
    ...
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
            if not items:
                await update.message.reply_text(
                    "Pump.fun is temporarily unavailable (edge 5xx). Try again in ~30–60s.",
                )
                return "ok"
    ...
# --- END PATCH ---'
2025-08-10 13:02:00,545 [INFO] app: [WEBHOOK] Admin command detected: /assistant Harden Pump.fun: add UA + jitter + clearer empty-state.

PATCH
=====

1) data_fetcher.py — improve _get_json_retry and pumpfun fetch.

# --- BEGIN PATCH: data_fetcher.py ---
import random

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    ua = {
        "User-Agent": headers.get("User-Agent") if headers else None
    }
    if ua["User-Agent"] is None:
        ua["User-Agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36"
    hdrs = {}
    if headers:
        hdrs.update(headers)
    hdrs.update({k:v for k,v in ua.items() if v})

    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=hdrs, timeout=timeout)
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            # jittered backoff to play nicer with CF/edges
            time.sleep((backoff * (attempt + 1)) + random.uniform(0, 0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": min(limit, 200), "offset": max(0, offset)}
            js = _get_json_retry(base, params=params, headers={})
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []
# --- END PATCH ---

2) alerts/telegram.py — show a clear message if Pump.fun is temporarily unavailable.

# --- BEGIN PATCH: alerts/telegram.py ---
async def cmd_fetch_source_sync(update, context):
    ...
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
            if not items:
                await update.message.reply_text(
                    "Pump.fun is temporarily unavailable (edge 5xx). Try again in ~30–60s.",
                )
                return "ok"
    ...
# --- END PATCH ---
2025-08-10 13:02:00,545 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:02:05,621 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:02:05,997 [INFO] app: [WEBHOOK] Command '/assistant Harden Pump.fun: add UA + jitter + clearer empty-state.

PATCH
=====

1) data_fetcher.py — improve _get_json_retry and pumpfun fetch.

# --- BEGIN PATCH: data_fetcher.py ---
import random

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    ua = {
        "User-Agent": headers.get("User-Agent") if headers else None
    }
    if ua["User-Agent"] is None:
        ua["User-Agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36"
    hdrs = {}
    if headers:
        hdrs.update(headers)
    hdrs.update({k:v for k,v in ua.items() if v})

    last_exc = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, params=params, headers=hdrs, timeout=timeout)
            if r.status_code in (429, 500, 502, 503, 504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            # jittered backoff to play nicer with CF/edges
            time.sleep((backoff * (attempt + 1)) + random.uniform(0, 0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            params = {"limit": min(limit, 200), "offset": max(0, offset)}
            js = _get_json_retry(base, params=params, headers={})
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint:
                    continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source": "pumpfun",
                    "symbol": sym or "?",
                    "name": name or sym or "Pump",
                    "mint": mint,
                    "holders": c.get("holders") or None,
                    "mcap_usd": mcap if isinstance(mcap, (int, float)) else None,
                    "liquidity_usd": liq if isinstance(liq, (int, float)) else None,
                    "age_min": age_min,
                    "renounced_mint_auth": None,
                    "renounced_freeze_auth": None,
                })
            if items:
                return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []
# --- END PATCH ---

2) alerts/telegram.py — show a clear message if Pump.fun is temporarily unavailable.

# --- BEGIN PATCH: alerts/telegram.py ---
async def cmd_fetch_source_sync(update, context):
    ...
        if wanted in ("pumpfun", "pf", "pump"):
            items = fetch_candidates_from_pumpfun(limit=50, offset=0)
            if not items:
                await update.message.reply_text(
                    "Pump.fun is temporarily unavailable (edge 5xx). Try again in ~30–60s.",
                )
                return "ok"
    ...
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:02:15,855 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:02:15,856 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:02:15,856 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:02:15,863 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:02:16,942 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:02:30,594 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:02:30,595 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121254, 'message': {'message_id': 4234, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830950, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:02:30,596 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:02:30,597 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 13:02:30,598 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 13:02:30,599 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:02:30,601 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:02:30,795 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 13:02:30,796 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:02:41,708 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:02:41,709 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121255, 'message': {'message_id': 4236, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830961, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:02:41,709 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:02:41,709 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:02:41,709 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:02:41,709 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:02:52,163 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:02:52,164 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121256, 'message': {'message_id': 4237, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754830972, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 13:02:52,164 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:02:52,164 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 13:02:52,164 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 13:02:52,164 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 13:02:52,191 [INFO] root: [RULES] Loaded (v1)
2025-08-10 13:02:52,292 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 13:02:52,293 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:02:52,405 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 13:02:52,406 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 13:03:28,977 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:03:28,978 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121257, 'message': {'message_id': 4239, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831008, 'text': '/a_logs_tail', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:03:28,978 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:03:28,978 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail'
2025-08-10 13:03:28,978 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail
2025-08-10 13:03:29,370 [INFO] app: [WEBHOOK] Command '/a_logs_tail' processed, response sent: 200
2025-08-10 13:06:31,201 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:06:31,201 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121258, 'message': {'message_id': 4241, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831190, 'text': '/assistant Force Dexscreener search endpoint + clear logs.\n\nPATCH\n=====\n\n1) data_fetcher.py — ensure we use the search endpoint (not pairs) and log it.\n\n# --- BEGIN PATCH: data_fetcher.py ---\n# Replace any old DEXSCREENER_* constants and fetching that used /latest/dex/pairs/...\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"\n\ndef _fetch_pairs_from_dexscreener_search(query="solana", limit=200):\n    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        logging.warning("[FETCH] Dexscreener search returned no JSON")\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            base = p.get("baseToken", {}) or {}\n            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            token_name   = base.get("name") or token_symbol\n            mint = base.get("address") or p.get("pairAddress")\n            liq_usd = (p.get("liquidity") or {}).get("usd")\n            mcap_usd = p.get("fdv")\n            out.append({\n                "source": "dexscreener",\n                "symbol": token_symbol,\n                "name": token_name,\n                "mint": mint,\n                "holders": None,\n                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,\n                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))\n    return out\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 301, 'length': 45, 'type': 'url'}, {'offset': 422, 'length': 12, 'type': 'url'}, {'offset': 1668, 'length': 12, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:06:31,202 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:06:31,202 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Force Dexscreener search endpoint + clear logs.

PATCH
=====

1) data_fetcher.py — ensure we use the search endpoint (not pairs) and log it.

# --- BEGIN PATCH: data_fetcher.py ---
# Replace any old DEXSCREENER_* constants and fetching that used /latest/dex/pairs/...
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=200):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---'
2025-08-10 13:06:31,202 [INFO] app: [WEBHOOK] Admin command detected: /assistant Force Dexscreener search endpoint + clear logs.

PATCH
=====

1) data_fetcher.py — ensure we use the search endpoint (not pairs) and log it.

# --- BEGIN PATCH: data_fetcher.py ---
# Replace any old DEXSCREENER_* constants and fetching that used /latest/dex/pairs/...
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=200):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---
2025-08-10 13:06:31,202 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:06:35,847 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:06:36,246 [INFO] app: [WEBHOOK] Command '/assistant Force Dexscreener search endpoint + clear logs.

PATCH
=====

1) data_fetcher.py — ensure we use the search endpoint (not pairs) and log it.

# --- BEGIN PATCH: data_fetcher.py ---
# Replace any old DEXSCREENER_* constants and fetching that used /latest/dex/pairs/...
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=200):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:06:48,353 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:06:48,353 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:06:48,353 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:06:48,358 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:06:49,391 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:07:03,648 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:07:03,648 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121259, 'message': {'message_id': 4243, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831223, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:07:03,649 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:07:03,649 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:07:03,649 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:07:03,649 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:07:03,650 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:07:14,343 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:07:14,343 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121260, 'message': {'message_id': 4244, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831234, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:07:14,343 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:07:14,344 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 13:07:14,344 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 13:07:14,344 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:07:14,459 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 13:07:14,460 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:07:23,257 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:07:23,257 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121261, 'message': {'message_id': 4246, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831243, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 13:07:23,258 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:07:23,258 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 13:07:23,258 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 13:07:23,258 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 13:07:23,275 [INFO] root: [RULES] Loaded (v1)
2025-08-10 13:07:23,423 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 13:07:23,423 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:07:23,536 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 13:07:23,536 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 13:07:39,686 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:07:39,687 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121262, 'message': {'message_id': 4248, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831259, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:07:39,687 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:07:39,687 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 13:07:39,688 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 13:07:40,123 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 13:10:52,642 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:10:52,643 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121263, 'message': {'message_id': 4250, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831452, 'text': '/assistant Force Dexscreener search + wire fetch_and_rank to it.\n\nPATCH\n=====\n\n# 1) data_fetcher.py — replace pairs usage and ensure fetch_and_rank calls search.\n\n# --- BEGIN PATCH: data_fetcher.py ---\n# Remove/ignore any old DEXSCREENER_* pairs constants and functions.\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"\n\ndef _fetch_pairs_from_dexscreener_search(query="solana", limit=300):\n    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        logging.warning("[FETCH] Dexscreener search returned no JSON")\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            base = p.get("baseToken", {}) or {}\n            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            token_name   = base.get("name") or token_symbol\n            mint = base.get("address") or p.get("pairAddress")\n            liq_usd = (p.get("liquidity") or {}).get("usd")\n            mcap_usd = p.get("fdv")\n            out.append({\n                "source": "dexscreener",\n                "symbol": token_symbol,\n                "name": token_name,\n                "mint": mint,\n                "holders": None,\n                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,\n                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))\n    return out\n\n# Ensure fetch_and_rank uses the search helper (not any old pairs-based helper).\ndef fetch_and_rank(rules):\n    all_items = []\n    try:\n        all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))\n    except Exception as e:\n        logging.warning("Pump.fun source failed: %s", e)\n\n    try:\n        all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))\n    except Exception as e:\n        logging.error("[FETCH] Dexscreener search error: %s", e)\n\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n\n    filtered = _dedupe_keep_best(filtered)\n\n    def _src_priority(src): return 0 if src == "pumpfun" else 1\n    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))\n    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))\n    return filtered\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 293, 'length': 45, 'type': 'url'}, {'offset': 414, 'length': 12, 'type': 'url'}, {'offset': 1660, 'length': 12, 'type': 'url'}, {'offset': 2011, 'length': 8, 'type': 'url'}, {'offset': 2887, 'length': 12, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:10:52,643 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:10:52,643 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Force Dexscreener search + wire fetch_and_rank to it.

PATCH
=====

# 1) data_fetcher.py — replace pairs usage and ensure fetch_and_rank calls search.

# --- BEGIN PATCH: data_fetcher.py ---
# Remove/ignore any old DEXSCREENER_* pairs constants and functions.
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out

# Ensure fetch_and_rank uses the search helper (not any old pairs-based helper).
def fetch_and_rank(rules):
    all_items = []
    try:
        all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
    except Exception as e:
        logging.error("[FETCH] Dexscreener search error: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)

    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))
    return filtered
# --- END PATCH ---'
2025-08-10 13:10:52,643 [INFO] app: [WEBHOOK] Admin command detected: /assistant Force Dexscreener search + wire fetch_and_rank to it.

PATCH
=====

# 1) data_fetcher.py — replace pairs usage and ensure fetch_and_rank calls search.

# --- BEGIN PATCH: data_fetcher.py ---
# Remove/ignore any old DEXSCREENER_* pairs constants and functions.
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out

# Ensure fetch_and_rank uses the search helper (not any old pairs-based helper).
def fetch_and_rank(rules):
    all_items = []
    try:
        all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
    except Exception as e:
        logging.error("[FETCH] Dexscreener search error: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)

    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))
    return filtered
# --- END PATCH ---
2025-08-10 13:10:52,643 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:11:02,921 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:11:03,310 [INFO] app: [WEBHOOK] Command '/assistant Force Dexscreener search + wire fetch_and_rank to it.

PATCH
=====

# 1) data_fetcher.py — replace pairs usage and ensure fetch_and_rank calls search.

# --- BEGIN PATCH: data_fetcher.py ---
# Remove/ignore any old DEXSCREENER_* pairs constants and functions.
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener using search endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken", {}) or {}
            token_symbol = base.get("symbol") or p.get("baseSymbol") or "SOL"
            token_name   = base.get("name") or token_symbol
            mint = base.get("address") or p.get("pairAddress")
            liq_usd = (p.get("liquidity") or {}).get("usd")
            mcap_usd = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": token_symbol,
                "name": token_name,
                "mint": mint,
                "holders": None,
                "mcap_usd": mcap_usd if isinstance(mcap_usd, (int, float)) else None,
                "liquidity_usd": liq_usd if isinstance(liq_usd, (int, float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out

# Ensure fetch_and_rank uses the search helper (not any old pairs-based helper).
def fetch_and_rank(rules):
    all_items = []
    try:
        all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e:
        logging.warning("Pump.fun source failed: %s", e)

    try:
        all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
    except Exception as e:
        logging.error("[FETCH] Dexscreener search error: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1

    filtered = _dedupe_keep_best(filtered)

    def _src_priority(src): return 0 if src == "pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))
    return filtered
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:11:13,610 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:11:13,610 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:11:13,611 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:11:13,613 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:11:14,465 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:11:31,331 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:11:31,332 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121264, 'message': {'message_id': 4252, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831491, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:11:31,332 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:11:31,332 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:11:31,332 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:11:31,332 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:11:31,333 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:11:45,786 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:11:45,786 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121265, 'message': {'message_id': 4253, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831505, 'text': '/a_logs_tail 120 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:11:45,786 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:11:45,786 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=info'
2025-08-10 13:11:45,786 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=info
2025-08-10 13:11:46,209 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=info' processed, response sent: 200
2025-08-10 13:15:04,883 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:15:04,884 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121266, 'message': {'message_id': 4255, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831704, 'text': '/assistant Wire /fetch_source to Dexscreener SEARCH helper + add debug logs.\n\nPATCH\n=====\n\n1) alerts/telegram.py — import the correct helper and call it.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\n# At the top with other imports:\nfrom data_fetcher import (\n    fetch_candidates_from_pumpfun,\n    _fetch_pairs_from_dexscreener_search,   # <-- ensure this is imported\n)\n\n# In cmd_fetch_source_sync (or your fetch_source handler), replace the dexscreener branch with:\n        if wanted in ("dexscreener", "dex", "ds"):\n            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)\n            logging.info("[FETCH] /fetch_source dexscreener returned %d items", len(items))\n            if not items:\n                await update.message.reply_text(\n                    "Dexscreener search returned no rows (rate limit or empty). Try again in ~20s."\n                )\n                return "ok"\n            # format the table (expects a dict list with \'source\',\'symbol\',\'name\',\'holders\',\'mcap_usd\',\'liquidity_usd\',\'age_min\')\n            rows = []\n            rows.append(["source","symbol","name","holders","mcap$","liq$","age_min"])\n            for t in items[:20]:\n                rows.append([\n                    t.get("source") or "dexscreener",\n                    t.get("symbol") or "?",\n                    t.get("name") or "?",\n                    t.get("holders") if t.get("holders") is not None else "-",\n                    f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"), (int,float)) else "-",\n                    f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"), (int,float)) else "-",\n                    int(t["age_min"]) if t.get("age_min") is not None else "-",\n                ])\n            txt = _format_table(rows, title="Dexscreener (search)")\n            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)\n            return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 16, 'length': 13, 'type': 'bot_command'}, {'offset': 101, 'length': 11, 'type': 'url'}, {'offset': 181, 'length': 11, 'type': 'url'}, {'offset': 612, 'length': 12, 'type': 'url'}, {'offset': 634, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:15:04,885 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:15:04,885 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Wire /fetch_source to Dexscreener SEARCH helper + add debug logs.

PATCH
=====

1) alerts/telegram.py — import the correct helper and call it.

# --- BEGIN PATCH: alerts/telegram.py ---
# At the top with other imports:
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,   # <-- ensure this is imported
)

# In cmd_fetch_source_sync (or your fetch_source handler), replace the dexscreener branch with:
        if wanted in ("dexscreener", "dex", "ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener returned %d items", len(items))
            if not items:
                await update.message.reply_text(
                    "Dexscreener search returned no rows (rate limit or empty). Try again in ~20s."
                )
                return "ok"
            # format the table (expects a dict list with 'source','symbol','name','holders','mcap_usd','liquidity_usd','age_min')
            rows = []
            rows.append(["source","symbol","name","holders","mcap$","liq$","age_min"])
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"), (int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"), (int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---'
2025-08-10 13:15:04,886 [INFO] app: [WEBHOOK] Admin command detected: /assistant Wire /fetch_source to Dexscreener SEARCH helper + add debug logs.

PATCH
=====

1) alerts/telegram.py — import the correct helper and call it.

# --- BEGIN PATCH: alerts/telegram.py ---
# At the top with other imports:
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,   # <-- ensure this is imported
)

# In cmd_fetch_source_sync (or your fetch_source handler), replace the dexscreener branch with:
        if wanted in ("dexscreener", "dex", "ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener returned %d items", len(items))
            if not items:
                await update.message.reply_text(
                    "Dexscreener search returned no rows (rate limit or empty). Try again in ~20s."
                )
                return "ok"
            # format the table (expects a dict list with 'source','symbol','name','holders','mcap_usd','liquidity_usd','age_min')
            rows = []
            rows.append(["source","symbol","name","holders","mcap$","liq$","age_min"])
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"), (int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"), (int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---
2025-08-10 13:15:04,886 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:15:12,387 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:15:12,817 [INFO] app: [WEBHOOK] Command '/assistant Wire /fetch_source to Dexscreener SEARCH helper + add debug logs.

PATCH
=====

1) alerts/telegram.py — import the correct helper and call it.

# --- BEGIN PATCH: alerts/telegram.py ---
# At the top with other imports:
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,   # <-- ensure this is imported
)

# In cmd_fetch_source_sync (or your fetch_source handler), replace the dexscreener branch with:
        if wanted in ("dexscreener", "dex", "ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener returned %d items", len(items))
            if not items:
                await update.message.reply_text(
                    "Dexscreener search returned no rows (rate limit or empty). Try again in ~20s."
                )
                return "ok"
            # format the table (expects a dict list with 'source','symbol','name','holders','mcap_usd','liquidity_usd','age_min')
            rows = []
            rows.append(["source","symbol","name","holders","mcap$","liq$","age_min"])
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"), (int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"), (int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:15:27,876 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:15:27,881 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:15:27,882 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:15:27,886 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:15:28,660 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:15:43,690 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:15:43,690 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121267, 'message': {'message_id': 4257, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831743, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:15:43,691 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:15:43,691 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:15:43,691 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:15:43,691 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:15:43,692 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:15:57,388 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:15:57,388 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:15:57,388 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:15:57,393 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:15:58,176 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:16:19,018 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:16:19,019 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121268, 'message': {'message_id': 4258, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831778, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:16:19,019 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:16:19,019 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:16:19,019 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:16:19,019 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:16:19,020 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:16:32,326 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:16:32,327 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121269, 'message': {'message_id': 4259, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831792, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:16:32,327 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:16:32,327 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 13:16:32,327 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 13:16:32,327 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:16:32,438 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 13:16:32,439 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:16:51,342 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:16:51,342 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121270, 'message': {'message_id': 4261, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831811, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 13:16:51,343 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:16:51,343 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 13:16:51,343 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 13:16:51,343 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 13:16:51,360 [INFO] root: [RULES] Loaded (v1)
2025-08-10 13:16:51,494 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=200&offset=0
2025-08-10 13:16:51,495 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 13:16:51,622 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 13:16:51,623 [INFO] root: [FETCH] Merged and ranked 0 tokens from 0 total
2025-08-10 13:17:00,917 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:17:00,918 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121271, 'message': {'message_id': 4263, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831820, 'text': '/a_logs_tail 200 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:17:00,918 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:17:00,918 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 200 level=info'
2025-08-10 13:17:00,918 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 200 level=info
2025-08-10 13:17:01,322 [INFO] app: [WEBHOOK] Command '/a_logs_tail 200 level=info' processed, response sent: 200
2025-08-10 13:20:10,311 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:20:10,312 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:20:10,312 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:20:10,318 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:20:11,231 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:20:26,165 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:20:26,166 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121272, 'message': {'message_id': 4265, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754831995, 'text': '/assistant Switch Dexscreener to SEARCH everywhere + add proof logs.\n\nPATCH\n=====\n\n1) data_fetcher.py — create/ensure search helper.\n# --- BEGIN PATCH: data_fetcher.py ---\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"\n\ndef _fetch_pairs_from_dexscreener_search(query="solana", limit=300):\n    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        logging.warning("[FETCH] Dexscreener search returned no JSON")\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            base = p.get("baseToken") or {}\n            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            name = base.get("name") or sym\n            mint = base.get("address") or p.get("pairAddress")\n            liq  = (p.get("liquidity") or {}).get("usd")\n            fdv  = p.get("fdv")\n            out.append({\n                "source": "dexscreener",\n                "symbol": sym,\n                "name": name,\n                "mint": mint,\n                "holders": None,\n                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,\n                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))\n    return out\n# --- END PATCH ---\n\n2) alerts/telegram.py — import and use the search helper in BOTH handlers.\n/* Find your imports at the top and ensure: */\nfrom data_fetcher import (\n    fetch_candidates_from_pumpfun,\n    _fetch_pairs_from_dexscreener_search,\n    fetch_and_rank,   # if already present, keep it\n)\n\n# a) In the /fetch_source handler branch for dexscreener, REPLACE its code with:\n        if wanted in ("dexscreener","dex","ds"):\n            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)\n            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))\n            if not items:\n                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")\n                return "ok"\n            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n            for t in items[:20]:\n                rows.append([\n                    t.get("source") or "dexscreener",\n                    t.get("symbol") or "?",\n                    t.get("name") or "?",\n                    t.get("holders") if t.get("holders") is not None else "-",\n                    f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                    f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                    int(t["age_min"]) if t.get("age_min") is not None else "-",\n                ])\n            txt = _format_table(rows, title="Dexscreener (search)")\n            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)\n            return "ok"\n\n# b) In the /fetch_now path where Dexscreener rows are gathered,\n#    REPLACE any call to old pairs helper with the search helper, e.g.:\n            try:\n                all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))\n            except Exception as e:\n                logging.error("[FETCH] Dexscreener search error: %s", e)\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 194, 'length': 45, 'type': 'url'}, {'offset': 315, 'length': 12, 'type': 'url'}, {'offset': 1487, 'length': 12, 'type': 'url'}, {'offset': 1603, 'length': 11, 'type': 'url'}, {'offset': 1886, 'length': 13, 'type': 'bot_command'}, {'offset': 2100, 'length': 12, 'type': 'url'}, {'offset': 2122, 'length': 13, 'type': 'bot_command'}, {'offset': 3211, 'length': 10, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:20:26,166 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:20:26,166 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Switch Dexscreener to SEARCH everywhere + add proof logs.

PATCH
=====

1) data_fetcher.py — create/ensure search helper.
# --- BEGIN PATCH: data_fetcher.py ---
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import and use the search helper in BOTH handlers.
/* Find your imports at the top and ensure: */
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,
    fetch_and_rank,   # if already present, keep it
)

# a) In the /fetch_source handler branch for dexscreener, REPLACE its code with:
        if wanted in ("dexscreener","dex","ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"

# b) In the /fetch_now path where Dexscreener rows are gathered,
#    REPLACE any call to old pairs helper with the search helper, e.g.:
            try:
                all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---'
2025-08-10 13:20:26,166 [INFO] app: [WEBHOOK] Admin command detected: /assistant Switch Dexscreener to SEARCH everywhere + add proof logs.

PATCH
=====

1) data_fetcher.py — create/ensure search helper.
# --- BEGIN PATCH: data_fetcher.py ---
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import and use the search helper in BOTH handlers.
/* Find your imports at the top and ensure: */
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,
    fetch_and_rank,   # if already present, keep it
)

# a) In the /fetch_source handler branch for dexscreener, REPLACE its code with:
        if wanted in ("dexscreener","dex","ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"

# b) In the /fetch_now path where Dexscreener rows are gathered,
#    REPLACE any call to old pairs helper with the search helper, e.g.:
            try:
                all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---
2025-08-10 13:20:26,166 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:20:26,167 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:20:31,150 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:20:31,596 [INFO] app: [WEBHOOK] Command '/assistant Switch Dexscreener to SEARCH everywhere + add proof logs.

PATCH
=====

1) data_fetcher.py — create/ensure search helper.
# --- BEGIN PATCH: data_fetcher.py ---
DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import and use the search helper in BOTH handlers.
/* Find your imports at the top and ensure: */
from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,
    fetch_and_rank,   # if already present, keep it
)

# a) In the /fetch_source handler branch for dexscreener, REPLACE its code with:
        if wanted in ("dexscreener","dex","ds"):
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"

# b) In the /fetch_now path where Dexscreener rows are gathered,
#    REPLACE any call to old pairs helper with the search helper, e.g.:
            try:
                all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:20:47,111 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:20:47,112 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121273, 'message': {'message_id': 4267, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832047, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:20:47,112 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:20:47,112 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:20:47,112 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:20:47,112 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:21:28,159 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:21:28,160 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121274, 'message': {'message_id': 4268, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832088, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:21:28,160 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:21:28,160 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 13:21:28,160 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 13:21:28,530 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 13:25:10,838 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:25:10,839 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121275, 'message': {'message_id': 4270, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832310, 'text': '/assistant Wire Dexscreener SEARCH call with undeniable logs.\n\nPATCH\n=====\n\n1) data_fetcher.py — add load + call logs and ensure the SEARCH helper is defined.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport logging\n\nlogging.info(">>> data_fetcher loaded vDEBUG-2 <<<")\n\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"\n\ndef _fetch_pairs_from_dexscreener_search(query="solana", limit=300):\n    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        logging.warning("[FETCH] Dexscreener search returned no JSON")\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            base = p.get("baseToken") or {}\n            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            name = base.get("name") or sym\n            mint = base.get("address") or p.get("pairAddress")\n            liq  = (p.get("liquidity") or {}).get("usd")\n            fdv  = p.get("fdv")\n            out.append({\n                "source": "dexscreener",\n                "symbol": sym,\n                "name": name,\n                "mint": mint,\n                "holders": None,\n                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,\n                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))\n    return out\n# --- END PATCH ---\n\n2) alerts/telegram.py — import the helper and log branch selection in /fetch_source.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\n# at top imports:\nfrom data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search\n\n# inside cmd_fetch_source_sync, right after def line, add:\n    logging.info(">>> ENTER cmd_fetch_source_sync")\n\n# after parsing \'wanted\', add:\n        logging.info(f">>> /fetch_source wanted={wanted}")\n\n# replace the dexscreener branch with this:\n        if wanted in ("dexscreener","dex","ds"):\n            logging.info(">>> BRANCH dexscreener(search)")\n            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)\n            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))\n            if not items:\n                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")\n                return "ok"\n            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n            for t in items[:20]:\n                rows.append([\n                    t.get("source") or "dexscreener",\n                    t.get("symbol") or "?",\n                    t.get("name") or "?",\n                    t.get("holders") if t.get("holders") is not None else "-",\n                    f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                    f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                    int(t["age_min"]) if t.get("age_min") is not None else "-",\n                ])\n            txt = _format_table(rows, title="Dexscreener (search)")\n            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)\n            return "ok"\n# --- END PATCH ---\n\n3) alerts/telegram.py — ensure /fetch_now uses SEARCH (not old pairs).\n# --- BEGIN PATCH: alerts/telegram.py ---\n# In cmd_fetch_now_sync where items are gathered from sources, ensure the Dexscreener call is:\n            try:\n                more = _fetch_pairs_from_dexscreener_search(query="solana", limit=300)\n                logging.info("[FETCH] /fetch_now dexscreener(search) injected %d items", len(more))\n                items.extend(more)\n            except Exception as e:\n                logging.error("[FETCH] Dexscreener search error: %s", e)\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 215, 'length': 12, 'type': 'url'}, {'offset': 291, 'length': 45, 'type': 'url'}, {'offset': 412, 'length': 12, 'type': 'url'}, {'offset': 1584, 'length': 12, 'type': 'url'}, {'offset': 1700, 'length': 11, 'type': 'url'}, {'offset': 1760, 'length': 13, 'type': 'bot_command'}, {'offset': 1802, 'length': 11, 'type': 'url'}, {'offset': 1993, 'length': 12, 'type': 'url'}, {'offset': 2081, 'length': 12, 'type': 'url'}, {'offset': 2100, 'length': 13, 'type': 'bot_command'}, {'offset': 2238, 'length': 12, 'type': 'url'}, {'offset': 2381, 'length': 12, 'type': 'url'}, {'offset': 2403, 'length': 13, 'type': 'bot_command'}, {'offset': 3510, 'length': 11, 'type': 'url'}, {'offset': 3531, 'length': 10, 'type': 'bot_command'}, {'offset': 3597, 'length': 11, 'type': 'url'}, {'offset': 3828, 'length': 12, 'type': 'url'}, {'offset': 3850, 'length': 10, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:25:10,839 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:25:10,839 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Wire Dexscreener SEARCH call with undeniable logs.

PATCH
=====

1) data_fetcher.py — add load + call logs and ensure the SEARCH helper is defined.

# --- BEGIN PATCH: data_fetcher.py ---
import logging

logging.info(">>> data_fetcher loaded vDEBUG-2 <<<")

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import the helper and log branch selection in /fetch_source.

# --- BEGIN PATCH: alerts/telegram.py ---
# at top imports:
from data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search

# inside cmd_fetch_source_sync, right after def line, add:
    logging.info(">>> ENTER cmd_fetch_source_sync")

# after parsing 'wanted', add:
        logging.info(f">>> /fetch_source wanted={wanted}")

# replace the dexscreener branch with this:
        if wanted in ("dexscreener","dex","ds"):
            logging.info(">>> BRANCH dexscreener(search)")
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---

3) alerts/telegram.py — ensure /fetch_now uses SEARCH (not old pairs).
# --- BEGIN PATCH: alerts/telegram.py ---
# In cmd_fetch_now_sync where items are gathered from sources, ensure the Dexscreener call is:
            try:
                more = _fetch_pairs_from_dexscreener_search(query="solana", limit=300)
                logging.info("[FETCH] /fetch_now dexscreener(search) injected %d items", len(more))
                items.extend(more)
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---'
2025-08-10 13:25:10,839 [INFO] app: [WEBHOOK] Admin command detected: /assistant Wire Dexscreener SEARCH call with undeniable logs.

PATCH
=====

1) data_fetcher.py — add load + call logs and ensure the SEARCH helper is defined.

# --- BEGIN PATCH: data_fetcher.py ---
import logging

logging.info(">>> data_fetcher loaded vDEBUG-2 <<<")

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import the helper and log branch selection in /fetch_source.

# --- BEGIN PATCH: alerts/telegram.py ---
# at top imports:
from data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search

# inside cmd_fetch_source_sync, right after def line, add:
    logging.info(">>> ENTER cmd_fetch_source_sync")

# after parsing 'wanted', add:
        logging.info(f">>> /fetch_source wanted={wanted}")

# replace the dexscreener branch with this:
        if wanted in ("dexscreener","dex","ds"):
            logging.info(">>> BRANCH dexscreener(search)")
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---

3) alerts/telegram.py — ensure /fetch_now uses SEARCH (not old pairs).
# --- BEGIN PATCH: alerts/telegram.py ---
# In cmd_fetch_now_sync where items are gathered from sources, ensure the Dexscreener call is:
            try:
                more = _fetch_pairs_from_dexscreener_search(query="solana", limit=300)
                logging.info("[FETCH] /fetch_now dexscreener(search) injected %d items", len(more))
                items.extend(more)
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---
2025-08-10 13:25:10,839 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:25:17,540 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:25:17,929 [INFO] app: [WEBHOOK] Command '/assistant Wire Dexscreener SEARCH call with undeniable logs.

PATCH
=====

1) data_fetcher.py — add load + call logs and ensure the SEARCH helper is defined.

# --- BEGIN PATCH: data_fetcher.py ---
import logging

logging.info(">>> data_fetcher loaded vDEBUG-2 <<<")

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
# --- END PATCH ---

2) alerts/telegram.py — import the helper and log branch selection in /fetch_source.

# --- BEGIN PATCH: alerts/telegram.py ---
# at top imports:
from data_fetcher import fetch_candidates_from_pumpfun, _fetch_pairs_from_dexscreener_search

# inside cmd_fetch_source_sync, right after def line, add:
    logging.info(">>> ENTER cmd_fetch_source_sync")

# after parsing 'wanted', add:
        logging.info(f">>> /fetch_source wanted={wanted}")

# replace the dexscreener branch with this:
        if wanted in ("dexscreener","dex","ds"):
            logging.info(">>> BRANCH dexscreener(search)")
            items = _fetch_pairs_from_dexscreener_search(query="solana", limit=200)
            logging.info("[FETCH] /fetch_source dexscreener (search) returned %d items", len(items))
            if not items:
                await update.message.reply_text("Dexscreener search returned no rows. Try again in ~20s.")
                return "ok"
            rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
            for t in items[:20]:
                rows.append([
                    t.get("source") or "dexscreener",
                    t.get("symbol") or "?",
                    t.get("name") or "?",
                    t.get("holders") if t.get("holders") is not None else "-",
                    f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                    f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                    int(t["age_min"]) if t.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Dexscreener (search)")
            await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)
            return "ok"
# --- END PATCH ---

3) alerts/telegram.py — ensure /fetch_now uses SEARCH (not old pairs).
# --- BEGIN PATCH: alerts/telegram.py ---
# In cmd_fetch_now_sync where items are gathered from sources, ensure the Dexscreener call is:
            try:
                more = _fetch_pairs_from_dexscreener_search(query="solana", limit=300)
                logging.info("[FETCH] /fetch_now dexscreener(search) injected %d items", len(more))
                items.extend(more)
            except Exception as e:
                logging.error("[FETCH] Dexscreener search error: %s", e)
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:25:35,069 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:25:35,069 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:25:35,069 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:25:35,073 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:25:36,147 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:25:48,519 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:25:48,519 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121276, 'message': {'message_id': 4272, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832348, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:25:48,519 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:25:48,519 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:25:48,519 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:25:48,519 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:25:48,520 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:26:12,166 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:26:12,166 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121277, 'message': {'message_id': 4273, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832372, 'text': '/a_logs_tail 200 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:26:12,166 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:26:12,166 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 200 level=info'
2025-08-10 13:26:12,167 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 200 level=info
2025-08-10 13:26:12,545 [INFO] app: [WEBHOOK] Command '/a_logs_tail 200 level=info' processed, response sent: 200
2025-08-10 13:31:51,738 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:31:51,739 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121278, 'message': {'message_id': 4275, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832711, 'text': '/assistant Install fetch diagnostics, force Dexscreener SEARCH, and show module versions.\n\nPATCH\n=====\n\n1) data_fetcher.py — add version banner, last-request tracing, and SEARCH helper.\n\n# --- BEGIN PATCH: data_fetcher.py ---\nimport logging, time, random, httpx\nVERSION_DF = "df-3"\nlogging.info(f">>> data_fetcher loaded {VERSION_DF} <<<")\n\nLAST_JSON_URL = None\nLAST_JSON_STATUS = None\n\nDEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"\nPUMPFUN_ENDPOINTS = ["https://frontend-api.pump.fun/coins/created"]\n\ndef _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):\n    global LAST_JSON_URL, LAST_JSON_STATUS\n    ua = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/124 Safari/537.36"}\n    if headers:\n        ua.update(headers)\n    last_exc = None\n    for attempt in range(retries):\n        try:\n            LAST_JSON_URL = url\n            r = httpx.get(url, params=params, headers=ua, timeout=timeout)\n            LAST_JSON_STATUS = r.status_code\n            if r.status_code in (429,500,502,503,504):\n                raise httpx.HTTPStatusError("transient", request=r.request, response=r)\n            r.raise_for_status()\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            time.sleep((backoff * (attempt+1)) + random.uniform(0,0.6))\n    logging.warning("JSON fetch failed for %s: %s", url, last_exc)\n    return None\n\ndef _fetch_pairs_from_dexscreener_search(query="solana", limit=300):\n    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)\n    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})\n    if not js:\n        logging.warning("[FETCH] Dexscreener search returned no JSON")\n        return []\n    pairs = js.get("pairs") or []\n    out = []\n    for p in pairs[:limit]:\n        try:\n            base = p.get("baseToken") or {}\n            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"\n            name = base.get("name") or sym\n            mint = base.get("address") or p.get("pairAddress")\n            liq  = (p.get("liquidity") or {}).get("usd")\n            fdv  = p.get("fdv")\n            out.append({\n                "source": "dexscreener",\n                "symbol": sym,\n                "name": name,\n                "mint": mint,\n                "holders": None,\n                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,\n                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,\n                "age_min": None,\n                "renounced_mint_auth": None,\n                "renounced_freeze_auth": None,\n            })\n        except Exception:\n            continue\n    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))\n    return out', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 282, 'length': 12, 'type': 'url'}, {'offset': 409, 'length': 45, 'type': 'url'}, {'offset': 478, 'length': 43, 'type': 'url'}, {'offset': 1512, 'length': 12, 'type': 'url'}, {'offset': 2684, 'length': 12, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:31:51,739 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:31:51,739 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Install fetch diagnostics, force Dexscreener SEARCH, and show module versions.

PATCH
=====

1) data_fetcher.py — add version banner, last-request tracing, and SEARCH helper.

# --- BEGIN PATCH: data_fetcher.py ---
import logging, time, random, httpx
VERSION_DF = "df-3"
logging.info(f">>> data_fetcher loaded {VERSION_DF} <<<")

LAST_JSON_URL = None
LAST_JSON_STATUS = None

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"
PUMPFUN_ENDPOINTS = ["https://frontend-api.pump.fun/coins/created"]

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    global LAST_JSON_URL, LAST_JSON_STATUS
    ua = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/124 Safari/537.36"}
    if headers:
        ua.update(headers)
    last_exc = None
    for attempt in range(retries):
        try:
            LAST_JSON_URL = url
            r = httpx.get(url, params=params, headers=ua, timeout=timeout)
            LAST_JSON_STATUS = r.status_code
            if r.status_code in (429,500,502,503,504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep((backoff * (attempt+1)) + random.uniform(0,0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out'
2025-08-10 13:31:51,739 [INFO] app: [WEBHOOK] Admin command detected: /assistant Install fetch diagnostics, force Dexscreener SEARCH, and show module versions.

PATCH
=====

1) data_fetcher.py — add version banner, last-request tracing, and SEARCH helper.

# --- BEGIN PATCH: data_fetcher.py ---
import logging, time, random, httpx
VERSION_DF = "df-3"
logging.info(f">>> data_fetcher loaded {VERSION_DF} <<<")

LAST_JSON_URL = None
LAST_JSON_STATUS = None

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"
PUMPFUN_ENDPOINTS = ["https://frontend-api.pump.fun/coins/created"]

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    global LAST_JSON_URL, LAST_JSON_STATUS
    ua = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/124 Safari/537.36"}
    if headers:
        ua.update(headers)
    last_exc = None
    for attempt in range(retries):
        try:
            LAST_JSON_URL = url
            r = httpx.get(url, params=params, headers=ua, timeout=timeout)
            LAST_JSON_STATUS = r.status_code
            if r.status_code in (429,500,502,503,504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep((backoff * (attempt+1)) + random.uniform(0,0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out
2025-08-10 13:31:51,740 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:32:01,435 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:32:01,827 [INFO] app: [WEBHOOK] Command '/assistant Install fetch diagnostics, force Dexscreener SEARCH, and show module versions.

PATCH
=====

1) data_fetcher.py — add version banner, last-request tracing, and SEARCH helper.

# --- BEGIN PATCH: data_fetcher.py ---
import logging, time, random, httpx
VERSION_DF = "df-3"
logging.info(f">>> data_fetcher loaded {VERSION_DF} <<<")

LAST_JSON_URL = None
LAST_JSON_STATUS = None

DEXSCREENER_SEARCH = "https://api.dexscreener.com/latest/dex/search"
PUMPFUN_ENDPOINTS = ["https://frontend-api.pump.fun/coins/created"]

def _get_json_retry(url, params=None, headers=None, retries=3, backoff=1.5, timeout=10):
    global LAST_JSON_URL, LAST_JSON_STATUS
    ua = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/124 Safari/537.36"}
    if headers:
        ua.update(headers)
    last_exc = None
    for attempt in range(retries):
        try:
            LAST_JSON_URL = url
            r = httpx.get(url, params=params, headers=ua, timeout=timeout)
            LAST_JSON_STATUS = r.status_code
            if r.status_code in (429,500,502,503,504):
                raise httpx.HTTPStatusError("transient", request=r.request, response=r)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last_exc = e
            time.sleep((backoff * (attempt+1)) + random.uniform(0,0.6))
    logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return None

def _fetch_pairs_from_dexscreener_search(query="solana", limit=300):
    logging.info("[FETCH] Dexscreener USING SEARCH endpoint (q=%s)", query)
    js = _get_json_retry(DEXSCREENER_SEARCH, params={"q": query})
    if not js:
        logging.warning("[FETCH] Dexscreener search returned no JSON")
        return []
    pairs = js.get("pairs") or []
    out = []
    for p in pairs[:limit]:
        try:
            base = p.get("baseToken") or {}
            sym = base.get("symbol") or p.get("baseSymbol") or "SOL"
            name = base.get("name") or sym
            mint = base.get("address") or p.get("pairAddress")
            liq  = (p.get("liquidity") or {}).get("usd")
            fdv  = p.get("fdv")
            out.append({
                "source": "dexscreener",
                "symbol": sym,
                "name": name,
                "mint": mint,
                "holders": None,
                "mcap_usd": fdv if isinstance(fdv,(int,float)) else None,
                "liquidity_usd": liq if isinstance(liq,(int,float)) else None,
                "age_min": None,
                "renounced_mint_auth": None,
                "renounced_freeze_auth": None,
            })
        except Exception:
            continue
    logging.info("[FETCH] Dexscreener search yielded %d items", len(out))
    return out' processed, response sent: 200
2025-08-10 13:32:01,958 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:32:01,959 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121279, 'message': {'message_id': 4276, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832711, 'text': 'def fetch_candidates_from_pumpfun(limit=200, offset=0):\n    for base in PUMPFUN_ENDPOINTS:\n        try:\n            js = _get_json_retry(base, params={"limit":min(limit,200),"offset":max(0,offset)})\n            if not js:\n                continue\n            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []\n            items = []\n            for c in rows:\n                mint = c.get("mint") or c.get("mintAddress") or c.get("address")\n                if not mint: continue\n                name = c.get("name") or c.get("tokenName") or "Pump"\n                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")\n                if ts is not None and ts < 10_000_000_000: ts *= 1000\n                age_min = _minutes_since_ms(ts) if ts else None\n                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")\n                liq  = c.get("liquidity_usd") or c.get("liquidity")\n                items.append({\n                    "source":"pumpfun","symbol":sym or "?","name":name or sym or "Pump","mint":mint,\n                    "holders": c.get("holders") or None, "mcap_usd": mcap if isinstance(mcap,(int,float)) else None,\n                    "liquidity_usd": liq if isinstance(liq,(int,float)) else None, "age_min": age_min,\n                    "renounced_mint_auth": None, "renounced_freeze_auth": None,\n                })\n            if items: return items\n        except Exception as e:\n            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)\n    logging.error("[FETCH] All Pump.fun endpoints failed")\n    return []\n\ndef fetch_and_rank(rules):\n    all_items = []\n    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))\n    except Exception as e: logging.warning("Pump.fun source failed: %s", e)\n    try: all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))\n    except Exception as e: logging.error("[FETCH] Dexscreener search error: %s", e)\n\n    filtered = [t for t in all_items if _passes_rules(t, rules)]\n    for t in filtered:\n        t["risk"] = _score_token(t, rules)\n        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])\n        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])\n        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])\n        if t.get("holders") is None: t["holders"] = -1\n    filtered = _dedupe_keep_best(filtered)\n    def _src_priority(src): return 0 if src=="pumpfun" else 1\n    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))\n    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))\n    return filtered\n# --- END PATCH ---', 'entities': [{'offset': 1606, 'length': 8, 'type': 'url'}, {'offset': 1689, 'length': 8, 'type': 'url'}, {'offset': 1900, 'length': 8, 'type': 'url'}, {'offset': 2755, 'length': 12, 'type': 'url'}]}}
2025-08-10 13:32:01,959 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:32:01,959 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def fetch_candidates_from_pumpfun(limit=200, offset=0):
    for base in PUMPFUN_ENDPOINTS:
        try:
            js = _get_json_retry(base, params={"limit":min(limit,200),"offset":max(0,offset)})
            if not js:
                continue
            rows = js if isinstance(js, list) else js.get("coins") or js.get("data") or []
            items = []
            for c in rows:
                mint = c.get("mint") or c.get("mintAddress") or c.get("address")
                if not mint: continue
                name = c.get("name") or c.get("tokenName") or "Pump"
                sym  = c.get("symbol") or c.get("ticker") or (name[:4].upper() if name else "PUMP")
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("timestamp")
                if ts is not None and ts < 10_000_000_000: ts *= 1000
                age_min = _minutes_since_ms(ts) if ts else None
                mcap = c.get("usd_market_cap") or c.get("market_cap") or c.get("fdv_usd")
                liq  = c.get("liquidity_usd") or c.get("liquidity")
                items.append({
                    "source":"pumpfun","symbol":sym or "?","name":name or sym or "Pump","mint":mint,
                    "holders": c.get("holders") or None, "mcap_usd": mcap if isinstance(mcap,(int,float)) else None,
                    "liquidity_usd": liq if isinstance(liq,(int,float)) else None, "age_min": age_min,
                    "renounced_mint_auth": None, "renounced_freeze_auth": None,
                })
            if items: return items
        except Exception as e:
            logging.warning("Pump.fun fetch/parsing failed for %s: %s", base, e)
    logging.error("[FETCH] All Pump.fun endpoints failed")
    return []

def fetch_and_rank(rules):
    all_items = []
    try: all_items.extend(fetch_candidates_from_pumpfun(limit=200, offset=0))
    except Exception as e: logging.warning("Pump.fun source failed: %s", e)
    try: all_items.extend(_fetch_pairs_from_dexscreener_search(query="solana", limit=300))
    except Exception as e: logging.error("[FETCH] Dexscreener search error: %s", e)

    filtered = [t for t in all_items if _passes_rules(t, rules)]
    for t in filtered:
        t["risk"] = _score_token(t, rules)
        if t.get("mcap_usd") is not None: t["mcap_usd"] = int(t["mcap_usd"])
        if t.get("liquidity_usd") is not None: t["liquidity_usd"] = int(t["liquidity_usd"])
        if t.get("age_min") is not None: t["age_min"] = int(t["age_min"])
        if t.get("holders") is None: t["holders"] = -1
    filtered = _dedupe_keep_best(filtered)
    def _src_priority(src): return 0 if src=="pumpfun" else 1
    filtered.sort(key=lambda x: (_src_priority(x.get("source")), x["risk"], -(x.get("liquidity_usd") or 0)))
    logging.info("[FETCH] Merged and ranked %d tokens from %d total", len(filtered), len(all_items))
    return filtered
# --- END PATCH ---'
2025-08-10 13:32:05,366 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:32:05,367 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121280, 'message': {'message_id': 4278, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832725, 'text': '2) alerts/telegram.py — add version banner and a new /a_diag_fetch command.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\nimport logging\nVERSION_TG = "tg-2"\nlogging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")\n\nfrom data_fetcher import (\n    fetch_candidates_from_pumpfun,\n    _fetch_pairs_from_dexscreener_search,\n    fetch_and_rank,\n    DEXSCREENER_SEARCH, PUMPFUN_ENDPOINTS, LAST_JSON_URL, LAST_JSON_STATUS,\n)\n\nasync def cmd_a_diag_fetch(update, context):\n    try:\n        import data_fetcher as df\n        lines = [\n            "```\\n[DIAG FETCH]",\n            f"alerts.telegram={VERSION_TG}",\n            f"data_fetcher={getattr(df,\'VERSION_DF\',\'?\')}",\n            f"DEXSCREENER_SEARCH={df.DEXSCREENER_SEARCH}",\n            f"PUMPFUN_ENDPOINTS={df.PUMPFUN_ENDPOINTS}",\n            f"LAST_JSON_URL={df.LAST_JSON_URL}",\n            f"LAST_JSON_STATUS={df.LAST_JSON_STATUS}",\n            "```",\n        ]\n        await update.message.reply_text("\\n".join(lines), parse_mode=ParseMode.MARKDOWN)\n        return "ok"\n    except Exception as e:\n        logging.exception("a_diag_fetch error")\n        await update.message.reply_text(f"diag failed: {e}")\n        return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 10, 'length': 11, 'type': 'url'}, {'offset': 53, 'length': 13, 'type': 'bot_command'}, {'offset': 103, 'length': 11, 'type': 'url'}, {'offset': 154, 'length': 12, 'type': 'url'}]}}
2025-08-10 13:32:05,367 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:32:05,367 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '2) alerts/telegram.py — add version banner and a new /a_diag_fetch command.

# --- BEGIN PATCH: alerts/telegram.py ---
import logging
VERSION_TG = "tg-2"
logging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")

from data_fetcher import (
    fetch_candidates_from_pumpfun,
    _fetch_pairs_from_dexscreener_search,
    fetch_and_rank,
    DEXSCREENER_SEARCH, PUMPFUN_ENDPOINTS, LAST_JSON_URL, LAST_JSON_STATUS,
)

async def cmd_a_diag_fetch(update, context):
    try:
        import data_fetcher as df
        lines = [
            "```\n[DIAG FETCH]",
            f"alerts.telegram={VERSION_TG}",
            f"data_fetcher={getattr(df,'VERSION_DF','?')}",
            f"DEXSCREENER_SEARCH={df.DEXSCREENER_SEARCH}",
            f"PUMPFUN_ENDPOINTS={df.PUMPFUN_ENDPOINTS}",
            f"LAST_JSON_URL={df.LAST_JSON_URL}",
            f"LAST_JSON_STATUS={df.LAST_JSON_STATUS}",
            "```",
        ]
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
        return "ok"
    except Exception as e:
        logging.exception("a_diag_fetch error")
        await update.message.reply_text(f"diag failed: {e}")
        return "ok"
# --- END PATCH ---'
2025-08-10 13:32:12,750 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:32:12,750 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121281, 'message': {'message_id': 4279, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832732, 'text': '3) app.py — route /a_diag_fetch (put with the other admin routes, before fallback).\n\n# --- BEGIN PATCH: app.py ---\n        if text.startswith("/a_diag_fetch"):\n            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n                _reply("Not authorized."); return "ok"\n            from alerts.telegram import cmd_a_diag_fetch\n            _reply(await cmd_a_diag_fetch(update, None)); return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 3, 'length': 6, 'type': 'url'}, {'offset': 18, 'length': 13, 'type': 'bot_command'}, {'offset': 104, 'length': 6, 'type': 'url'}, {'offset': 143, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:32:12,751 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:32:12,751 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '3) app.py — route /a_diag_fetch (put with the other admin routes, before fallback).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/a_diag_fetch"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_a_diag_fetch
            _reply(await cmd_a_diag_fetch(update, None)); return "ok"
# --- END PATCH ---'
2025-08-10 13:32:37,007 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:32:37,007 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:32:37,007 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:32:37,010 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:32:37,942 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:32:58,520 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:32:58,521 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121282, 'message': {'message_id': 4280, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832778, 'text': '/a_diag_fetch', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:32:58,522 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:32:58,522 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_diag_fetch'
2025-08-10 13:32:58,523 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 13:32:58,523 [INFO] app: [WEBHOOK] Unknown admin command: /a_diag_fetch
2025-08-10 13:33:12,457 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:33:12,459 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121283, 'message': {'message_id': 4281, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754832792, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:33:12,459 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:33:12,460 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 13:33:12,460 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 13:33:12,903 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 13:49:17,480 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:49:17,480 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121284, 'message': {'message_id': 4283, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754833757, 'text': '/assistant Add /a_diag_fetch route and handler (diagnostics for sources and versions).\n\nPATCH\n=====\n\n1) alerts/telegram.py — define the diag handler if missing.\n\n# --- BEGIN PATCH: alerts/telegram.py ---\nimport logging\nfrom telegram.constants import ParseMode\n\n# version tags so we can see what\'s loaded\nVERSION_TG = "tg-3"\nlogging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")\n\n# imports for diag\nimport importlib\nimport data_fetcher as df\n\nasync def cmd_a_diag_fetch(update, context):\n    try:\n        importlib.reload(df)  # ensure we read latest module symbols\n        lines = [\n            "```\\n[DIAG FETCH]",\n            f"alerts.telegram={VERSION_TG}",\n            f"data_fetcher={getattr(df,\'VERSION_DF\',\'?\')}",\n            f"DEXSCREENER_SEARCH={getattr(df,\'DEXSCREENER_SEARCH\',\'?\')}",\n            f"PUMPFUN_ENDPOINTS={getattr(df,\'PUMPFUN_ENDPOINTS\',\'?\')}",\n            f"LAST_JSON_URL={getattr(df,\'LAST_JSON_URL\',\'?\')}",\n            f"LAST_JSON_STATUS={getattr(df,\'LAST_JSON_STATUS\',\'?\')}",\n            "```",\n        ]\n        await update.message.reply_text("\\n".join(lines), parse_mode=ParseMode.MARKDOWN)\n        return "ok"\n    except Exception as e:\n        logging.exception("a_diag_fetch error")\n        await update.message.reply_text(f"diag failed: {e}")\n        return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 15, 'length': 13, 'type': 'bot_command'}, {'offset': 111, 'length': 11, 'type': 'url'}, {'offset': 188, 'length': 11, 'type': 'url'}, {'offset': 324, 'length': 12, 'type': 'url'}]}}
2025-08-10 13:49:17,481 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:49:17,481 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add /a_diag_fetch route and handler (diagnostics for sources and versions).

PATCH
=====

1) alerts/telegram.py — define the diag handler if missing.

# --- BEGIN PATCH: alerts/telegram.py ---
import logging
from telegram.constants import ParseMode

# version tags so we can see what's loaded
VERSION_TG = "tg-3"
logging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")

# imports for diag
import importlib
import data_fetcher as df

async def cmd_a_diag_fetch(update, context):
    try:
        importlib.reload(df)  # ensure we read latest module symbols
        lines = [
            "```\n[DIAG FETCH]",
            f"alerts.telegram={VERSION_TG}",
            f"data_fetcher={getattr(df,'VERSION_DF','?')}",
            f"DEXSCREENER_SEARCH={getattr(df,'DEXSCREENER_SEARCH','?')}",
            f"PUMPFUN_ENDPOINTS={getattr(df,'PUMPFUN_ENDPOINTS','?')}",
            f"LAST_JSON_URL={getattr(df,'LAST_JSON_URL','?')}",
            f"LAST_JSON_STATUS={getattr(df,'LAST_JSON_STATUS','?')}",
            "```",
        ]
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
        return "ok"
    except Exception as e:
        logging.exception("a_diag_fetch error")
        await update.message.reply_text(f"diag failed: {e}")
        return "ok"
# --- END PATCH ---'
2025-08-10 13:49:17,481 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add /a_diag_fetch route and handler (diagnostics for sources and versions).

PATCH
=====

1) alerts/telegram.py — define the diag handler if missing.

# --- BEGIN PATCH: alerts/telegram.py ---
import logging
from telegram.constants import ParseMode

# version tags so we can see what's loaded
VERSION_TG = "tg-3"
logging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")

# imports for diag
import importlib
import data_fetcher as df

async def cmd_a_diag_fetch(update, context):
    try:
        importlib.reload(df)  # ensure we read latest module symbols
        lines = [
            "```\n[DIAG FETCH]",
            f"alerts.telegram={VERSION_TG}",
            f"data_fetcher={getattr(df,'VERSION_DF','?')}",
            f"DEXSCREENER_SEARCH={getattr(df,'DEXSCREENER_SEARCH','?')}",
            f"PUMPFUN_ENDPOINTS={getattr(df,'PUMPFUN_ENDPOINTS','?')}",
            f"LAST_JSON_URL={getattr(df,'LAST_JSON_URL','?')}",
            f"LAST_JSON_STATUS={getattr(df,'LAST_JSON_STATUS','?')}",
            "```",
        ]
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
        return "ok"
    except Exception as e:
        logging.exception("a_diag_fetch error")
        await update.message.reply_text(f"diag failed: {e}")
        return "ok"
# --- END PATCH ---
2025-08-10 13:49:17,481 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 13:49:17,482 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:49:24,464 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 13:49:24,864 [INFO] app: [WEBHOOK] Command '/assistant Add /a_diag_fetch route and handler (diagnostics for sources and versions).

PATCH
=====

1) alerts/telegram.py — define the diag handler if missing.

# --- BEGIN PATCH: alerts/telegram.py ---
import logging
from telegram.constants import ParseMode

# version tags so we can see what's loaded
VERSION_TG = "tg-3"
logging.info(f">>> alerts.telegram loaded {VERSION_TG} <<<")

# imports for diag
import importlib
import data_fetcher as df

async def cmd_a_diag_fetch(update, context):
    try:
        importlib.reload(df)  # ensure we read latest module symbols
        lines = [
            "```\n[DIAG FETCH]",
            f"alerts.telegram={VERSION_TG}",
            f"data_fetcher={getattr(df,'VERSION_DF','?')}",
            f"DEXSCREENER_SEARCH={getattr(df,'DEXSCREENER_SEARCH','?')}",
            f"PUMPFUN_ENDPOINTS={getattr(df,'PUMPFUN_ENDPOINTS','?')}",
            f"LAST_JSON_URL={getattr(df,'LAST_JSON_URL','?')}",
            f"LAST_JSON_STATUS={getattr(df,'LAST_JSON_STATUS','?')}",
            "```",
        ]
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
        return "ok"
    except Exception as e:
        logging.exception("a_diag_fetch error")
        await update.message.reply_text(f"diag failed: {e}")
        return "ok"
# --- END PATCH ---' processed, response sent: 200
2025-08-10 13:49:25,713 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:49:25,713 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121285, 'message': {'message_id': 4285, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754833765, 'text': '2) app.py — add a router branch for /a_diag_fetch (place with other admin routes, BEFORE the unknown fallback).\n\n# --- BEGIN PATCH: app.py ---\n        if text.startswith("/a_diag_fetch"):\n            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n                _reply("Not authorized."); return "ok"\n            from alerts.telegram import cmd_a_diag_fetch\n            _reply(await cmd_a_diag_fetch(update, None)); return "ok"\n# --- END PATCH ---', 'entities': [{'offset': 3, 'length': 6, 'type': 'url'}, {'offset': 36, 'length': 13, 'type': 'bot_command'}, {'offset': 132, 'length': 6, 'type': 'url'}, {'offset': 171, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:49:25,714 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:49:25,714 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '2) app.py — add a router branch for /a_diag_fetch (place with other admin routes, BEFORE the unknown fallback).

# --- BEGIN PATCH: app.py ---
        if text.startswith("/a_diag_fetch"):
            if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
                _reply("Not authorized."); return "ok"
            from alerts.telegram import cmd_a_diag_fetch
            _reply(await cmd_a_diag_fetch(update, None)); return "ok"
# --- END PATCH ---'
2025-08-10 13:49:58,945 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:49:58,946 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 13:49:58,946 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 13:49:58,949 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 13:49:59,653 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 13:50:16,758 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:50:16,759 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121286, 'message': {'message_id': 4286, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754833816, 'text': "[DIAG FETCH]\nalerts.telegram=tg-3\ndata_fetcher=df-3            <- good if you see df-3\nDEXSCREENER_SEARCH=https://api.dexscreener.com/latest/dex/search\nPUMPFUN_ENDPOINTS=['https://frontend-api.pump.fun/coins/created']\nLAST_JSON_URL=...            <- will fill in after a fetch\nLAST_JSON_STATUS=...", 'entities': [{'offset': 106, 'length': 45, 'type': 'url'}, {'offset': 172, 'length': 43, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 13:50:16,759 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:50:16,759 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '[DIAG FETCH]
alerts.telegram=tg-3
data_fetcher=df-3            <- good if you see df-3
DEXSCREENER_SEARCH=https://api.dexscreener.com/latest/dex/search
PUMPFUN_ENDPOINTS=['https://frontend-api.pump.fun/coins/created']
LAST_JSON_URL=...            <- will fill in after a fetch
LAST_JSON_STATUS=...'
2025-08-10 13:50:34,930 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:50:34,930 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121287, 'message': {'message_id': 4287, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754833834, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 13:50:34,931 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:50:34,931 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 13:50:34,931 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 13:50:34,931 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 13:50:34,932 [INFO] root: >>> LOADED alerts.telegram vDEBUG-1 <<<
2025-08-10 13:50:44,901 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 13:50:44,901 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121288, 'message': {'message_id': 4288, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754833844, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 13:50:44,901 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 13:50:44,902 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 13:50:44,902 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 13:50:45,318 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 14:00:48,943 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:00:48,944 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:00:48,944 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:00:48,947 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:00:49,830 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:01:02,708 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:01:02,708 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 14:01:02,708 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:01:02,709 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 14:01:02,709 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:01:02,709 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:01:02,710 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:01:02,867 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 14:01:02,867 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:01:32,239 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:01:32,240 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:01:32,240 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:01:32,244 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:01:33,185 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:02:22,482 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:02:22,483 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:02:22,483 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:02:22,485 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:02:23,150 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:03:18,622 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:03:18,623 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source dexscreener'}}
2025-08-10 14:03:18,623 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:03:18,623 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source dexscreener'
2025-08-10 14:03:18,624 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 14:03:18,624 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:03:18,625 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:03:18,806 [ERROR] root: [FETCH] DexScreener API error: 404 Client Error: Not Found for url: https://api.dexscreener.com/latest/dex/pairs/solana
2025-08-10 14:03:18,807 [INFO] root: [FETCH] /fetch_source dexscreener (search) returned 0 items
2025-08-10 14:03:45,824 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:03:45,825 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:03:45,825 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:03:45,830 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:03:46,698 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:03:58,296 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:03:58,296 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 14:03:58,297 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:03:58,297 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 14:03:58,297 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:03:58,297 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:03:58,298 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:03:58,338 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:03:58,427 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: 530 Server Error:  for url: https://frontend-api.pump.fun/coins/created?limit=50&offset=0
2025-08-10 14:03:58,427 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:03:58,427 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:04:32,122 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:04:32,122 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:04:32,122 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:04:32,126 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:04:33,120 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:04:34,892 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:04:34,892 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:04:34,892 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:04:34,895 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:04:35,576 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:05:02,843 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:05:02,843 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 14:05:02,843 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:05:02,844 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 14:05:02,844 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:05:02,844 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:05:02,845 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:05:02,884 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:05:03,044 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:05:04,712 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:05:08,072 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:05:08,072 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:05:08,073 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:05:36,077 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:05:36,078 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:05:36,078 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:05:36,081 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:05:36,805 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:05:46,192 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:05:46,192 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_diag_fetch'}}
2025-08-10 14:05:46,192 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:05:46,192 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_diag_fetch'
2025-08-10 14:05:46,193 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 14:05:46,193 [INFO] app: [WEBHOOK] Unknown admin command: /a_diag_fetch
2025-08-10 14:06:24,039 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:06:24,039 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source dexscreener'}}
2025-08-10 14:06:24,039 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:06:24,039 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source dexscreener'
2025-08-10 14:06:24,039 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 14:06:24,040 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:06:24,041 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:06:24,080 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:06:24,088 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:06:24,174 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:06:24,175 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:06:24,177 [INFO] root: [FETCH] /fetch_source dexscreener (search) returned 30 items
2025-08-10 14:06:30,659 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:06:30,659 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:06:30,659 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:06:30,661 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:06:31,361 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:07:26,810 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:07:26,811 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 14:07:26,811 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:07:26,811 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 14:07:26,811 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:07:26,811 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:07:26,812 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:07:26,852 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:07:26,876 [INFO] root: [RULES] Loaded (v1)
2025-08-10 14:07:26,971 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:07:28,920 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:07:32,244 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:07:32,244 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:07:32,245 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:07:32,347 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:07:32,351 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:07:32,351 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:08:21,130 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:08:21,130 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:08:21,130 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:08:21,133 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:08:21,895 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:08:31,680 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:08:31,680 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_diag_fetch'}}
2025-08-10 14:08:31,680 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:08:31,680 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_diag_fetch'
2025-08-10 14:08:31,681 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 14:08:31,681 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:08:31,719 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:08:31,727 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:08:31,727 [ERROR] root: a_diag_fetch error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 648, in cmd_a_diag_fetch
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'obj' object has no attribute 'reply_text'
2025-08-10 14:08:32,096 [INFO] app: [WEBHOOK] Command '/a_diag_fetch' processed, response sent: 200
2025-08-10 14:09:13,637 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:09:13,639 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source dexscreener'}}
2025-08-10 14:09:13,639 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:09:13,640 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source dexscreener'
2025-08-10 14:09:13,640 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 14:09:13,640 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:09:13,641 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:09:13,853 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:09:13,855 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:09:13,856 [INFO] root: [FETCH] /fetch_source dexscreener (search) returned 30 items
2025-08-10 14:09:31,953 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:09:31,953 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_source pumpfun'}}
2025-08-10 14:09:31,953 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:09:31,953 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_source pumpfun'
2025-08-10 14:09:31,953 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:09:31,954 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:09:32,048 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:09:34,270 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:09:37,792 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:09:37,792 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:09:37,792 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:09:44,460 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:09:44,460 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:09:44,461 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:09:44,463 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:09:45,169 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:11:25,394 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:11:25,395 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121289, 'message': {'message_id': 4299, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835084, 'text': '/a_logs_tail 120 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:11:25,396 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:11:25,396 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 120 level=info'
2025-08-10 14:11:25,397 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 120 level=info
2025-08-10 14:11:25,835 [INFO] app: [WEBHOOK] Command '/a_logs_tail 120 level=info' processed, response sent: 200
2025-08-10 14:11:40,264 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:11:40,264 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121290, 'message': {'message_id': 4301, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835100, 'text': '/a_diag_fetch', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:11:40,264 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:11:40,264 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_diag_fetch'
2025-08-10 14:11:40,264 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 14:11:40,265 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:11:40,266 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:11:40,275 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:11:40,275 [ERROR] root: a_diag_fetch error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 648, in cmd_a_diag_fetch
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'obj' object has no attribute 'reply_text'
2025-08-10 14:11:40,662 [INFO] app: [WEBHOOK] Command '/a_diag_fetch' processed, response sent: 200
2025-08-10 14:11:58,602 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:11:58,603 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121291, 'message': {'message_id': 4303, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835118, 'text': '/fetch_source dexscreener', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:11:58,603 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:11:58,603 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener'
2025-08-10 14:11:58,604 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener
2025-08-10 14:11:58,604 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:11:58,605 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:11:58,734 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:11:58,737 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:11:58,737 [INFO] root: [FETCH] /fetch_source dexscreener (search) returned 30 items
2025-08-10 14:12:11,390 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:12:11,391 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121292, 'message': {'message_id': 4305, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835131, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:12:11,391 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:12:11,391 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 14:12:11,391 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:12:11,391 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:12:11,507 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:12:13,362 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:12:16,818 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:12:16,818 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:12:16,818 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:12:27,140 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:12:27,140 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121293, 'message': {'message_id': 4307, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835147, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:12:27,141 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:12:27,141 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:12:27,141 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:12:27,141 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:12:27,162 [INFO] root: [RULES] Loaded (v1)
2025-08-10 14:12:27,278 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:12:29,281 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:12:32,710 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:12:32,711 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:12:32,711 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:12:32,824 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:12:32,827 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:12:32,828 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:13:13,498 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:13:13,498 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121294, 'message': {'message_id': 4309, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835193, 'text': '/a_logs_tail 200 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:13:13,498 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:13:13,498 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 200 level=info'
2025-08-10 14:13:13,499 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 200 level=info
2025-08-10 14:13:13,905 [INFO] app: [WEBHOOK] Command '/a_logs_tail 200 level=info' processed, response sent: 200
2025-08-10 14:20:15,875 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:20:15,876 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121295, 'message': {'message_id': 4311, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835615, 'text': '/assistant patch: Harden Pump.fun fetcher (headers + retries)\n\nFILE: data_fetcher.py\n--- BEGIN PATCH ---\ntry:\n    import httpx\nexcept Exception:  # fallback if httpx missing in this env\n    httpx = None\n\nimport time, random, logging\n\n# Public endpoints (unchanged path; we just handle them more gently)\nPUMPFUN_ENDPOINTS = [\n    "https://frontend-api.pump.fun/coins/created",\n]\n\n# Conservative, real-browser-y headers to dodge CDN 530s sometimes\n_DEFAULT_HEADERS = {\n    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",\n    "Accept": "application/json,text/plain,*/*",\n    "Accept-Language": "en-US,en;q=0.9",\n    "Connection": "keep-alive",\n    "Referer": "https://pump.fun/",\n    "Origin": "https://pump.fun",\n}\n\ndef _fetch_json_hardened(url: str, params=None, timeout=5.0, retries=3):\n    """\n    Sync JSON fetch with short timeouts, jittered backoff, and browser-like headers.\n    Returns (status_code, json_or_None). Raises only after final failure.\n    """\n    if httpx is None:\n        raise RuntimeError("httpx not available")\n\n    last_exc = None\n    # backoff: ~0.4s, 0.8s, 1.6s (+/- jitter)\n    for attempt in range(retries):\n        try:\n            with httpx.Client(timeout=timeout, headers=_DEFAULT_HEADERS, follow_redirects=True) as client:\n                resp = client.get(url, params=params)\n                sc = resp.status_code\n                if sc == 200:\n                    try:\n                        return sc, resp.json()\n                    except Exception as je:\n                        last_exc = je\n                        sc = 599\n                # For 5xx (incl. 530) or 429, retry; for 4xx (not 429), break\n                if sc in (429,) or 500 <= sc < 600 or sc == 530:\n                    pass  # retry below\n                else:\n                    # non-retriable\n                    return sc, None\n        except Exception as e:\n            last_exc = e\n        # backoff (except after last attempt)\n        if attempt < retries - 1:\n            base = 0.4 * (2 ** attempt)\n            time.sleep(base + random.uniform(0.05, 0.25))\n\n    # all attempts failed\n    if last_exc:\n        logging.warning("JSON fetch failed for %s: %s", url, last_exc)\n    return (0, None)\n\ndef fetch_candidates_from_pumpfun(limit: int = 50, offset: int = 0):\n    """\n    Returns a list of dicts: {source,symbol,name,holders,mcap_usd,liquidity_usd,age_min}\n    Uses hardened JSON client with headers + retries.\n    """\n    items = []\n    params = {"limit": max(10, min(200, int(limit or 50))), "offset": max(0, int(offset or 0))}\n    for base in PUMPFUN_ENDPOINTS:\n        url = f"{base}"\n        status, data = _fetch_json_hardened(url, params=params, timeout=5.5, retries=3)\n        if status == 200 and isinstance(data, dict):\n            coins = data.get("coins") or data.get("data") or []\n            now_ms = int(time.time() * 1000)\n            for c in coins:\n                # Map best-effort fields; many are unknown in public feed\n                sym = c.get("symbol") or c.get("ticker") or "?"\n                name = c.get("name") or sym\n                # Age in minutes if "created_timestamp" available; else unknown\n                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("createdAtMs")\n                try:\n                    if isinstance(ts, str) and ts.isdigit():\n                        ts = int(ts)\n                    if ts and ts < 10_000_000_000:  # seconds → ms\n                        ts *= 1000\n                except Exception:\n                    pass\n                age_min = int(max(0, (now_ms - ts) / 60000)) if isinstance(ts, (int, float)) else None', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 25, 'length': 8, 'type': 'url'}, {'offset': 330, 'length': 43, 'type': 'url'}, {'offset': 740, 'length': 17, 'type': 'url'}, {'offset': 775, 'length': 16, 'type': 'url'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 14:20:15,876 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:20:15,876 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant patch: Harden Pump.fun fetcher (headers + retries)

FILE: data_fetcher.py
--- BEGIN PATCH ---
try:
    import httpx
except Exception:  # fallback if httpx missing in this env
    httpx = None

import time, random, logging

# Public endpoints (unchanged path; we just handle them more gently)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

# Conservative, real-browser-y headers to dodge CDN 530s sometimes
_DEFAULT_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
    "Accept": "application/json,text/plain,*/*",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
    "Referer": "https://pump.fun/",
    "Origin": "https://pump.fun",
}

def _fetch_json_hardened(url: str, params=None, timeout=5.0, retries=3):
    """
    Sync JSON fetch with short timeouts, jittered backoff, and browser-like headers.
    Returns (status_code, json_or_None). Raises only after final failure.
    """
    if httpx is None:
        raise RuntimeError("httpx not available")

    last_exc = None
    # backoff: ~0.4s, 0.8s, 1.6s (+/- jitter)
    for attempt in range(retries):
        try:
            with httpx.Client(timeout=timeout, headers=_DEFAULT_HEADERS, follow_redirects=True) as client:
                resp = client.get(url, params=params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                # For 5xx (incl. 530) or 429, retry; for 4xx (not 429), break
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass  # retry below
                else:
                    # non-retriable
                    return sc, None
        except Exception as e:
            last_exc = e
        # backoff (except after last attempt)
        if attempt < retries - 1:
            base = 0.4 * (2 ** attempt)
            time.sleep(base + random.uniform(0.05, 0.25))

    # all attempts failed
    if last_exc:
        logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return (0, None)

def fetch_candidates_from_pumpfun(limit: int = 50, offset: int = 0):
    """
    Returns a list of dicts: {source,symbol,name,holders,mcap_usd,liquidity_usd,age_min}
    Uses hardened JSON client with headers + retries.
    """
    items = []
    params = {"limit": max(10, min(200, int(limit or 50))), "offset": max(0, int(offset or 0))}
    for base in PUMPFUN_ENDPOINTS:
        url = f"{base}"
        status, data = _fetch_json_hardened(url, params=params, timeout=5.5, retries=3)
        if status == 200 and isinstance(data, dict):
            coins = data.get("coins") or data.get("data") or []
            now_ms = int(time.time() * 1000)
            for c in coins:
                # Map best-effort fields; many are unknown in public feed
                sym = c.get("symbol") or c.get("ticker") or "?"
                name = c.get("name") or sym
                # Age in minutes if "created_timestamp" available; else unknown
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("createdAtMs")
                try:
                    if isinstance(ts, str) and ts.isdigit():
                        ts = int(ts)
                    if ts and ts < 10_000_000_000:  # seconds → ms
                        ts *= 1000
                except Exception:
                    pass
                age_min = int(max(0, (now_ms - ts) / 60000)) if isinstance(ts, (int, float)) else None'
2025-08-10 14:20:15,876 [INFO] app: [WEBHOOK] Admin command detected: /assistant patch: Harden Pump.fun fetcher (headers + retries)

FILE: data_fetcher.py
--- BEGIN PATCH ---
try:
    import httpx
except Exception:  # fallback if httpx missing in this env
    httpx = None

import time, random, logging

# Public endpoints (unchanged path; we just handle them more gently)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

# Conservative, real-browser-y headers to dodge CDN 530s sometimes
_DEFAULT_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
    "Accept": "application/json,text/plain,*/*",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
    "Referer": "https://pump.fun/",
    "Origin": "https://pump.fun",
}

def _fetch_json_hardened(url: str, params=None, timeout=5.0, retries=3):
    """
    Sync JSON fetch with short timeouts, jittered backoff, and browser-like headers.
    Returns (status_code, json_or_None). Raises only after final failure.
    """
    if httpx is None:
        raise RuntimeError("httpx not available")

    last_exc = None
    # backoff: ~0.4s, 0.8s, 1.6s (+/- jitter)
    for attempt in range(retries):
        try:
            with httpx.Client(timeout=timeout, headers=_DEFAULT_HEADERS, follow_redirects=True) as client:
                resp = client.get(url, params=params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                # For 5xx (incl. 530) or 429, retry; for 4xx (not 429), break
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass  # retry below
                else:
                    # non-retriable
                    return sc, None
        except Exception as e:
            last_exc = e
        # backoff (except after last attempt)
        if attempt < retries - 1:
            base = 0.4 * (2 ** attempt)
            time.sleep(base + random.uniform(0.05, 0.25))

    # all attempts failed
    if last_exc:
        logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return (0, None)

def fetch_candidates_from_pumpfun(limit: int = 50, offset: int = 0):
    """
    Returns a list of dicts: {source,symbol,name,holders,mcap_usd,liquidity_usd,age_min}
    Uses hardened JSON client with headers + retries.
    """
    items = []
    params = {"limit": max(10, min(200, int(limit or 50))), "offset": max(0, int(offset or 0))}
    for base in PUMPFUN_ENDPOINTS:
        url = f"{base}"
        status, data = _fetch_json_hardened(url, params=params, timeout=5.5, retries=3)
        if status == 200 and isinstance(data, dict):
            coins = data.get("coins") or data.get("data") or []
            now_ms = int(time.time() * 1000)
            for c in coins:
                # Map best-effort fields; many are unknown in public feed
                sym = c.get("symbol") or c.get("ticker") or "?"
                name = c.get("name") or sym
                # Age in minutes if "created_timestamp" available; else unknown
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("createdAtMs")
                try:
                    if isinstance(ts, str) and ts.isdigit():
                        ts = int(ts)
                    if ts and ts < 10_000_000_000:  # seconds → ms
                        ts *= 1000
                except Exception:
                    pass
                age_min = int(max(0, (now_ms - ts) / 60000)) if isinstance(ts, (int, float)) else None
2025-08-10 14:20:15,876 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 14:20:18,983 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 14:20:19,372 [INFO] app: [WEBHOOK] Command '/assistant patch: Harden Pump.fun fetcher (headers + retries)

FILE: data_fetcher.py
--- BEGIN PATCH ---
try:
    import httpx
except Exception:  # fallback if httpx missing in this env
    httpx = None

import time, random, logging

# Public endpoints (unchanged path; we just handle them more gently)
PUMPFUN_ENDPOINTS = [
    "https://frontend-api.pump.fun/coins/created",
]

# Conservative, real-browser-y headers to dodge CDN 530s sometimes
_DEFAULT_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
    "Accept": "application/json,text/plain,*/*",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
    "Referer": "https://pump.fun/",
    "Origin": "https://pump.fun",
}

def _fetch_json_hardened(url: str, params=None, timeout=5.0, retries=3):
    """
    Sync JSON fetch with short timeouts, jittered backoff, and browser-like headers.
    Returns (status_code, json_or_None). Raises only after final failure.
    """
    if httpx is None:
        raise RuntimeError("httpx not available")

    last_exc = None
    # backoff: ~0.4s, 0.8s, 1.6s (+/- jitter)
    for attempt in range(retries):
        try:
            with httpx.Client(timeout=timeout, headers=_DEFAULT_HEADERS, follow_redirects=True) as client:
                resp = client.get(url, params=params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                # For 5xx (incl. 530) or 429, retry; for 4xx (not 429), break
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass  # retry below
                else:
                    # non-retriable
                    return sc, None
        except Exception as e:
            last_exc = e
        # backoff (except after last attempt)
        if attempt < retries - 1:
            base = 0.4 * (2 ** attempt)
            time.sleep(base + random.uniform(0.05, 0.25))

    # all attempts failed
    if last_exc:
        logging.warning("JSON fetch failed for %s: %s", url, last_exc)
    return (0, None)

def fetch_candidates_from_pumpfun(limit: int = 50, offset: int = 0):
    """
    Returns a list of dicts: {source,symbol,name,holders,mcap_usd,liquidity_usd,age_min}
    Uses hardened JSON client with headers + retries.
    """
    items = []
    params = {"limit": max(10, min(200, int(limit or 50))), "offset": max(0, int(offset or 0))}
    for base in PUMPFUN_ENDPOINTS:
        url = f"{base}"
        status, data = _fetch_json_hardened(url, params=params, timeout=5.5, retries=3)
        if status == 200 and isinstance(data, dict):
            coins = data.get("coins") or data.get("data") or []
            now_ms = int(time.time() * 1000)
            for c in coins:
                # Map best-effort fields; many are unknown in public feed
                sym = c.get("symbol") or c.get("ticker") or "?"
                name = c.get("name") or sym
                # Age in minutes if "created_timestamp" available; else unknown
                ts = c.get("created_timestamp") or c.get("createdAt") or c.get("createdAtMs")
                try:
                    if isinstance(ts, str) and ts.isdigit():
                        ts = int(ts)
                    if ts and ts < 10_000_000_000:  # seconds → ms
                        ts *= 1000
                except Exception:
                    pass
                age_min = int(max(0, (now_ms - ts) / 60000)) if isinstance(ts, (int, float)) else None' processed, response sent: 200
2025-08-10 14:20:19,488 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:20:19,488 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121296, 'message': {'message_id': 4312, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835615, 'text': 'items.append({\n                    "source": "pumpfun",\n                    "symbol": sym,\n                    "name": name,\n                    "holders": None,             # not in public feed\n                    "mcap_usd": c.get("market_cap") or c.get("mcap") or None,\n                    "liquidity_usd": c.get("liquidity_usd") or c.get("liquidity") or None,\n                    "age_min": age_min,\n                })\n            logging.info("[FETCH] Pump.fun yielded %s items", len(items))\n            break\n        else:\n            if status:\n                logging.warning("Pump.fun returned HTTP %s", status)\n            else:\n                logging.warning("Pump.fun request failed without HTTP status")\n    if not items:\n        logging.error("[FETCH] All Pump.fun endpoints failed")\n    return items\n--- END PATCH ---\n\nNOTES:\n- No response is expected to this patch message.\n- It strengthens only Pump.fun; Dexscreener remains on the search endpoint.', 'entities': [{'offset': 435, 'length': 12, 'type': 'url'}, {'offset': 457, 'length': 8, 'type': 'url'}, {'offset': 585, 'length': 8, 'type': 'url'}, {'offset': 672, 'length': 8, 'type': 'url'}, {'offset': 771, 'length': 8, 'type': 'url'}, {'offset': 913, 'length': 8, 'type': 'url'}]}}
2025-08-10 14:20:19,488 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:20:19,489 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'items.append({
                    "source": "pumpfun",
                    "symbol": sym,
                    "name": name,
                    "holders": None,             # not in public feed
                    "mcap_usd": c.get("market_cap") or c.get("mcap") or None,
                    "liquidity_usd": c.get("liquidity_usd") or c.get("liquidity") or None,
                    "age_min": age_min,
                })
            logging.info("[FETCH] Pump.fun yielded %s items", len(items))
            break
        else:
            if status:
                logging.warning("Pump.fun returned HTTP %s", status)
            else:
                logging.warning("Pump.fun request failed without HTTP status")
    if not items:
        logging.error("[FETCH] All Pump.fun endpoints failed")
    return items
--- END PATCH ---

NOTES:
- No response is expected to this patch message.
- It strengthens only Pump.fun; Dexscreener remains on the search endpoint.'
2025-08-10 14:20:31,978 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:20:31,979 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121297, 'message': {'message_id': 4314, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835631, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:20:31,979 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:20:31,979 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 14:20:31,979 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:20:31,979 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:20:32,100 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:20:33,747 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:20:37,215 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:20:37,215 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:20:37,215 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:20:47,135 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:20:47,135 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121298, 'message': {'message_id': 4316, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835647, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:20:47,135 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:20:47,135 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:20:47,135 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:20:47,136 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:20:47,275 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:20:49,410 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:20:52,639 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:20:52,639 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:20:52,639 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:20:52,736 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:20:52,742 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:20:52,743 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:20:58,059 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:20:58,060 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121299, 'message': {'message_id': 4318, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835657, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:20:58,060 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:20:58,060 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 14:20:58,060 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 14:20:58,478 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 14:24:30,910 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:24:30,910 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121300, 'message': {'message_id': 4320, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835870, 'text': '/assistant micro-patch: Pump.fun cache-buster + h2 + slightly higher retries\n\nFILE: data_fetcher.py\n--- BEGIN PATCH ---\n# inside _fetch_json_hardened(...) replace the client and request section with:\n\n    for attempt in range(retries):\n        try:\n            # jittered cache-buster each attempt\n            _params = dict(params or {})\n            _params["_"] = f"{int(time.time()*1000)}-{random.randint(1000,9999)}"\n\n            # HTTP/2 often behaves better through some CDNs\n            with httpx.Client(\n                timeout=timeout,\n                headers=_DEFAULT_HEADERS,\n                follow_redirects=True,\n                http2=True,\n            ) as client:\n                resp = client.get(url, params=_params)\n                sc = resp.status_code\n                if sc == 200:\n                    try:\n                        return sc, resp.json()\n                    except Exception as je:\n                        last_exc = je\n                        sc = 599\n                if sc in (429,) or 500 <= sc < 600 or sc == 530:\n                    pass\n                else:\n                    return sc, None\n        except Exception as e:\n            last_exc = e\n        if attempt < retries - 1:\n            base = 0.5 * (2 ** attempt)  # a hair longer than before\n            time.sleep(base + random.uniform(0.05, 0.35))\n--- END PATCH ---\n\nNOTES:\n- No reply expected to this message.\n- After it lands, try: /fetch_source pumpfun  then /fetch_now\n- If the edge is still hard-down, you’ll still see “All Pump.fun endpoints failed” (expected).', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 24, 'length': 8, 'type': 'url'}, {'offset': 1441, 'length': 13, 'type': 'bot_command'}, {'offset': 1469, 'length': 10, 'type': 'bot_command'}, {'offset': 1536, 'length': 8, 'type': 'url'}]}}
2025-08-10 14:24:30,911 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:24:30,911 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant micro-patch: Pump.fun cache-buster + h2 + slightly higher retries

FILE: data_fetcher.py
--- BEGIN PATCH ---
# inside _fetch_json_hardened(...) replace the client and request section with:

    for attempt in range(retries):
        try:
            # jittered cache-buster each attempt
            _params = dict(params or {})
            _params["_"] = f"{int(time.time()*1000)}-{random.randint(1000,9999)}"

            # HTTP/2 often behaves better through some CDNs
            with httpx.Client(
                timeout=timeout,
                headers=_DEFAULT_HEADERS,
                follow_redirects=True,
                http2=True,
            ) as client:
                resp = client.get(url, params=_params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass
                else:
                    return sc, None
        except Exception as e:
            last_exc = e
        if attempt < retries - 1:
            base = 0.5 * (2 ** attempt)  # a hair longer than before
            time.sleep(base + random.uniform(0.05, 0.35))
--- END PATCH ---

NOTES:
- No reply expected to this message.
- After it lands, try: /fetch_source pumpfun  then /fetch_now
- If the edge is still hard-down, you’ll still see “All Pump.fun endpoints failed” (expected).'
2025-08-10 14:24:30,911 [INFO] app: [WEBHOOK] Admin command detected: /assistant micro-patch: Pump.fun cache-buster + h2 + slightly higher retries

FILE: data_fetcher.py
--- BEGIN PATCH ---
# inside _fetch_json_hardened(...) replace the client and request section with:

    for attempt in range(retries):
        try:
            # jittered cache-buster each attempt
            _params = dict(params or {})
            _params["_"] = f"{int(time.time()*1000)}-{random.randint(1000,9999)}"

            # HTTP/2 often behaves better through some CDNs
            with httpx.Client(
                timeout=timeout,
                headers=_DEFAULT_HEADERS,
                follow_redirects=True,
                http2=True,
            ) as client:
                resp = client.get(url, params=_params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass
                else:
                    return sc, None
        except Exception as e:
            last_exc = e
        if attempt < retries - 1:
            base = 0.5 * (2 ** attempt)  # a hair longer than before
            time.sleep(base + random.uniform(0.05, 0.35))
--- END PATCH ---

NOTES:
- No reply expected to this message.
- After it lands, try: /fetch_source pumpfun  then /fetch_now
- If the edge is still hard-down, you’ll still see “All Pump.fun endpoints failed” (expected).
2025-08-10 14:24:30,911 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 14:24:32,285 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 14:24:32,655 [INFO] app: [WEBHOOK] Command '/assistant micro-patch: Pump.fun cache-buster + h2 + slightly higher retries

FILE: data_fetcher.py
--- BEGIN PATCH ---
# inside _fetch_json_hardened(...) replace the client and request section with:

    for attempt in range(retries):
        try:
            # jittered cache-buster each attempt
            _params = dict(params or {})
            _params["_"] = f"{int(time.time()*1000)}-{random.randint(1000,9999)}"

            # HTTP/2 often behaves better through some CDNs
            with httpx.Client(
                timeout=timeout,
                headers=_DEFAULT_HEADERS,
                follow_redirects=True,
                http2=True,
            ) as client:
                resp = client.get(url, params=_params)
                sc = resp.status_code
                if sc == 200:
                    try:
                        return sc, resp.json()
                    except Exception as je:
                        last_exc = je
                        sc = 599
                if sc in (429,) or 500 <= sc < 600 or sc == 530:
                    pass
                else:
                    return sc, None
        except Exception as e:
            last_exc = e
        if attempt < retries - 1:
            base = 0.5 * (2 ** attempt)  # a hair longer than before
            time.sleep(base + random.uniform(0.05, 0.35))
--- END PATCH ---

NOTES:
- No reply expected to this message.
- After it lands, try: /fetch_source pumpfun  then /fetch_now
- If the edge is still hard-down, you’ll still see “All Pump.fun endpoints failed” (expected).' processed, response sent: 200
2025-08-10 14:24:44,010 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:24:44,010 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121301, 'message': {'message_id': 4322, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835883, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:24:44,011 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:24:44,011 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 14:24:44,011 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 14:24:44,011 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:24:44,143 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:24:46,160 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 14:24:49,307 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:24:49,308 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:24:49,308 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 14:25:06,382 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:25:06,382 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121302, 'message': {'message_id': 4324, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835906, 'text': '/a_logs_tail level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:25:06,382 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:25:06,382 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail level=info'
2025-08-10 14:25:06,382 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail level=info
2025-08-10 14:25:06,807 [INFO] app: [WEBHOOK] Command '/a_logs_tail level=info' processed, response sent: 200
2025-08-10 14:25:30,335 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:25:30,335 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121303, 'message': {'message_id': 4326, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754835930, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:25:30,335 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:25:30,335 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:25:30,335 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:25:30,336 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:25:30,431 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:25:32,395 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:25:35,970 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:25:35,971 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:25:35,971 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:25:36,194 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:25:36,201 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:25:36,202 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:29:17,862 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:29:17,863 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121304, 'message': {'message_id': 4328, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836157, 'text': '/assistant Add early-coverage dexscreener fallback (yellow tag) when Pump.fun is down\n\nFILES: data_fetcher.py, alerts/telegram.py\n--- BEGIN PATCH data_fetcher.py ---\n# 1) Add a tiny helper near your other fetchers\ndef _freshness_score_dxs(item):\n    # smaller is fresher\n    try:\n        v = float(item.get("volumeUsd", {}).get("h24") or 0)\n    except Exception:\n        v = 0.0\n    try:\n        liq = float(item.get("liquidity", {}).get("usd") or 0)\n    except Exception:\n        liq = 0.0\n    try:\n        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)\n    except Exception:\n        mc = 0.0\n    try:\n        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)\n    except Exception:\n        tx = 0.0\n    # prefer tiny / sleepy pairs first\n    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0\n\ndef fetch_candidates_from_dexscreener_early(limit=80):\n    """\n    Heuristic \'very-new-ish\' coverage from Dexscreener search when Pump.fun is unavailable.\n    Picks low-liquidity/low-volume/low-txn pairs and tags them as \'dexscreener-new\'.\n    """\n    url = "https://api.dexscreener.com/latest/dex/search"\n    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)\n    if sc != 200 or not js or not js.get("pairs"):\n        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)\n        return []\n    pairs = js["pairs"]\n    # sort by our freshness score (ascending == fresher)\n    pairs.sort(key=_freshness_score_dxs)\n    out = []\n    now_ms = int(time.time() * 1000)\n    for p in pairs[:limit]:\n        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"\n        name = p.get("baseToken", {}).get("name") or "?"\n        liq = (p.get("liquidity", {}) or {}).get("usd")\n        mcap = p.get("fdv") or p.get("marketCap")\n        # try to compute age if pairCreatedAt present\n        try:\n            created = int(p.get("pairCreatedAt") or 0)\n            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None\n        except Exception:\n            age_min = None\n        out.append({\n            "source": "dexscreener-new",\n            "symbol": symbol,\n            "name": name,\n            "liquidity_usd": float(liq) if liq else None,\n            "mcap_usd": float(mcap) if mcap else None,\n            "age_min": age_min,\n        })\n    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))\n    return out\n\n# 2) In your main fetch/merge path (where you build all_items), add AFTER Pump.fun block:\n    # If Pump.fun produced nothing, top-up with early-coverage from Dexscreener\n    try:\n        if not any(it.get("source") == "pumpfun" for it in all_items):\n            early = fetch_candidates_from_dexscreener_early(limit=80)\n            all_items.extend(early)\n    except Exception as e:\n        logging.warning("[FETCH] Dexscreener-early error: %s", e)\n--- END PATCH ---\n\n--- BEGIN PATCH alerts/telegram.py ---\n# 3) In the table rendering where you currently set _src_label,\n#    add a yellow dot for \'dexscreener-new\'. Keep green for pumpfun.\n\n# Find the line that builds _src_label, replace with:\nsrc = (row.get("source") or "").lower()\nif src == "pumpfun":\n    _src_label = "🟢 pumpfun"\nelif src == "dexscreener-new":\n    _src_label = "🟡 dxs-new"\nelse:\n    _src_label = src or "dexscreener"\n\n# Make sure the first printed column uses _src_label (it already does in your build).\n--- END PATCH ---\n\nNOTES:\n- No reply expected.\n- Then run: /fetch_now\n- Also try: /fetch_source dexscreener (to see raw search) and /a_logs_tail 120 level=info', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 69, 'length': 8, 'type': 'url'}, {'offset': 118, 'length': 11, 'type': 'url'}, {'offset': 1055, 'length': 8, 'type': 'url'}, {'offset': 1184, 'length': 45, 'type': 'url'}, {'offset': 1377, 'length': 12, 'type': 'url'}, {'offset': 2512, 'length': 12, 'type': 'url'}, {'offset': 2671, 'length': 8, 'type': 'url'}, {'offset': 2696, 'length': 8, 'type': 'url'}, {'offset': 3088, 'length': 11, 'type': 'url'}, {'offset': 3156, 'length': 10, 'type': 'code'}, {'offset': 3634, 'length': 10, 'type': 'bot_command'}, {'offset': 3657, 'length': 13, 'type': 'bot_command'}, {'offset': 3707, 'length': 12, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 14:29:17,863 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:29:17,863 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Add early-coverage dexscreener fallback (yellow tag) when Pump.fun is down

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add a tiny helper near your other fetchers
def _freshness_score_dxs(item):
    # smaller is fresher
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    # prefer tiny / sleepy pairs first
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic 'very-new-ish' coverage from Dexscreener search when Pump.fun is unavailable.
    Picks low-liquidity/low-volume/low-txn pairs and tags them as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    # sort by our freshness score (ascending == fresher)
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        # try to compute age if pairCreatedAt present
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In your main fetch/merge path (where you build all_items), add AFTER Pump.fun block:
    # If Pump.fun produced nothing, top-up with early-coverage from Dexscreener
    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) In the table rendering where you currently set _src_label,
#    add a yellow dot for 'dexscreener-new'. Keep green for pumpfun.

# Find the line that builds _src_label, replace with:
src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src == "dexscreener-new":
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# Make sure the first printed column uses _src_label (it already does in your build).
--- END PATCH ---

NOTES:
- No reply expected.
- Then run: /fetch_now
- Also try: /fetch_source dexscreener (to see raw search) and /a_logs_tail 120 level=info'
2025-08-10 14:29:17,863 [INFO] app: [WEBHOOK] Admin command detected: /assistant Add early-coverage dexscreener fallback (yellow tag) when Pump.fun is down

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add a tiny helper near your other fetchers
def _freshness_score_dxs(item):
    # smaller is fresher
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    # prefer tiny / sleepy pairs first
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic 'very-new-ish' coverage from Dexscreener search when Pump.fun is unavailable.
    Picks low-liquidity/low-volume/low-txn pairs and tags them as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    # sort by our freshness score (ascending == fresher)
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        # try to compute age if pairCreatedAt present
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In your main fetch/merge path (where you build all_items), add AFTER Pump.fun block:
    # If Pump.fun produced nothing, top-up with early-coverage from Dexscreener
    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) In the table rendering where you currently set _src_label,
#    add a yellow dot for 'dexscreener-new'. Keep green for pumpfun.

# Find the line that builds _src_label, replace with:
src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src == "dexscreener-new":
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# Make sure the first printed column uses _src_label (it already does in your build).
--- END PATCH ---

NOTES:
- No reply expected.
- Then run: /fetch_now
- Also try: /fetch_source dexscreener (to see raw search) and /a_logs_tail 120 level=info
2025-08-10 14:29:17,864 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 14:29:20,436 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 14:29:20,831 [INFO] app: [WEBHOOK] Command '/assistant Add early-coverage dexscreener fallback (yellow tag) when Pump.fun is down

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add a tiny helper near your other fetchers
def _freshness_score_dxs(item):
    # smaller is fresher
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    # prefer tiny / sleepy pairs first
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic 'very-new-ish' coverage from Dexscreener search when Pump.fun is unavailable.
    Picks low-liquidity/low-volume/low-txn pairs and tags them as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    # sort by our freshness score (ascending == fresher)
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        # try to compute age if pairCreatedAt present
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In your main fetch/merge path (where you build all_items), add AFTER Pump.fun block:
    # If Pump.fun produced nothing, top-up with early-coverage from Dexscreener
    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) In the table rendering where you currently set _src_label,
#    add a yellow dot for 'dexscreener-new'. Keep green for pumpfun.

# Find the line that builds _src_label, replace with:
src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src == "dexscreener-new":
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# Make sure the first printed column uses _src_label (it already does in your build).
--- END PATCH ---

NOTES:
- No reply expected.
- Then run: /fetch_now
- Also try: /fetch_source dexscreener (to see raw search) and /a_logs_tail 120 level=info' processed, response sent: 200
2025-08-10 14:29:35,979 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:29:35,979 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121305, 'message': {'message_id': 4330, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836175, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:29:35,979 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:29:35,980 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:29:35,980 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:29:35,980 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:29:36,102 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:29:38,305 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:29:41,838 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:29:41,838 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:29:41,839 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:29:42,026 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:29:42,027 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:29:42,027 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:30:50,904 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:30:50,907 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121306, 'message': {'message_id': 4332, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836250, 'text': '/a_logs_tail level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:30:50,907 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:30:50,907 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail level=info'
2025-08-10 14:30:50,908 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail level=info
2025-08-10 14:30:51,333 [INFO] app: [WEBHOOK] Command '/a_logs_tail level=info' processed, response sent: 200
2025-08-10 14:37:27,499 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:37:27,500 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:37:27,500 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:37:27,528 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:37:29,198 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:37:45,536 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:37:45,536 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121307, 'message': {'message_id': 4334, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836665, 'text': '/assistant Wire Dexscreener "early" fallback + label and a test route\n\nFILES: data_fetcher.py, alerts/telegram.py, app.py\n--- BEGIN PATCH data_fetcher.py ---\n# 1) Add (or keep) the early-coverage helper near your other fetchers.\n\ndef _freshness_score_dxs(item):\n    try:\n        v = float(item.get("volumeUsd", {}).get("h24") or 0)\n    except Exception:\n        v = 0.0\n    try:\n        liq = float(item.get("liquidity", {}).get("usd") or 0)\n    except Exception:\n        liq = 0.0\n    try:\n        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)\n    except Exception:\n        mc = 0.0\n    try:\n        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)\n    except Exception:\n        tx = 0.0\n    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0  # smaller=fresher\n\ndef fetch_candidates_from_dexscreener_early(limit=80):\n    """\n    Heuristic coverage when Pump.fun is down. Tags rows as \'dexscreener-new\'.\n    """\n    url = "https://api.dexscreener.com/latest/dex/search"\n    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)\n    if sc != 200 or not js or not js.get("pairs"):\n        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)\n        return []\n    pairs = js["pairs"]\n    pairs.sort(key=_freshness_score_dxs)\n    out = []\n    now_ms = int(time.time() * 1000)\n    for p in pairs[:limit]:\n        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"\n        name = p.get("baseToken", {}).get("name") or "?"\n        liq = (p.get("liquidity", {}) or {}).get("usd")\n        mcap = p.get("fdv") or p.get("marketCap")\n        try:\n            created = int(p.get("pairCreatedAt") or 0)\n            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None\n        except Exception:\n            age_min = None\n        out.append({\n            "source": "dexscreener-new",\n            "symbol": symbol,\n            "name": name,\n            "liquidity_usd": float(liq) if liq else None,\n            "mcap_usd": float(mcap) if mcap else None,\n            "age_min": age_min,\n        })\n    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))\n    return out\n\n# 2) In the main merge logic (where all_items is built), AFTER the Pump.fun section,\n#    ensure we top-up from early if Pump.fun produced nothing:\n\n    try:\n        if not any(it.get("source") == "pumpfun" for it in all_items):\n            early = fetch_candidates_from_dexscreener_early(limit=80)\n            all_items.extend(early)\n    except Exception as e:\n        logging.warning("[FETCH] Dexscreener-early error: %s", e)\n--- END PATCH ---\n\n--- BEGIN PATCH alerts/telegram.py ---\n# 3) Ensure the source label shows a yellow dot for dexscreener-early.\n#    Find where _src_label is computed for table rows and replace with:\n\nsrc = (row.get("source") or "").lower()\nif src == "pumpfun":\n    _src_label = "🟢 pumpfun"\nelif src in ("dexscreener-new", "dxs-new"):\n    _src_label = "🟡 dxs-new"\nelse:\n    _src_label = src or "dexscreener"\n\n# (Column building already prints _src_label as the first column.)\n--- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 102, 'length': 11, 'type': 'url'}, {'offset': 115, 'length': 6, 'type': 'url'}, {'offset': 987, 'length': 8, 'type': 'url'}, {'offset': 1056, 'length': 45, 'type': 'url'}, {'offset': 1249, 'length': 12, 'type': 'url'}, {'offset': 2273, 'length': 12, 'type': 'url'}, {'offset': 2394, 'length': 9, 'type': 'code'}, {'offset': 2425, 'length': 8, 'type': 'url'}, {'offset': 2479, 'length': 8, 'type': 'url'}, {'offset': 2828, 'length': 11, 'type': 'url'}, {'offset': 2931, 'length': 10, 'type': 'code'}, {'offset': 3232, 'length': 10, 'type': 'code'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 14:37:45,536 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:37:45,536 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Wire Dexscreener "early" fallback + label and a test route

FILES: data_fetcher.py, alerts/telegram.py, app.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add (or keep) the early-coverage helper near your other fetchers.

def _freshness_score_dxs(item):
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0  # smaller=fresher

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic coverage when Pump.fun is down. Tags rows as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In the main merge logic (where all_items is built), AFTER the Pump.fun section,
#    ensure we top-up from early if Pump.fun produced nothing:

    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) Ensure the source label shows a yellow dot for dexscreener-early.
#    Find where _src_label is computed for table rows and replace with:

src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src in ("dexscreener-new", "dxs-new"):
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# (Column building already prints _src_label as the first column.)
--- END PATCH ---'
2025-08-10 14:37:45,537 [INFO] app: [WEBHOOK] Admin command detected: /assistant Wire Dexscreener "early" fallback + label and a test route

FILES: data_fetcher.py, alerts/telegram.py, app.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add (or keep) the early-coverage helper near your other fetchers.

def _freshness_score_dxs(item):
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0  # smaller=fresher

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic coverage when Pump.fun is down. Tags rows as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In the main merge logic (where all_items is built), AFTER the Pump.fun section,
#    ensure we top-up from early if Pump.fun produced nothing:

    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) Ensure the source label shows a yellow dot for dexscreener-early.
#    Find where _src_label is computed for table rows and replace with:

src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src in ("dexscreener-new", "dxs-new"):
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# (Column building already prints _src_label as the first column.)
--- END PATCH ---
2025-08-10 14:37:45,537 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 14:37:45,541 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:37:45,661 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:37:55,722 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 14:37:56,126 [INFO] app: [WEBHOOK] Command '/assistant Wire Dexscreener "early" fallback + label and a test route

FILES: data_fetcher.py, alerts/telegram.py, app.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Add (or keep) the early-coverage helper near your other fetchers.

def _freshness_score_dxs(item):
    try:
        v = float(item.get("volumeUsd", {}).get("h24") or 0)
    except Exception:
        v = 0.0
    try:
        liq = float(item.get("liquidity", {}).get("usd") or 0)
    except Exception:
        liq = 0.0
    try:
        mc = float(item.get("fdv") or 0) or float(item.get("marketCap") or 0)
    except Exception:
        mc = 0.0
    try:
        tx = float(item.get("txns", {}).get("h24", {}).get("buys") or 0) + float(item.get("txns", {}).get("h24", {}).get("sells") or 0)
    except Exception:
        tx = 0.0
    return (v or 0) * 1.0 + (liq or 0) * 0.5 + (mc or 0) * 0.25 + (tx or 0) * 100.0  # smaller=fresher

def fetch_candidates_from_dexscreener_early(limit=80):
    """
    Heuristic coverage when Pump.fun is down. Tags rows as 'dexscreener-new'.
    """
    url = "https://api.dexscreener.com/latest/dex/search"
    sc, js = _fetch_json_hardened(url, params={"q": "solana"}, retries=3, timeout=8.0)
    if sc != 200 or not js or not js.get("pairs"):
        logging.info("[FETCH] Dexscreener-early returned 0 (sc=%s)", sc)
        return []
    pairs = js["pairs"]
    pairs.sort(key=_freshness_score_dxs)
    out = []
    now_ms = int(time.time() * 1000)
    for p in pairs[:limit]:
        symbol = p.get("baseToken", {}).get("symbol") or p.get("baseToken", {}).get("name") or p.get("baseToken", {}).get("address") or "?"
        name = p.get("baseToken", {}).get("name") or "?"
        liq = (p.get("liquidity", {}) or {}).get("usd")
        mcap = p.get("fdv") or p.get("marketCap")
        try:
            created = int(p.get("pairCreatedAt") or 0)
            age_min = int((now_ms - created) / 60000) if created and created < now_ms else None
        except Exception:
            age_min = None
        out.append({
            "source": "dexscreener-new",
            "symbol": symbol,
            "name": name,
            "liquidity_usd": float(liq) if liq else None,
            "mcap_usd": float(mcap) if mcap else None,
            "age_min": age_min,
        })
    logging.info("[FETCH] Dexscreener-early yielded %d items", len(out))
    return out

# 2) In the main merge logic (where all_items is built), AFTER the Pump.fun section,
#    ensure we top-up from early if Pump.fun produced nothing:

    try:
        if not any(it.get("source") == "pumpfun" for it in all_items):
            early = fetch_candidates_from_dexscreener_early(limit=80)
            all_items.extend(early)
    except Exception as e:
        logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 3) Ensure the source label shows a yellow dot for dexscreener-early.
#    Find where _src_label is computed for table rows and replace with:

src = (row.get("source") or "").lower()
if src == "pumpfun":
    _src_label = "🟢 pumpfun"
elif src in ("dexscreener-new", "dxs-new"):
    _src_label = "🟡 dxs-new"
else:
    _src_label = src or "dexscreener"

# (Column building already prints _src_label as the first column.)
--- END PATCH ---' processed, response sent: 200
2025-08-10 14:37:56,256 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:37:56,256 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121308, 'message': {'message_id': 4335, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836665, 'text': '--- BEGIN PATCH alerts/telegram.py (new command) ---\n# 4) Add a quick test command handler to show ONLY the early list.\nasync def cmd_fetch_source_dxs_early(update, context):\n    try:\n        from data_fetcher import fetch_candidates_from_dexscreener_early\n        items = fetch_candidates_from_dexscreener_early(limit=40)\n        rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n        for t in items[:15]:\n            rows.append([\n                "🟡 dxs-new",\n                t.get("symbol") or "?",\n                t.get("name") or "?",\n                t.get("holders") if t.get("holders") is not None else "-",\n                f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                t.get("age_min") if t.get("age_min") is not None else "-",\n            ])\n        txt = _format_table(rows, title="Dexscreener early (🟡)")\n        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n        return "ok"\n    except Exception as e:\n        logging.exception("dxs early cmd error")\n        await update.message.reply_text(f"❌ dxs-early failed: {e}")\n        return "ok"\n--- END PATCH ---\n\n--- BEGIN PATCH app.py ---\n# 5) Route the new test command in the Flask webhook block (admin-only),\n#    alongside your other manual routes, BEFORE the unknown/fallback branch:\n\nif text.startswith("/fetch_source dexscreener_early"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        _reply("Not authorized."); return "ok"\n    from alerts.telegram import cmd_fetch_source_dxs_early\n    _reply(await cmd_fetch_source_dxs_early(update, None)); return "ok"\n--- END PATCH ---\n\nNOTES:\n- No response expected to this patch.\n- After it lands: send /fetch_source dexscreener_early  (you should see 🟡 dxs-new rows)\n- Then send /fetch_now  (if Pump.fun still 530, table may include 🟡 dxs-new entries)\n- Check /a_logs_tail 120 level=info for "[FETCH] Dexscreener-early yielded N items".', 'entities': [{'offset': 23, 'length': 11, 'type': 'url'}, {'offset': 1326, 'length': 6, 'type': 'url'}, {'offset': 1508, 'length': 13, 'type': 'bot_command'}, {'offset': 1890, 'length': 13, 'type': 'bot_command'}, {'offset': 1968, 'length': 10, 'type': 'bot_command'}, {'offset': 1984, 'length': 8, 'type': 'url'}, {'offset': 2050, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:37:56,256 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:37:56,256 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '--- BEGIN PATCH alerts/telegram.py (new command) ---
# 4) Add a quick test command handler to show ONLY the early list.
async def cmd_fetch_source_dxs_early(update, context):
    try:
        from data_fetcher import fetch_candidates_from_dexscreener_early
        items = fetch_candidates_from_dexscreener_early(limit=40)
        rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
        for t in items[:15]:
            rows.append([
                "🟡 dxs-new",
                t.get("symbol") or "?",
                t.get("name") or "?",
                t.get("holders") if t.get("holders") is not None else "-",
                f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                t.get("age_min") if t.get("age_min") is not None else "-",
            ])
        txt = _format_table(rows, title="Dexscreener early (🟡)")
        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        return "ok"
    except Exception as e:
        logging.exception("dxs early cmd error")
        await update.message.reply_text(f"❌ dxs-early failed: {e}")
        return "ok"
--- END PATCH ---

--- BEGIN PATCH app.py ---
# 5) Route the new test command in the Flask webhook block (admin-only),
#    alongside your other manual routes, BEFORE the unknown/fallback branch:

if text.startswith("/fetch_source dexscreener_early"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        _reply("Not authorized."); return "ok"
    from alerts.telegram import cmd_fetch_source_dxs_early
    _reply(await cmd_fetch_source_dxs_early(update, None)); return "ok"
--- END PATCH ---

NOTES:
- No response expected to this patch.
- After it lands: send /fetch_source dexscreener_early  (you should see 🟡 dxs-new rows)
- Then send /fetch_now  (if Pump.fun still 530, table may include 🟡 dxs-new entries)
- Check /a_logs_tail 120 level=info for "[FETCH] Dexscreener-early yielded N items".'
2025-08-10 14:39:03,304 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:39:03,305 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:39:03,305 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:39:03,308 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:39:04,140 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:39:13,549 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:39:13,550 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121309, 'message': {'message_id': 4337, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836753, 'text': '/fetch_source dexscreener_early', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:39:13,550 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:39:13,551 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener_early'
2025-08-10 14:39:13,551 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener_early
2025-08-10 14:39:13,551 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:39:13,552 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:39:13,612 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:39:30,084 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:39:30,084 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121310, 'message': {'message_id': 4338, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836769, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:39:30,084 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:39:30,085 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:39:30,085 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:39:30,085 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:39:30,151 [INFO] root: [RULES] Loaded (v1)
2025-08-10 14:39:30,267 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:39:31,974 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:39:35,458 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:39:35,459 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:39:35,463 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:39:35,693 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:39:35,695 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:39:35,695 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:39:55,800 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:39:55,801 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121311, 'message': {'message_id': 4340, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754836795, 'text': '/a_logs_tail level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:39:55,801 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:39:55,801 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail level=info'
2025-08-10 14:39:55,801 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail level=info
2025-08-10 14:39:56,219 [INFO] app: [WEBHOOK] Command '/a_logs_tail level=info' processed, response sent: 200
2025-08-10 14:43:42,119 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:43:42,119 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121312, 'message': {'message_id': 4342, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754837021, 'text': '/assistant Ensure early-fallback is used and labeled 🟡\n\nFILES: data_fetcher.py, alerts/telegram.py\n--- BEGIN PATCH data_fetcher.py ---\n# 1) Guarantee early fallback is actually appended when Pump.fun yields none.\n#    Place this AFTER the Pump.fun block, BEFORE ranking/sorting.\n\ntry:\n    # If Pump.fun produced nothing, top up from Dexscreener early\n    if not any((it.get("source") or "").lower() == "pumpfun" for it in all_items):\n        from data_fetcher import fetch_candidates_from_dexscreener_early\n        early = fetch_candidates_from_dexscreener_early(limit=80)\n        all_items.extend(early)\nexcept Exception as e:\n    logging.warning("[FETCH] Dexscreener-early error: %s", e)\n--- END PATCH ---\n\n--- BEGIN PATCH alerts/telegram.py ---\n# 2) Centralize source → label mapping and use it everywhere we render rows.\n\n# Add near other helpers:\ndef _src_to_label(src: str) -> str:\n    s = (src or "").lower()\n    if s == "pumpfun":\n        return "🟢 pumpfun"\n    if s in ("dexscreener-new", "dxs-new"):\n        return "🟡 dxs-new"\n    return s or "dexscreener"\n\n# Find ALL places we build table rows (both /fetch_now and /fetch_source handlers)\n# and replace the first column expression. For example, change:\n#   (row.get("source") or "dexscreener"),\n# to:\n#   _src_to_label(row.get("source")),\n\n# Also in the dexscreener-early test command (if present) ensure it uses the label:\n#   rows.append([\n#       _src_to_label(t.get("source") or "dexscreener-new"),\n#       ... (rest unchanged) ...\n#   ])\n--- END PATCH ---', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 88, 'length': 11, 'type': 'url'}, {'offset': 192, 'length': 8, 'type': 'url'}, {'offset': 240, 'length': 8, 'type': 'url'}, {'offset': 295, 'length': 8, 'type': 'url'}, {'offset': 733, 'length': 11, 'type': 'url'}, {'offset': 1115, 'length': 10, 'type': 'bot_command'}, {'offset': 1130, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:43:42,119 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:43:42,120 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant Ensure early-fallback is used and labeled 🟡

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Guarantee early fallback is actually appended when Pump.fun yields none.
#    Place this AFTER the Pump.fun block, BEFORE ranking/sorting.

try:
    # If Pump.fun produced nothing, top up from Dexscreener early
    if not any((it.get("source") or "").lower() == "pumpfun" for it in all_items):
        from data_fetcher import fetch_candidates_from_dexscreener_early
        early = fetch_candidates_from_dexscreener_early(limit=80)
        all_items.extend(early)
except Exception as e:
    logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 2) Centralize source → label mapping and use it everywhere we render rows.

# Add near other helpers:
def _src_to_label(src: str) -> str:
    s = (src or "").lower()
    if s == "pumpfun":
        return "🟢 pumpfun"
    if s in ("dexscreener-new", "dxs-new"):
        return "🟡 dxs-new"
    return s or "dexscreener"

# Find ALL places we build table rows (both /fetch_now and /fetch_source handlers)
# and replace the first column expression. For example, change:
#   (row.get("source") or "dexscreener"),
# to:
#   _src_to_label(row.get("source")),

# Also in the dexscreener-early test command (if present) ensure it uses the label:
#   rows.append([
#       _src_to_label(t.get("source") or "dexscreener-new"),
#       ... (rest unchanged) ...
#   ])
--- END PATCH ---'
2025-08-10 14:43:42,120 [INFO] app: [WEBHOOK] Admin command detected: /assistant Ensure early-fallback is used and labeled 🟡

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Guarantee early fallback is actually appended when Pump.fun yields none.
#    Place this AFTER the Pump.fun block, BEFORE ranking/sorting.

try:
    # If Pump.fun produced nothing, top up from Dexscreener early
    if not any((it.get("source") or "").lower() == "pumpfun" for it in all_items):
        from data_fetcher import fetch_candidates_from_dexscreener_early
        early = fetch_candidates_from_dexscreener_early(limit=80)
        all_items.extend(early)
except Exception as e:
    logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 2) Centralize source → label mapping and use it everywhere we render rows.

# Add near other helpers:
def _src_to_label(src: str) -> str:
    s = (src or "").lower()
    if s == "pumpfun":
        return "🟢 pumpfun"
    if s in ("dexscreener-new", "dxs-new"):
        return "🟡 dxs-new"
    return s or "dexscreener"

# Find ALL places we build table rows (both /fetch_now and /fetch_source handlers)
# and replace the first column expression. For example, change:
#   (row.get("source") or "dexscreener"),
# to:
#   _src_to_label(row.get("source")),

# Also in the dexscreener-early test command (if present) ensure it uses the label:
#   rows.append([
#       _src_to_label(t.get("source") or "dexscreener-new"),
#       ... (rest unchanged) ...
#   ])
--- END PATCH ---
2025-08-10 14:43:42,120 [INFO] app: [WEBHOOK] Routing /assistant
2025-08-10 14:43:49,145 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-10 14:43:49,582 [INFO] app: [WEBHOOK] Command '/assistant Ensure early-fallback is used and labeled 🟡

FILES: data_fetcher.py, alerts/telegram.py
--- BEGIN PATCH data_fetcher.py ---
# 1) Guarantee early fallback is actually appended when Pump.fun yields none.
#    Place this AFTER the Pump.fun block, BEFORE ranking/sorting.

try:
    # If Pump.fun produced nothing, top up from Dexscreener early
    if not any((it.get("source") or "").lower() == "pumpfun" for it in all_items):
        from data_fetcher import fetch_candidates_from_dexscreener_early
        early = fetch_candidates_from_dexscreener_early(limit=80)
        all_items.extend(early)
except Exception as e:
    logging.warning("[FETCH] Dexscreener-early error: %s", e)
--- END PATCH ---

--- BEGIN PATCH alerts/telegram.py ---
# 2) Centralize source → label mapping and use it everywhere we render rows.

# Add near other helpers:
def _src_to_label(src: str) -> str:
    s = (src or "").lower()
    if s == "pumpfun":
        return "🟢 pumpfun"
    if s in ("dexscreener-new", "dxs-new"):
        return "🟡 dxs-new"
    return s or "dexscreener"

# Find ALL places we build table rows (both /fetch_now and /fetch_source handlers)
# and replace the first column expression. For example, change:
#   (row.get("source") or "dexscreener"),
# to:
#   _src_to_label(row.get("source")),

# Also in the dexscreener-early test command (if present) ensure it uses the label:
#   rows.append([
#       _src_to_label(t.get("source") or "dexscreener-new"),
#       ... (rest unchanged) ...
#   ])
--- END PATCH ---' processed, response sent: 200
2025-08-10 14:45:25,450 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:45:25,451 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:45:25,451 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:45:25,453 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:45:26,182 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:45:37,743 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:45:37,744 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121313, 'message': {'message_id': 4344, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754837137, 'text': '/fetch_source dexscreener_early', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 14:45:37,744 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:45:37,744 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source dexscreener_early'
2025-08-10 14:45:37,744 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source dexscreener_early
2025-08-10 14:45:37,744 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 14:45:37,745 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:45:37,785 [INFO] root: >>> data_fetcher LOADED df-4 <<<
2025-08-10 14:45:57,652 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:45:57,653 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121314, 'message': {'message_id': 4345, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754837157, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 14:45:57,653 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:45:57,653 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 14:45:57,653 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 14:45:57,653 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 14:45:57,670 [INFO] root: [RULES] Loaded (v1)
2025-08-10 14:45:57,789 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:45:59,473 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 14:46:02,833 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 14:46:02,833 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 14:46:02,833 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 14:46:02,950 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 14:46:02,952 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 14:46:02,952 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 14:46:25,164 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 14:46:25,164 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121315, 'message': {'message_id': 4347, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754837185, 'text': '/a_logs_tail 150 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 14:46:25,164 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:46:25,164 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 150 level=info'
2025-08-10 14:46:25,165 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 150 level=info
2025-08-10 14:46:25,670 [INFO] app: [WEBHOOK] Command '/a_logs_tail 150 level=info' processed, response sent: 200
2025-08-10 14:57:13,615 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:57:13,616 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:57:13,616 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:57:13,619 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:57:14,390 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:57:32,152 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:57:32,153 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_diag_fetch'}}
2025-08-10 14:57:32,156 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:57:32,157 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_diag_fetch'
2025-08-10 14:57:32,157 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 14:57:32,159 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:57:32,218 [INFO] root: >>> data_fetcher LOADED df-5 <<<
2025-08-10 14:57:32,232 [INFO] root: >>> data_fetcher LOADED df-5 <<<
2025-08-10 14:57:32,233 [ERROR] root: a_diag_fetch error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 648, in cmd_a_diag_fetch
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'obj' object has no attribute 'reply_text'
2025-08-10 14:57:32,601 [INFO] app: [WEBHOOK] Command '/a_diag_fetch' processed, response sent: 200
2025-08-10 14:59:03,312 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:59:03,312 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:59:03,312 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:59:03,316 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:59:04,171 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 14:59:23,775 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 14:59:23,775 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/a_diag_fetch'}}
2025-08-10 14:59:23,775 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 14:59:23,776 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/a_diag_fetch'
2025-08-10 14:59:23,776 [INFO] app: [WEBHOOK] Admin command detected: /a_diag_fetch
2025-08-10 14:59:23,777 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 14:59:23,828 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 14:59:23,837 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 14:59:23,838 [ERROR] root: a_diag_fetch error
Traceback (most recent call last):
  File "/home/runner/workspace/alerts/telegram.py", line 648, in cmd_a_diag_fetch
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'obj' object has no attribute 'reply_text'
2025-08-10 14:59:24,253 [INFO] app: [WEBHOOK] Command '/a_diag_fetch' processed, response sent: 200
2025-08-10 14:59:29,299 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:59:29,299 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 14:59:29,299 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 14:59:29,301 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 14:59:29,977 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:18:23,371 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:18:23,372 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 15:18:23,374 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:18:23,375 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 15:18:23,375 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 15:18:23,375 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 15:18:23,380 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 15:18:23,466 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 15:18:23,506 [INFO] root: [RULES] Loaded (v1)
2025-08-10 15:18:23,508 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:18:23,509 [INFO] root: [FETCH] On-chain primary: 0 ultra-fresh items
2025-08-10 15:18:23,667 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:18:25,555 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:18:28,577 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 15:18:28,578 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 15:18:28,579 [INFO] root: [FETCH] Pump.fun API: 0 items
2025-08-10 15:18:28,579 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:18:28,579 [INFO] root: [FETCH] On-chain fallback: 0 seed items
2025-08-10 15:18:28,580 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 15:18:28,694 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 15:18:28,700 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 15:18:28,701 [INFO] root: [FETCH] DexScreener: 30 items
2025-08-10 15:18:28,702 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 15:18:40,406 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:18:40,406 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:18:40,407 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:18:40,412 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:18:41,530 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:19:17,881 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:19:17,881 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:19:17,881 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:19:17,885 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:19:18,583 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:19:19,736 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:19:19,736 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:19:19,737 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:19:19,739 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:19:20,640 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:22:06,660 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:06,661 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:06,661 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:22:06,663 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:22:07,380 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:22:20,823 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:20,823 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:20,824 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:22:20,834 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:22:21,623 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:22:50,921 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:50,922 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:50,922 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:22:50,925 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:22:51,585 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:22:52,738 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:52,738 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:22:52,738 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:22:52,741 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:22:53,495 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:23:52,985 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:23:52,986 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:23:52,986 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:23:52,988 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:23:53,667 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:23:56,806 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:23:56,807 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:23:56,807 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:23:56,810 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:23:57,509 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:24:44,143 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:24:44,145 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:24:44,146 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:24:44,149 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:24:44,863 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:25:02,084 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:02,084 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:02,084 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:25:02,087 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:25:02,764 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:25:03,002 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:25:03,003 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 15:25:03,003 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:25:03,003 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/ping'
2025-08-10 15:25:03,003 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 15:25:03,416 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 15:25:21,072 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:21,072 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:21,072 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:25:21,076 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:25:21,950 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:25:23,125 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:23,126 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:25:23,126 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:25:23,129 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:25:24,194 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:25:24,561 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:25:24,562 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/status'}}
2025-08-10 15:25:24,563 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:25:24,563 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/status'
2025-08-10 15:25:24,564 [INFO] app: [WEBHOOK] Admin command detected: /status
2025-08-10 15:25:24,981 [INFO] app: [WEBHOOK] Command '/status' processed, response sent: 200
2025-08-10 15:26:44,870 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:26:44,871 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:26:44,871 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:26:44,874 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:26:45,614 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:26:47,279 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:26:47,280 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/fetch_now'}}
2025-08-10 15:26:47,281 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:26:47,281 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/fetch_now'
2025-08-10 15:26:47,281 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 15:26:47,281 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 15:26:47,282 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 15:26:47,331 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 15:26:47,358 [INFO] root: [RULES] Loaded (v1)
2025-08-10 15:26:47,359 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:26:47,359 [INFO] root: [FETCH] On-chain primary: 0 ultra-fresh items
2025-08-10 15:26:47,553 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:26:49,392 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:26:52,462 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 15:26:52,462 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 15:26:52,462 [INFO] root: [FETCH] Pump.fun API: 0 items
2025-08-10 15:26:52,463 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:26:52,463 [INFO] root: [FETCH] On-chain fallback: 0 seed items
2025-08-10 15:26:52,463 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 15:26:52,632 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 15:26:52,636 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 15:26:52,636 [INFO] root: [FETCH] DexScreener: 30 items
2025-08-10 15:26:52,637 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 15:26:56,003 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:26:56,004 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:26:56,004 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:26:56,007 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:26:56,844 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:27:49,215 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:27:49,215 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:27:49,215 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:27:49,218 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:27:49,917 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:28:52,431 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:28:52,432 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:28:52,432 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:28:52,434 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:28:53,109 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:28:55,246 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:28:55,246 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:28:55,246 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:28:55,250 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:28:56,111 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:28:56,692 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:28:56,692 [INFO] app: [WEBHOOK] Update data: {'message': {'from': {'id': 1653046781, 'username': 'admin'}, 'chat': {'id': 1653046781}, 'text': '/ping'}}
2025-08-10 15:28:56,692 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:28:56,692 [INFO] app: [WEBHOOK] Message from admin (1653046781): '/ping'
2025-08-10 15:28:56,692 [INFO] app: [WEBHOOK] Admin command detected: /ping
2025-08-10 15:28:57,247 [INFO] app: [WEBHOOK] Command '/ping' processed, response sent: 200
2025-08-10 15:29:58,682 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:29:58,682 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:29:58,682 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:29:58,686 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:29:59,558 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:30:00,718 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:00,719 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:00,719 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:30:00,721 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:30:01,507 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:30:03,689 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:03,689 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:03,690 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:30:03,694 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:30:04,538 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:30:27,476 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:27,476 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:30:27,476 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:30:27,479 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:30:28,256 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:33:08,538 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:33:08,539 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:33:08,539 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:33:08,545 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:33:09,915 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:33:48,814 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:33:48,814 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:33:48,814 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:33:48,817 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:33:49,636 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:36:23,406 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:36:23,406 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:36:23,407 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:36:23,410 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:36:24,479 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:40:37,206 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:40:37,206 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:40:37,206 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:40:37,210 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:40:37,876 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:41:00,981 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:41:00,981 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:41:00,981 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:41:00,984 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:41:01,690 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:44:47,809 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:44:47,812 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:44:47,813 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:44:47,818 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:44:48,686 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 15:48:13,663 [INFO] app: [WEBHOOK] Received POST request from 127.0.0.1
2025-08-10 15:48:13,663 [INFO] app: [WEBHOOK] Update data: {'update_id': 12345, 'message': {'message_id': 678, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Admin'}, 'chat': {'id': 1653046781, 'type': 'private'}, 'date': 1754840893, 'text': '/fetch_now'}}
2025-08-10 15:48:13,663 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:48:13,663 [INFO] app: [WEBHOOK] Message from unknown (1653046781): '/fetch_now'
2025-08-10 15:48:13,664 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 15:48:13,664 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 15:48:13,665 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 15:48:13,702 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 15:48:13,770 [INFO] root: [RULES] Loaded (v1)
2025-08-10 15:48:13,863 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:48:14,542 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:48:15,604 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:48:15,607 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:48:15,607 [INFO] root: [FETCH] On-chain primary: 0 ultra-fresh items
2025-08-10 15:48:15,722 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:48:17,765 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:48:20,928 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 15:48:20,929 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 15:48:20,929 [INFO] root: [FETCH] Pump.fun API: 0 items
2025-08-10 15:48:20,930 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:48:20,930 [INFO] root: [FETCH] On-chain fallback: 0 seed items
2025-08-10 15:48:20,930 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 15:48:21,042 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 15:48:21,045 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 15:48:21,045 [INFO] root: [FETCH] DexScreener: 30 items
2025-08-10 15:48:21,045 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 15:51:01,961 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 15:51:01,962 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121316, 'message': {'message_id': 4357, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754841061, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 15:51:01,962 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 15:51:01,962 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 15:51:01,962 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 15:51:01,962 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 15:51:02,078 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:51:02,871 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:51:04,014 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:51:04,015 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:51:04,016 [INFO] root: [FETCH] On-chain primary: 0 ultra-fresh items
2025-08-10 15:51:04,142 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:51:06,074 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 15:51:09,484 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 15:51:09,484 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 15:51:09,484 [INFO] root: [FETCH] Pump.fun API: 0 items
2025-08-10 15:51:09,485 [WARNING] root: [CHAIN] Missing PUMPFUN_PROGRAM_ID or SOLANA_RPC_HTTP
2025-08-10 15:51:09,485 [INFO] root: [FETCH] On-chain fallback: 0 seed items
2025-08-10 15:51:09,485 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 15:51:09,596 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 15:51:09,598 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 15:51:09,598 [INFO] root: [FETCH] DexScreener: 30 items
2025-08-10 15:51:09,598 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 15:59:45,849 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:59:45,849 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 15:59:45,850 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 15:59:45,865 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 15:59:47,244 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:00:17,087 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 16:00:17,087 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121317, 'message': {'message_id': 4359, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754841616, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 16:00:17,088 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 16:00:17,088 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 16:00:17,088 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 16:00:17,088 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 16:00:17,094 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 16:00:17,215 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 16:00:17,402 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 16:00:19,165 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 16:00:22,686 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 16:00:22,687 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 16:00:22,687 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 16:06:05,317 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:06:05,317 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:06:05,317 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:06:05,320 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:06:05,958 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:09:15,829 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:09:15,829 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:09:15,829 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:09:15,832 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:09:16,514 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:09:36,106 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:09:36,106 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:09:36,106 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:09:36,109 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:09:36,774 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:10:10,574 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:10:10,575 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:10:10,575 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:10:10,577 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:10:11,295 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:10:23,051 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 16:10:23,052 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121318, 'message': {'message_id': 4361, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754842222, 'text': '/pumpfun_status', 'entities': [{'offset': 0, 'length': 15, 'type': 'bot_command'}]}}
2025-08-10 16:10:23,052 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 16:10:23,053 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/pumpfun_status'
2025-08-10 16:10:23,054 [INFO] app: [WEBHOOK] Admin command detected: /pumpfun_status
2025-08-10 16:10:23,055 [INFO] app: [WEBHOOK] Unknown admin command: /pumpfun_status
2025-08-10 16:10:34,049 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 16:10:34,050 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121319, 'message': {'message_id': 4362, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754842233, 'text': '/fetch_source pumpfun', 'entities': [{'offset': 0, 'length': 13, 'type': 'bot_command'}]}}
2025-08-10 16:10:34,051 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 16:10:34,051 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_source pumpfun'
2025-08-10 16:10:34,051 [INFO] app: [WEBHOOK] Admin command detected: /fetch_source pumpfun
2025-08-10 16:10:34,051 [INFO] app: [WEBHOOK] Routing /fetch_source
2025-08-10 16:10:34,064 [INFO] root: >>> alerts.telegram LOADED tg-4 <<<
2025-08-10 16:10:34,103 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 16:10:34,331 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:35,964 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:39,078 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=50&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 16:10:39,078 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 16:10:39,079 [INFO] root: [FETCH] /fetch_source pumpfun returned 0 items
2025-08-10 16:10:40,375 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 16:10:40,376 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121320, 'message': {'message_id': 4364, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754842240, 'text': '/fetch_now', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 16:10:40,376 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 16:10:40,376 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/fetch_now'
2025-08-10 16:10:40,376 [INFO] app: [WEBHOOK] Admin command detected: /fetch_now
2025-08-10 16:10:40,376 [INFO] app: [WEBHOOK] Routing /fetch_now
2025-08-10 16:10:40,402 [INFO] root: [RULES] Loaded (v1)
2025-08-10 16:10:40,500 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:41,182 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:42,372 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:42,474 [INFO] httpx: HTTP Request: GET https://pumpportal.fun/api/coins/created?limit=200&offset=0 "HTTP/1.1 404 Not Found"
2025-08-10 16:10:43,164 [INFO] httpx: HTTP Request: GET https://pumpportal.fun/api/coins/created?limit=200&offset=0 "HTTP/1.1 404 Not Found"
2025-08-10 16:10:44,154 [INFO] httpx: HTTP Request: GET https://pumpportal.fun/api/coins/created?limit=200&offset=0 "HTTP/1.1 404 Not Found"
2025-08-10 16:10:44,629 [INFO] httpx: HTTP Request: POST https://mainnet.helius-rpc.com/?api-key=e3de2ac8-b5fd-43c8-a1e5-e68d9a562009 "HTTP/1.1 200 OK"
2025-08-10 16:10:44,630 [INFO] root: [CHAIN] pumpfun-chain yielded 0 seed rows (<=15min)
2025-08-10 16:10:44,630 [INFO] root: [FETCH] On-chain primary: 0 ultra-fresh items
2025-08-10 16:10:44,726 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:46,781 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=200&offset=0 "HTTP/1.1 530 "
2025-08-10 16:10:50,029 [WARNING] root: JSON fetch failed for https://frontend-api.pump.fun/coins/created: Server error '530 ' for url 'https://frontend-api.pump.fun/coins/created?limit=200&offset=0'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/530
2025-08-10 16:10:50,030 [ERROR] root: [FETCH] All Pump.fun endpoints failed
2025-08-10 16:10:50,030 [INFO] root: [FETCH] Pump.fun API: 0 items
2025-08-10 16:10:50,499 [INFO] httpx: HTTP Request: POST https://mainnet.helius-rpc.com/?api-key=e3de2ac8-b5fd-43c8-a1e5-e68d9a562009 "HTTP/1.1 200 OK"
2025-08-10 16:10:50,500 [INFO] root: [CHAIN] pumpfun-chain yielded 0 seed rows (<=60min)
2025-08-10 16:10:50,500 [INFO] root: [FETCH] On-chain fallback: 0 seed items
2025-08-10 16:10:50,500 [INFO] root: [FETCH] Dexscreener USING SEARCH endpoint (q=solana)
2025-08-10 16:10:50,620 [INFO] httpx: HTTP Request: GET https://api.dexscreener.com/latest/dex/search?q=solana "HTTP/1.1 200 OK"
2025-08-10 16:10:50,622 [INFO] root: [FETCH] Dexscreener search yielded 30 items
2025-08-10 16:10:50,622 [INFO] root: [FETCH] DexScreener: 30 items
2025-08-10 16:10:50,622 [INFO] root: [FETCH] Merged and ranked 5 tokens from 30 total
2025-08-10 16:34:02,882 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:34:02,882 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:34:02,882 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:34:02,885 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:34:03,548 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:51:18,239 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:51:18,239 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:51:18,239 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:51:18,242 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:51:18,890 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:53:54,858 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:53:54,859 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:53:54,859 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:53:54,862 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:53:55,571 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:53:58,771 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:53:58,772 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:53:58,772 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:53:58,775 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:53:59,769 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:54:09,947 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:54:09,947 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:54:09,947 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:54:09,949 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:54:10,754 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:54:28,986 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:54:28,987 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 16:54:28,987 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 16:54:28,990 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 16:54:29,789 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 16:55:18,907 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 16:55:18,907 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121321, 'message': {'message_id': 4366, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754844918, 'text': '/pumpfun_probe', 'entities': [{'offset': 0, 'length': 14, 'type': 'bot_command'}]}}
2025-08-10 16:55:18,907 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 16:55:18,907 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/pumpfun_probe'
2025-08-10 16:55:18,907 [INFO] app: [WEBHOOK] Admin command detected: /pumpfun_probe
2025-08-10 16:55:18,907 [INFO] app: [WEBHOOK] Routing /pumpfun_probe
2025-08-10 16:55:18,951 [INFO] root: >>> data_fetcher LOADED df-6 <<<
2025-08-10 16:55:19,093 [INFO] httpx: HTTP Request: GET https://frontend-api.pump.fun/coins/created?limit=50&offset=0 "HTTP/1.1 530 "
2025-08-10 16:55:19,255 [INFO] httpx: HTTP Request: GET https://api.pumpfunapi.org/pumpfun/new/tokens?limit=50 "HTTP/1.1 200 OK"
2025-08-10 16:55:19,483 [INFO] httpx: HTTP Request: POST https://mainnet.helius-rpc.com/?api-key=e3de2ac8-b5fd-43c8-a1e5-e68d9a562009 "HTTP/1.1 200 OK"
2025-08-10 16:55:19,914 [INFO] app: [WEBHOOK] Command '/pumpfun_probe' processed, response sent: 200
2025-08-10 17:05:20,141 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:05:20,142 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121322, 'message': {'message_id': 4368, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754845519, 'text': '/assistant\nBEGIN PATCH: Hybrid chain + Birdeye + Dexscreener\nFILES: data_fetcher.py, alerts/telegram.py\n\n--- PATCH data_fetcher.py ---\n\n# [A] imports (add if missing)\nimport os, time, requests, logging\nfrom datetime import datetime, timezone\n\n# [B] tiny helpers (add if missing)\ndef _now():\n    return int(time.time())\n\ndef _age_min(ts):\n    try:\n        return max(0, int((_now() - int(ts)) / 60))\n    except Exception:\n        return None\n\ndef _rpc(url, method, params=None, timeout=8):\n    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}\n    r = requests.post(url, json=body, timeout=timeout)\n    r.raise_for_status()\n    return r.json()\n\n# [C] 1) SOLANA ON-CHAIN (Pump.fun program) – first source\ndef fetch_candidates_from_pumpfun_rpc(limit=60):\n    url = os.environ.get("SOLANA_RPC_HTTP","").strip()\n    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()\n    if not url or not program:\n        logging.warning("[RPC] Missing SOLANA_RPC_HTTP or PUMPFUN_PROGRAM_ID")\n        return []\n    try:\n        sigs = _rpc(url, "getSignaturesForAddress", [program, {"limit": limit}]).get("result") or []\n        out = []\n        for s in sigs[:limit]:\n            sig = s.get("signature"); bt = s.get("blockTime")\n            if not sig: continue\n            try:\n                tx = _rpc(url, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}\n            except Exception:\n                continue\n            meta = tx.get("meta") or {}\n            post = meta.get("postTokenBalances") or []\n            pre  = meta.get("preTokenBalances") or []\n            pre_mints = {b.get("mint") for b in pre if b.get("mint")}\n            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]\n            for mint in new_mints:\n                out.append({\n                    "source": "pumpfun-rpc",\n                    "symbol": mint[:4],\n                    "name": mint,\n                    "holders": None,\n                    "mcap_usd": None,\n                    "liquidity_usd": None,\n                    "age_min": _age_min(bt) if bt else None,\n                })\n        logging.info("[RPC] Pump.fun RPC yielded %d", len(out))\n        return out\n    except Exception as e:\n        logging.exception("[RPC] error: %s", e)\n        return []\n\n# [D] 2) BIRDEYE RECENT – second source\ndef fetch_candidates_from_birdeye_recent(limit=100, timeout=8):\n    url = "https://public-api.birdeye.so/public/token/solana/recent"\n    apikey = os.environ.get("BIRDEYE_API_KEY","").strip()\n    headers = {"accept":"application/json"}\n    if apikey:\n        headers["X-API-KEY"] = apikey\n    try:\n        r = requests.get(url, timeout=timeout, headers=headers, params={"limit": min(200, max(10, limit))})\n        r.raise_for_status()\n        js = r.json() or {}\n        data = js.get("data") or js.get("tokens") or js.get("result") or []\n    except Exception as e:\n        logging.warning("[BIRDEYE] recent failed: %s", e)\n        return []\n    out = []\n    now = _now()\n    for it in data:\n        # try common field names across API variants\n        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")\n        sym  = it.get("symbol") or (mint[:4] if mint else "?")\n        name = it.get("name") or mint or "?"\n        liq  = it.get("liquidity") or it.get("liquidityUSD") or it.get("liquidity_usd")\n        mcap = it.get("marketCap") or it.get("market_cap") or it.get("mcap_usd")\n        ts   = it.get("updateUnixTime") or it.get("created_at") or it.get("createdTime") or now\n        out.append({\n            "source": "birdeye",\n            "symbol": sym,\n            "name": name,\n            "holders": it.get("holders"),   # may be None\n            "mcap_usd": mcap,\n            "liquidity_usd": liq,\n            "age_min": _age_min(ts),\n        })\n    logging.info("[BIRDEYE] recent yielded %d", len(out))\n    return out', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 92, 'length': 11, 'type': 'url'}, {'offset': 571, 'length': 13, 'type': 'url'}, {'offset': 690, 'length': 8, 'type': 'url'}, {'offset': 2194, 'length': 12, 'type': 'url'}, {'offset': 2214, 'length': 8, 'type': 'url'}, {'offset': 2478, 'length': 56, 'type': 'url'}, {'offset': 3878, 'length': 12, 'type': 'url'}], 'link_preview_options': {'url': 'https://public-api.birdeye.so/public/token/solana/recent'}}}
2025-08-10 17:05:20,142 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:05:20,142 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: Hybrid chain + Birdeye + Dexscreener
FILES: data_fetcher.py, alerts/telegram.py

--- PATCH data_fetcher.py ---

# [A] imports (add if missing)
import os, time, requests, logging
from datetime import datetime, timezone

# [B] tiny helpers (add if missing)
def _now():
    return int(time.time())

def _age_min(ts):
    try:
        return max(0, int((_now() - int(ts)) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=8):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

# [C] 1) SOLANA ON-CHAIN (Pump.fun program) – first source
def fetch_candidates_from_pumpfun_rpc(limit=60):
    url = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not url or not program:
        logging.warning("[RPC] Missing SOLANA_RPC_HTTP or PUMPFUN_PROGRAM_ID")
        return []
    try:
        sigs = _rpc(url, "getSignaturesForAddress", [program, {"limit": limit}]).get("result") or []
        out = []
        for s in sigs[:limit]:
            sig = s.get("signature"); bt = s.get("blockTime")
            if not sig: continue
            try:
                tx = _rpc(url, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            except Exception:
                continue
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            for mint in new_mints:
                out.append({
                    "source": "pumpfun-rpc",
                    "symbol": mint[:4],
                    "name": mint,
                    "holders": None,
                    "mcap_usd": None,
                    "liquidity_usd": None,
                    "age_min": _age_min(bt) if bt else None,
                })
        logging.info("[RPC] Pump.fun RPC yielded %d", len(out))
        return out
    except Exception as e:
        logging.exception("[RPC] error: %s", e)
        return []

# [D] 2) BIRDEYE RECENT – second source
def fetch_candidates_from_birdeye_recent(limit=100, timeout=8):
    url = "https://public-api.birdeye.so/public/token/solana/recent"
    apikey = os.environ.get("BIRDEYE_API_KEY","").strip()
    headers = {"accept":"application/json"}
    if apikey:
        headers["X-API-KEY"] = apikey
    try:
        r = requests.get(url, timeout=timeout, headers=headers, params={"limit": min(200, max(10, limit))})
        r.raise_for_status()
        js = r.json() or {}
        data = js.get("data") or js.get("tokens") or js.get("result") or []
    except Exception as e:
        logging.warning("[BIRDEYE] recent failed: %s", e)
        return []
    out = []
    now = _now()
    for it in data:
        # try common field names across API variants
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        sym  = it.get("symbol") or (mint[:4] if mint else "?")
        name = it.get("name") or mint or "?"
        liq  = it.get("liquidity") or it.get("liquidityUSD") or it.get("liquidity_usd")
        mcap = it.get("marketCap") or it.get("market_cap") or it.get("mcap_usd")
        ts   = it.get("updateUnixTime") or it.get("created_at") or it.get("createdTime") or now
        out.append({
            "source": "birdeye",
            "symbol": sym,
            "name": name,
            "holders": it.get("holders"),   # may be None
            "mcap_usd": mcap,
            "liquidity_usd": liq,
            "age_min": _age_min(ts),
        })
    logging.info("[BIRDEYE] recent yielded %d", len(out))
    return out'
2025-08-10 17:05:20,142 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: Hybrid chain + Birdeye + Dexscreener
FILES: data_fetcher.py, alerts/telegram.py

--- PATCH data_fetcher.py ---

# [A] imports (add if missing)
import os, time, requests, logging
from datetime import datetime, timezone

# [B] tiny helpers (add if missing)
def _now():
    return int(time.time())

def _age_min(ts):
    try:
        return max(0, int((_now() - int(ts)) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=8):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

# [C] 1) SOLANA ON-CHAIN (Pump.fun program) – first source
def fetch_candidates_from_pumpfun_rpc(limit=60):
    url = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not url or not program:
        logging.warning("[RPC] Missing SOLANA_RPC_HTTP or PUMPFUN_PROGRAM_ID")
        return []
    try:
        sigs = _rpc(url, "getSignaturesForAddress", [program, {"limit": limit}]).get("result") or []
        out = []
        for s in sigs[:limit]:
            sig = s.get("signature"); bt = s.get("blockTime")
            if not sig: continue
            try:
                tx = _rpc(url, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            except Exception:
                continue
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            for mint in new_mints:
                out.append({
                    "source": "pumpfun-rpc",
                    "symbol": mint[:4],
                    "name": mint,
                    "holders": None,
                    "mcap_usd": None,
                    "liquidity_usd": None,
                    "age_min": _age_min(bt) if bt else None,
                })
        logging.info("[RPC] Pump.fun RPC yielded %d", len(out))
        return out
    except Exception as e:
        logging.exception("[RPC] error: %s", e)
        return []

# [D] 2) BIRDEYE RECENT – second source
def fetch_candidates_from_birdeye_recent(limit=100, timeout=8):
    url = "https://public-api.birdeye.so/public/token/solana/recent"
    apikey = os.environ.get("BIRDEYE_API_KEY","").strip()
    headers = {"accept":"application/json"}
    if apikey:
        headers["X-API-KEY"] = apikey
    try:
        r = requests.get(url, timeout=timeout, headers=headers, params={"limit": min(200, max(10, limit))})
        r.raise_for_status()
        js = r.json() or {}
        data = js.get("data") or js.get("tokens") or js.get("result") or []
    except Exception as e:
        logging.warning("[BIRDEYE] recent failed: %s", e)
        return []
    out = []
    now = _now()
    for it in data:
        # try common field names across API variants
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        sym  = it.get("symbol") or (mint[:4] if mint else "?")
        name = it.get("name") or mint or "?"
        liq  = it.get("liquidity") or it.get("liquidityUSD") or it.get("liquidity_usd")
        mcap = it.get("marketCap") or it.get("market_cap") or it.get("mcap_usd")
        ts   = it.get("updateUnixTime") or it.get("created_at") or it.get("createdTime") or now
        out.append({
            "source": "birdeye",
            "symbol": sym,
            "name": name,
            "holders": it.get("holders"),   # may be None
            "mcap_usd": mcap,
            "liquidity_usd": liq,
            "age_min": _age_min(ts),
        })
    logging.info("[BIRDEYE] recent yielded %d", len(out))
    return out
2025-08-10 17:05:20,143 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: Hybrid chain + Birdeye + Dexscreener
FILES: data_fetcher.py, alerts/telegram.py

--- PATCH data_fetcher.py ---

# [A] imports (add if missing)
import os, time, requests, logging
from datetime import datetime, timezone

# [B] tiny helpers (add if missing)
def _now():
    return int(time.time())

def _age_min(ts):
    try:
        return max(0, int((_now() - int(ts)) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=8):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

# [C] 1) SOLANA ON-CHAIN (Pump.fun program) – first source
def fetch_candidates_from_pumpfun_rpc(limit=60):
    url = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not url or not program:
        logging.warning("[RPC] Missing SOLANA_RPC_HTTP or PUMPFUN_PROGRAM_ID")
        return []
    try:
        sigs = _rpc(url, "getSignaturesForAddress", [program, {"limit": limit}]).get("result") or []
        out = []
        for s in sigs[:limit]:
            sig = s.get("signature"); bt = s.get("blockTime")
            if not sig: continue
            try:
                tx = _rpc(url, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            except Exception:
                continue
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            for mint in new_mints:
                out.append({
                    "source": "pumpfun-rpc",
                    "symbol": mint[:4],
                    "name": mint,
                    "holders": None,
                    "mcap_usd": None,
                    "liquidity_usd": None,
                    "age_min": _age_min(bt) if bt else None,
                })
        logging.info("[RPC] Pump.fun RPC yielded %d", len(out))
        return out
    except Exception as e:
        logging.exception("[RPC] error: %s", e)
        return []

# [D] 2) BIRDEYE RECENT – second source
def fetch_candidates_from_birdeye_recent(limit=100, timeout=8):
    url = "https://public-api.birdeye.so/public/token/solana/recent"
    apikey = os.environ.get("BIRDEYE_API_KEY","").strip()
    headers = {"accept":"application/json"}
    if apikey:
        headers["X-API-KEY"] = apikey
    try:
        r = requests.get(url, timeout=timeout, headers=headers, params={"limit": min(200, max(10, limit))})
        r.raise_for_status()
        js = r.json() or {}
        data = js.get("data") or js.get("tokens") or js.get("result") or []
    except Exception as e:
        logging.warning("[BIRDEYE] recent failed: %s", e)
        return []
    out = []
    now = _now()
    for it in data:
        # try common field names across API variants
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        sym  = it.get("symbol") or (mint[:4] if mint else "?")
        name = it.get("name") or mint or "?"
        liq  = it.get("liquidity") or it.get("liquidityUSD") or it.get("liquidity_usd")
        mcap = it.get("marketCap") or it.get("market_cap") or it.get("mcap_usd")
        ts   = it.get("updateUnixTime") or it.get("created_at") or it.get("createdTime") or now
        out.append({
            "source": "birdeye",
            "symbol": sym,
            "name": name,
            "holders": it.get("holders"),   # may be None
            "mcap_usd": mcap,
            "liquidity_usd": liq,
            "age_min": _age_min(ts),
        })
    logging.info("[BIRDEYE] recent yielded %d", len(out))
    return out
2025-08-10 17:05:20,258 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:05:20,259 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121323, 'message': {'message_id': 4369, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754845519, 'text': '# [E] 3) Dexscreener search – keep your existing function:\n# def fetch_candidates_from_dexscreener_search(query="solana", limit=300): ... (returns unified dicts with source="dexscreener")\n\n# [F] Orchestrator (new priority: RPC → Birdeye → Dexscreener)\ndef fetch_candidates_multi_source(limit=100):\n    items = []\n    try:\n        rpc = fetch_candidates_from_pumpfun_rpc(limit=min(60, limit))\n        if rpc: items.extend(rpc)\n    except Exception as e:\n        logging.warning("[FETCH] rpc fail: %s", e)\n\n    # If chain didn’t give much, ask Birdeye\n    if len(items) < 3:\n        try:\n            be = fetch_candidates_from_birdeye_recent(limit=limit)\n            items.extend(be)\n        except Exception as e:\n            logging.warning("[FETCH] birdeye fail: %s", e)\n\n    # If still empty, Dexscreener fallback\n    if not items:\n        try:\n            ds = fetch_candidates_from_dexscreener_search(query="solana", limit=300)\n            items.extend(ds)\n        except Exception as e:\n            logging.error("[FETCH] dexscreener fail: %s", e)\n\n    logging.info("[FETCH] multi-source produced %d", len(items))\n    return items\n\n# [G] Ensure your ranking uses this:\n# items = fetch_candidates_multi_source(limit=rules.get(\'output\',{}).get(\'max_results\',10)*20 or 100)\n\n--- END PATCH ---\n\n--- PATCH alerts/telegram.py ---\n\n# 1) add import near others:\nfrom data_fetcher import fetch_candidates_from_birdeye_recent, fetch_candidates_multi_source\n\n# 2) Add a debug admin route (place before unknown/fallback branch):\nif text.startswith("/fetch_source birdeye"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n    try:\n        items = fetch_candidates_from_birdeye_recent(limit=100)\n        for t in items[:40]:\n            rows.append([\n                t.get("source","birdeye"),\n                t.get("symbol") or "?",\n                t.get("name") or "?",\n                t.get("holders") if t.get("holders") is not None else "-",\n                f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                int(t["age_min"]) if t.get("age_min") is not None else "-",\n            ])\n        txt = _format_table(rows, title="Birdeye (recent)")\n        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n    except Exception as e:\n        await update.message.reply_text(f"birdeye fetch error: {e}")\n    return "ok"\n\n# 3) In /fetch_now handler, ensure it uses the multi-source selector:\n# BEFORE: items = <old call>\n# AFTER:\nitems = fetch_candidates_multi_source(limit=120)\n\n--- END PATCH ---\n\nENV NOTE:\n- Optional: Add BIRDEYE_API_KEY in Replit Secrets (if you have one). If not set, we still try without it.\n\nVALIDATION (expected):\n- No reply to this message.\n- Then run:\n  /fetch_source birdeye   -> table of newest Birdeye tokens (if API reachable)\n  /fetch_now              -> table may include sources: pumpfun-rpc, birdeye, dexscreener\n- Logs:\n  [RPC] Pump.fun RPC yielded N\n  [BIRDEYE] recent yielded N\n  [FETCH] multi-source produced N\nEND', 'entities': [{'offset': 1058, 'length': 12, 'type': 'url'}, {'offset': 1313, 'length': 11, 'type': 'url'}, {'offset': 1542, 'length': 13, 'type': 'bot_command'}, {'offset': 2703, 'length': 10, 'type': 'bot_command'}, {'offset': 3054, 'length': 13, 'type': 'bot_command'}, {'offset': 3133, 'length': 10, 'type': 'bot_command'}, {'offset': 3237, 'length': 8, 'type': 'url'}]}}
2025-08-10 17:05:20,259 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:05:20,259 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# [E] 3) Dexscreener search – keep your existing function:
# def fetch_candidates_from_dexscreener_search(query="solana", limit=300): ... (returns unified dicts with source="dexscreener")

# [F] Orchestrator (new priority: RPC → Birdeye → Dexscreener)
def fetch_candidates_multi_source(limit=100):
    items = []
    try:
        rpc = fetch_candidates_from_pumpfun_rpc(limit=min(60, limit))
        if rpc: items.extend(rpc)
    except Exception as e:
        logging.warning("[FETCH] rpc fail: %s", e)

    # If chain didn’t give much, ask Birdeye
    if len(items) < 3:
        try:
            be = fetch_candidates_from_birdeye_recent(limit=limit)
            items.extend(be)
        except Exception as e:
            logging.warning("[FETCH] birdeye fail: %s", e)

    # If still empty, Dexscreener fallback
    if not items:
        try:
            ds = fetch_candidates_from_dexscreener_search(query="solana", limit=300)
            items.extend(ds)
        except Exception as e:
            logging.error("[FETCH] dexscreener fail: %s", e)

    logging.info("[FETCH] multi-source produced %d", len(items))
    return items

# [G] Ensure your ranking uses this:
# items = fetch_candidates_multi_source(limit=rules.get('output',{}).get('max_results',10)*20 or 100)

--- END PATCH ---

--- PATCH alerts/telegram.py ---

# 1) add import near others:
from data_fetcher import fetch_candidates_from_birdeye_recent, fetch_candidates_multi_source

# 2) Add a debug admin route (place before unknown/fallback branch):
if text.startswith("/fetch_source birdeye"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
    try:
        items = fetch_candidates_from_birdeye_recent(limit=100)
        for t in items[:40]:
            rows.append([
                t.get("source","birdeye"),
                t.get("symbol") or "?",
                t.get("name") or "?",
                t.get("holders") if t.get("holders") is not None else "-",
                f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                int(t["age_min"]) if t.get("age_min") is not None else "-",
            ])
        txt = _format_table(rows, title="Birdeye (recent)")
        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    except Exception as e:
        await update.message.reply_text(f"birdeye fetch error: {e}")
    return "ok"

# 3) In /fetch_now handler, ensure it uses the multi-source selector:
# BEFORE: items = <old call>
# AFTER:
items = fetch_candidates_multi_source(limit=120)

--- END PATCH ---

ENV NOTE:
- Optional: Add BIRDEYE_API_KEY in Replit Secrets (if you have one). If not set, we still try without it.

VALIDATION (expected):
- No reply to this message.
- Then run:
  /fetch_source birdeye   -> table of newest Birdeye tokens (if API reachable)
  /fetch_now              -> table may include sources: pumpfun-rpc, birdeye, dexscreener
- Logs:
  [RPC] Pump.fun RPC yielded N
  [BIRDEYE] recent yielded N
  [FETCH] multi-source produced N
END'
2025-08-10 17:08:09,686 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:08:09,686 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121324, 'message': {'message_id': 4370, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754845689, 'text': '/help', 'entities': [{'offset': 0, 'length': 5, 'type': 'bot_command'}]}}
2025-08-10 17:08:09,687 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:08:09,687 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/help'
2025-08-10 17:08:09,687 [INFO] app: [WEBHOOK] Admin command detected: /help
2025-08-10 17:08:10,069 [INFO] app: [WEBHOOK] Command '/help' processed, response sent: 200
2025-08-10 17:17:22,896 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:22,897 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121325, 'message': {'message_id': 4372, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846227, 'text': '/assistant\nBEGIN PATCH: Birdeye poller + alerts\nFILES: poller.py, alerts/telegram.py, data_fetcher.py\n\n--- CREATE poller.py ---\n\nimport os, json, time, threading, logging, requests, hashlib\nfrom datetime import datetime, timezone\n\n# --- Optional Redis (only if REDIS_URL provided) ---\n_redis = None\ntry:\n    import redis  # optional\n    if os.environ.get("REDIS_URL"):\n        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)\nexcept Exception:\n    _redis = None\n\nDATA_DIR = os.path.join(os.getcwd(), "data")\nSEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")\n\ndef _load_seen():\n    if _redis:\n        try:\n            return set(_redis.smembers("birdeye:seen") or [])\n        except Exception:\n            pass\n    try:\n        os.makedirs(DATA_DIR, exist_ok=True)\n        if os.path.exists(SEEN_FILE):\n            with open(SEEN_FILE, "r") as f:\n                return set(json.load(f))\n    except Exception:\n        pass\n    return set()\n\ndef _save_seen(s):\n    if _redis:\n        try:\n            pipe = _redis.pipeline()\n            pipe.delete("birdeye:seen")\n            if s:\n                pipe.sadd("birdeye:seen", *list(s))\n            pipe.execute()\n            return\n        except Exception:\n            pass\n    try:\n        os.makedirs(DATA_DIR, exist_ok=True)\n        with open(SEEN_FILE, "w") as f:\n            json.dump(sorted(list(s)), f)\n    except Exception:\n        pass\n\ndef _age_min(ts):\n    try:\n        ts = int(ts)\n        return max(0, int((time.time() - ts) / 60))\n    except Exception:\n        return None\n\ndef _rpc(url, method, params=None, timeout=6):\n    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}\n    r = requests.post(url, json=body, timeout=timeout)\n    r.raise_for_status()\n    return r.json()\n\ndef _is_pumpfun_mint(mint):\n    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""\n    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()\n    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()\n    if not rpc or not program:\n        return False\n    try:\n        # signers for the mint account itself may be sparse; instead check signatures for program id.\n        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.\n        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []\n        for s in sigs:\n            sig = s.get("signature")\n            if not sig: continue\n            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}\n            meta = tx.get("meta") or {}\n            post = meta.get("postTokenBalances") or []\n            pre  = meta.get("preTokenBalances") or []\n            pre_mints = {b.get("mint") for b in pre if b.get("mint")}\n            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]\n            if mint in new_mints:\n                return True\n    except Exception as e:\n        logging.debug("pumpfun verify error: %s", e)\n    return False\n\nclass BirdeyePoller:\n    def __init__(self, send_func, interval=10):\n        """\n        send_func(chat_id, text, disable_preview=True) -> coroutine or callable\n        """\n        self.interval = max(5, int(interval))\n        self._thr = None\n        self._stop = threading.Event()\n        self.send_func = send_func\n        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")\n        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"\n        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()\n        self._seen = _load_seen()\n\n    def start(self):\n        if self._thr and self._thr.is_alive():\n            return\n        self._stop.clear()\n        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)\n        self._thr.start()\n        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 55, 'length': 9, 'type': 'url'}, {'offset': 73, 'length': 11, 'type': 'url'}, {'offset': 114, 'length': 9, 'type': 'url'}, {'offset': 1696, 'length': 13, 'type': 'url'}, {'offset': 3938, 'length': 12, 'type': 'url'}]}}
2025-08-10 17:17:22,897 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:22,897 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)'
2025-08-10 17:17:22,897 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)
2025-08-10 17:17:22,897 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)
2025-08-10 17:17:23,015 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:23,015 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121326, 'message': {'message_id': 4373, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846227, 'text': 'def stop(self):\n        if self._thr:\n            self._stop.set()\n            self._thr.join(timeout=3.0)\n            self._thr = None\n        logging.info("[SCAN] Birdeye poller stopped")\n\n    def is_running(self):\n        return self._thr is not None and self._thr.is_alive()\n\n    def set_interval(self, sec):\n        self.interval = max(5, int(sec))\n\n    def set_filter(self, mode):\n        self.filter_mode = mode\n\n    def _run(self):\n        url = "https://public-api.birdeye.so/public/token/solana/recent"\n        headers = {"accept":"application/json"}\n        if self.birdeye_key:\n            headers["X-API-KEY"] = self.birdeye_key\n        while not self._stop.is_set():\n            try:\n                r = requests.get(url, headers=headers, timeout=8, params={"limit": 120})\n                if r.status_code != 200:\n                    logging.warning("[SCAN] Birdeye status=%s", r.status_code)\n                    time.sleep(self.interval); continue\n                js = r.json() or {}\n                data = js.get("data") or js.get("tokens") or js.get("result") or []\n                new_cnt = 0\n                for it in data:\n                    mint = it.get("address") or it.get("mint") or it.get("tokenAddress")\n                    if not mint: continue\n                    key = mint  # de-dup by mint\n                    if key in self._seen: continue\n\n                    # optional pump.fun verification\n                    if self.filter_mode == "pumpfun":\n                        if not _is_pumpfun_mint(mint):\n                            continue\n\n                    self._seen.add(key); new_cnt += 1\n\n                    sym  = it.get("symbol") or mint[:4]\n                    name = it.get("name") or mint\n                    liq  = it.get("liquidity") or it.get("liquidityUSD")\n                    mcap = it.get("marketCap")\n                    ts   = it.get("updateUnixTime") or int(time.time())\n                    age  = _age_min(ts) or "?"\n\n                    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n                    pumpfun_url = f"https://pump.fun/{mint}"\n\n                    parts = [\n                        f"🆕 *{name}* ({sym})",\n                        f"mint: `{mint}`",\n                        f"age: {age} min",\n                        f"mcap: {mcap:,}" if isinstance(mcap,(int,float)) else "mcap: –",\n                        f"liq: {liq:,}" if isinstance(liq,(int,float)) else "liq: –",\n                        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n                    ]\n                    text = " \\n".join(parts)\n                    try:\n                        # send_func may be async or sync; handle both\n                        res = self.send_func(self.chat_id, text)\n                        if hasattr(res, "__await__"):\n                            # running in thread; we can\'t await. Best-effort: log request and move on.\n                            logging.info("[SCAN] queued alert for %s", mint)\n                        else:\n                            pass\n                    except Exception as e:\n                        logging.warning("[SCAN] send failed: %s", e)\n\n                if new_cnt:\n                    _save_seen(self._seen)\n                    logging.info("[SCAN] sent %d new alerts", new_cnt)\n            except Exception as e:\n                logging.warning("[SCAN] loop error: %s", e)\n            time.sleep(self.interval)\n\n# singleton holder\n_scanner = None\ndef get_scanner(sender):\n    global _scanner\n    if _scanner is None:\n        _scanner = BirdeyePoller(send_func=sender, interval=int(os.environ.get("SCAN_INTERVAL","10") or "10"))\n    return _scanner\n\n\n--- PATCH data_fetcher.py ---', 'entities': [{'offset': 144, 'length': 12, 'type': 'url'}, {'offset': 455, 'length': 56, 'type': 'url'}, {'offset': 1406, 'length': 8, 'type': 'url'}, {'offset': 2012, 'length': 44, 'type': 'url'}, {'offset': 2094, 'length': 23, 'type': 'url'}, {'offset': 2514, 'length': 8, 'type': 'url'}, {'offset': 2952, 'length': 12, 'type': 'url'}, {'offset': 3268, 'length': 12, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 17:17:23,015 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:23,015 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def stop(self):
        if self._thr:
            self._stop.set()
            self._thr.join(timeout=3.0)
            self._thr = None
        logging.info("[SCAN] Birdeye poller stopped")

    def is_running(self):
        return self._thr is not None and self._thr.is_alive()

    def set_interval(self, sec):
        self.interval = max(5, int(sec))

    def set_filter(self, mode):
        self.filter_mode = mode

    def _run(self):
        url = "https://public-api.birdeye.so/public/token/solana/recent"
        headers = {"accept":"application/json"}
        if self.birdeye_key:
            headers["X-API-KEY"] = self.birdeye_key
        while not self._stop.is_set():
            try:
                r = requests.get(url, headers=headers, timeout=8, params={"limit": 120})
                if r.status_code != 200:
                    logging.warning("[SCAN] Birdeye status=%s", r.status_code)
                    time.sleep(self.interval); continue
                js = r.json() or {}
                data = js.get("data") or js.get("tokens") or js.get("result") or []
                new_cnt = 0
                for it in data:
                    mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
                    if not mint: continue
                    key = mint  # de-dup by mint
                    if key in self._seen: continue

                    # optional pump.fun verification
                    if self.filter_mode == "pumpfun":
                        if not _is_pumpfun_mint(mint):
                            continue

                    self._seen.add(key); new_cnt += 1

                    sym  = it.get("symbol") or mint[:4]
                    name = it.get("name") or mint
                    liq  = it.get("liquidity") or it.get("liquidityUSD")
                    mcap = it.get("marketCap")
                    ts   = it.get("updateUnixTime") or int(time.time())
                    age  = _age_min(ts) or "?"

                    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
                    pumpfun_url = f"https://pump.fun/{mint}"

                    parts = [
                        f"🆕 *{name}* ({sym})",
                        f"mint: `{mint}`",
                        f"age: {age} min",
                        f"mcap: {mcap:,}" if isinstance(mcap,(int,float)) else "mcap: –",
                        f"liq: {liq:,}" if isinstance(liq,(int,float)) else "liq: –",
                        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
                    ]
                    text = " \n".join(parts)
                    try:
                        # send_func may be async or sync; handle both
                        res = self.send_func(self.chat_id, text)
                        if hasattr(res, "__await__"):
                            # running in thread; we can't await. Best-effort: log request and move on.
                            logging.info("[SCAN] queued alert for %s", mint)
                        else:
                            pass
                    except Exception as e:
                        logging.warning("[SCAN] send failed: %s", e)

                if new_cnt:
                    _save_seen(self._seen)
                    logging.info("[SCAN] sent %d new alerts", new_cnt)
            except Exception as e:
                logging.warning("[SCAN] loop error: %s", e)
            time.sleep(self.interval)

# singleton holder
_scanner = None
def get_scanner(sender):
    global _scanner
    if _scanner is None:
        _scanner = BirdeyePoller(send_func=sender, interval=int(os.environ.get("SCAN_INTERVAL","10") or "10"))
    return _scanner


--- PATCH data_fetcher.py ---'
2025-08-10 17:17:23,133 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:23,138 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121327, 'message': {'message_id': 4374, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846227, 'text': '# no functional changes required for the poller, but ensure this helper exists:\ndef birdeye_debug_recent(limit=40):\n    import requests, os, logging\n    url = "https://public-api.birdeye.so/public/token/solana/recent"\n    headers = {"accept":"application/json"}\n    if os.environ.get("BIRDEYE_API_KEY"):\n        headers["X-API-KEY"] = os.environ["BIRDEYE_API_KEY"]\n    r = requests.get(url, headers=headers, timeout=8, params={"limit":min(200, max(10, limit))})\n    r.raise_for_status()\n    js = r.json() or {}\n    data = js.get("data") or js.get("tokens") or js.get("result") or []\n    out = []\n    now = int(time.time())\n    for it in data[:limit]:\n        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")\n        sym  = it.get("symbol") or (mint[:4] if mint else "?")\n        name = it.get("name") or mint or "?"\n        liq  = it.get("liquidity") or it.get("liquidityUSD")\n        mcap = it.get("marketCap")\n        ts   = it.get("updateUnixTime") or now\n        out.append({\n            "source":"birdeye",\n            "symbol":sym,"name":name,"holders":it.get("holders"),\n            "mcap_usd":mcap,"liquidity_usd":liq,"age_min":max(0,int((now-int(ts))/60))}\n        )\n    return out\n\n\n--- PATCH alerts/telegram.py ---\n\n# add imports\nimport os\nfrom poller import get_scanner\nfrom data_fetcher import birdeye_debug_recent\n\n# helper to send message from poller (thread-safe wrapper)\ndef _send_text_sync(chat_id, text):\n    # best-effort: queue via Telegram webhook object\n    try:\n        # update/message isn\'t available in thread; use bot token direct via requests if you prefer.\n        # For simplicity, re-use our reply helper when called from command context only.\n        pass\n    except Exception:\n        pass\n\n# --- Commands (place BEFORE \'unknown admin command\' fallback) ---\n\n# start scanning\nif text.startswith("/scan_start"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")\n    sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))\n    sc.set_interval(sec); sc.start()\n    await update.message.reply_text(f"✅ Scanner started every {sec}s (filter={sc.filter_mode})")\n    return "ok"\n\n# stop scanning\nif text.startswith("/scan_stop"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    sc = get_scanner(lambda *_: None)\n    sc.stop()\n    await update.message.reply_text("🛑 Scanner stopped")\n    return "ok"\n\n# status\nif text.startswith("/scan_status"):\n    sc = get_scanner(lambda *_: None)\n    state = "running" if sc.is_running() else "stopped"\n    await update.message.reply_text(f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}")\n    return "ok"\n\n# filter (all|pumpfun)\nif text.startswith("/scan_filter"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    mode = parts[1].lower() if len(parts) > 1 else "all"\n    if mode not in ("all","pumpfun"):\n        await update.message.reply_text("Usage: /scan_filter all|pumpfun"); return "ok"\n    sc = get_scanner(lambda *_: None)\n    sc.set_filter(mode)\n    await update.message.reply_text(f"✅ Filter set to: {mode}")\n    return "ok"', 'entities': [{'offset': 160, 'length': 56, 'type': 'url'}, {'offset': 1179, 'length': 3, 'type': 'bot_command'}, {'offset': 1230, 'length': 11, 'type': 'url'}, {'offset': 1850, 'length': 11, 'type': 'bot_command'}, {'offset': 2487, 'length': 10, 'type': 'bot_command'}, {'offset': 2811, 'length': 12, 'type': 'bot_command'}, {'offset': 3091, 'length': 12, 'type': 'bot_command'}, {'offset': 3429, 'length': 12, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 17:17:23,139 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:23,139 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# no functional changes required for the poller, but ensure this helper exists:
def birdeye_debug_recent(limit=40):
    import requests, os, logging
    url = "https://public-api.birdeye.so/public/token/solana/recent"
    headers = {"accept":"application/json"}
    if os.environ.get("BIRDEYE_API_KEY"):
        headers["X-API-KEY"] = os.environ["BIRDEYE_API_KEY"]
    r = requests.get(url, headers=headers, timeout=8, params={"limit":min(200, max(10, limit))})
    r.raise_for_status()
    js = r.json() or {}
    data = js.get("data") or js.get("tokens") or js.get("result") or []
    out = []
    now = int(time.time())
    for it in data[:limit]:
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        sym  = it.get("symbol") or (mint[:4] if mint else "?")
        name = it.get("name") or mint or "?"
        liq  = it.get("liquidity") or it.get("liquidityUSD")
        mcap = it.get("marketCap")
        ts   = it.get("updateUnixTime") or now
        out.append({
            "source":"birdeye",
            "symbol":sym,"name":name,"holders":it.get("holders"),
            "mcap_usd":mcap,"liquidity_usd":liq,"age_min":max(0,int((now-int(ts))/60))}
        )
    return out


--- PATCH alerts/telegram.py ---

# add imports
import os
from poller import get_scanner
from data_fetcher import birdeye_debug_recent

# helper to send message from poller (thread-safe wrapper)
def _send_text_sync(chat_id, text):
    # best-effort: queue via Telegram webhook object
    try:
        # update/message isn't available in thread; use bot token direct via requests if you prefer.
        # For simplicity, re-use our reply helper when called from command context only.
        pass
    except Exception:
        pass

# --- Commands (place BEFORE 'unknown admin command' fallback) ---

# start scanning
if text.startswith("/scan_start"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
    sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
    sc.set_interval(sec); sc.start()
    await update.message.reply_text(f"✅ Scanner started every {sec}s (filter={sc.filter_mode})")
    return "ok"

# stop scanning
if text.startswith("/scan_stop"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    sc = get_scanner(lambda *_: None)
    sc.stop()
    await update.message.reply_text("🛑 Scanner stopped")
    return "ok"

# status
if text.startswith("/scan_status"):
    sc = get_scanner(lambda *_: None)
    state = "running" if sc.is_running() else "stopped"
    await update.message.reply_text(f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}")
    return "ok"

# filter (all|pumpfun)
if text.startswith("/scan_filter"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    mode = parts[1].lower() if len(parts) > 1 else "all"
    if mode not in ("all","pumpfun"):
        await update.message.reply_text("Usage: /scan_filter all|pumpfun"); return "ok"
    sc = get_scanner(lambda *_: None)
    sc.set_filter(mode)
    await update.message.reply_text(f"✅ Filter set to: {mode}")
    return "ok"'
2025-08-10 17:17:23,264 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:23,264 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121328, 'message': {'message_id': 4375, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846227, 'text': '# manual peek of Birdeye (debug)\nif text.startswith("/fetch_source birdeye"):\n    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n    try:\n        items = birdeye_debug_recent(limit=40)\n        for t in items:\n            rows.append([\n                t.get("source","birdeye"),\n                t.get("symbol") or "?",\n                t.get("name") or "?",\n                t.get("holders") if t.get("holders") is not None else "-",\n                f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                int(t["age_min"]) if t.get("age_min") is not None else "-",\n            ])\n        txt = _format_table(rows, title="Birdeye (recent)")\n        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n    except Exception as e:\n        await update.message.reply_text(f"birdeye error: {e}")\n    return "ok"\n\n--- END PATCH ---\n\nENV:\n- Optional (recommended): add BIRDEYE_API_KEY  (Birdeye > Account > API)\n- Optional: REDIS_URL (for persistent/fast de-dupe). Falls back to file if absent.\n- Required for Pump.fun filtering: SOLANA_RPC_HTTP, PUMPFUN_PROGRAM_ID\n\nVALIDATION (expected):\n- No reply to this message.\n- Then run (in Telegram DM with your bot):\n  1) /scan_filter all            ← or /scan_filter pumpfun (requires RPC envs)\n  2) /scan_start 10              ← begin polling every 10s\n  3) Watch for 🆕 alerts with Birdeye + Pump.fun links\n  4) /scan_status                ← shows “running”\n  5) /scan_stop                  ← stops the thread\n- Logs will show: “[SCAN] Birdeye poller started…”, “sent N new alerts”, etc.\nEND', 'entities': [{'offset': 53, 'length': 13, 'type': 'bot_command'}, {'offset': 1219, 'length': 8, 'type': 'url'}, {'offset': 1375, 'length': 12, 'type': 'bot_command'}, {'offset': 1408, 'length': 12, 'type': 'bot_command'}, {'offset': 1454, 'length': 11, 'type': 'bot_command'}, {'offset': 1548, 'length': 8, 'type': 'url'}, {'offset': 1568, 'length': 12, 'type': 'bot_command'}, {'offset': 1619, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 17:17:23,265 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:23,265 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# manual peek of Birdeye (debug)
if text.startswith("/fetch_source birdeye"):
    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
    try:
        items = birdeye_debug_recent(limit=40)
        for t in items:
            rows.append([
                t.get("source","birdeye"),
                t.get("symbol") or "?",
                t.get("name") or "?",
                t.get("holders") if t.get("holders") is not None else "-",
                f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                int(t["age_min"]) if t.get("age_min") is not None else "-",
            ])
        txt = _format_table(rows, title="Birdeye (recent)")
        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    except Exception as e:
        await update.message.reply_text(f"birdeye error: {e}")
    return "ok"

--- END PATCH ---

ENV:
- Optional (recommended): add BIRDEYE_API_KEY  (Birdeye > Account > API)
- Optional: REDIS_URL (for persistent/fast de-dupe). Falls back to file if absent.
- Required for Pump.fun filtering: SOLANA_RPC_HTTP, PUMPFUN_PROGRAM_ID

VALIDATION (expected):
- No reply to this message.
- Then run (in Telegram DM with your bot):
  1) /scan_filter all            ← or /scan_filter pumpfun (requires RPC envs)
  2) /scan_start 10              ← begin polling every 10s
  3) Watch for 🆕 alerts with Birdeye + Pump.fun links
  4) /scan_status                ← shows “running”
  5) /scan_stop                  ← stops the thread
- Logs will show: “[SCAN] Birdeye poller started…”, “sent N new alerts”, etc.
END'
2025-08-10 17:17:27,732 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:27,732 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121329, 'message': {'message_id': 4376, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846247, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 17:17:27,732 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:27,732 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 17:17:27,733 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 17:17:27,733 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 17:17:34,678 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:34,679 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121330, 'message': {'message_id': 4377, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846254, 'text': '/assistant\nBEGIN PATCH: Birdeye poller + alerts\nFILES: poller.py, alerts/telegram.py, data_fetcher.py\n\n--- CREATE poller.py ---\n\nimport os, json, time, threading, logging, requests, hashlib\nfrom datetime import datetime, timezone\n\n# --- Optional Redis (only if REDIS_URL provided) ---\n_redis = None\ntry:\n    import redis  # optional\n    if os.environ.get("REDIS_URL"):\n        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)\nexcept Exception:\n    _redis = None\n\nDATA_DIR = os.path.join(os.getcwd(), "data")\nSEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")\n\ndef _load_seen():\n    if _redis:\n        try:\n            return set(_redis.smembers("birdeye:seen") or [])\n        except Exception:\n            pass\n    try:\n        os.makedirs(DATA_DIR, exist_ok=True)\n        if os.path.exists(SEEN_FILE):\n            with open(SEEN_FILE, "r") as f:\n                return set(json.load(f))\n    except Exception:\n        pass\n    return set()\n\ndef _save_seen(s):\n    if _redis:\n        try:\n            pipe = _redis.pipeline()\n            pipe.delete("birdeye:seen")\n            if s:\n                pipe.sadd("birdeye:seen", *list(s))\n            pipe.execute()\n            return\n        except Exception:\n            pass\n    try:\n        os.makedirs(DATA_DIR, exist_ok=True)\n        with open(SEEN_FILE, "w") as f:\n            json.dump(sorted(list(s)), f)\n    except Exception:\n        pass\n\ndef _age_min(ts):\n    try:\n        ts = int(ts)\n        return max(0, int((time.time() - ts) / 60))\n    except Exception:\n        return None\n\ndef _rpc(url, method, params=None, timeout=6):\n    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}\n    r = requests.post(url, json=body, timeout=timeout)\n    r.raise_for_status()\n    return r.json()\n\ndef _is_pumpfun_mint(mint):\n    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""\n    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()\n    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()\n    if not rpc or not program:\n        return False\n    try:\n        # signers for the mint account itself may be sparse; instead check signatures for program id.\n        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.\n        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []\n        for s in sigs:\n            sig = s.get("signature")\n            if not sig: continue\n            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}\n            meta = tx.get("meta") or {}\n            post = meta.get("postTokenBalances") or []\n            pre  = meta.get("preTokenBalances") or []\n            pre_mints = {b.get("mint") for b in pre if b.get("mint")}\n            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]\n            if mint in new_mints:\n                return True\n    except Exception as e:\n        logging.debug("pumpfun verify error: %s", e)\n    return False\n\nclass BirdeyePoller:\n    def __init__(self, send_func, interval=10):\n        """\n        send_func(chat_id, text, disable_preview=True) -> coroutine or callable\n        """\n        self.interval = max(5, int(interval))\n        self._thr = None\n        self._stop = threading.Event()\n        self.send_func = send_func\n        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")\n        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"\n        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()\n        self._seen = _load_seen()\n\n    def start(self):\n        if self._thr and self._thr.is_alive():\n            return\n        self._stop.clear()\n        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)\n        self._thr.start()\n        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 55, 'length': 9, 'type': 'url'}, {'offset': 73, 'length': 11, 'type': 'url'}, {'offset': 114, 'length': 9, 'type': 'url'}, {'offset': 1696, 'length': 13, 'type': 'url'}, {'offset': 3938, 'length': 12, 'type': 'url'}]}}
2025-08-10 17:17:34,679 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:34,679 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)'
2025-08-10 17:17:34,679 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)
2025-08-10 17:17:34,679 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: Birdeye poller + alerts
FILES: poller.py, alerts/telegram.py, data_fetcher.py

--- CREATE poller.py ---

import os, json, time, threading, logging, requests, hashlib
from datetime import datetime, timezone

# --- Optional Redis (only if REDIS_URL provided) ---
_redis = None
try:
    import redis  # optional
    if os.environ.get("REDIS_URL"):
        _redis = redis.from_url(os.environ["REDIS_URL"], decode_responses=True)
except Exception:
    _redis = None

DATA_DIR = os.path.join(os.getcwd(), "data")
SEEN_FILE = os.path.join(DATA_DIR, "birdeye_seen.json")

def _load_seen():
    if _redis:
        try:
            return set(_redis.smembers("birdeye:seen") or [])
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        if os.path.exists(SEEN_FILE):
            with open(SEEN_FILE, "r") as f:
                return set(json.load(f))
    except Exception:
        pass
    return set()

def _save_seen(s):
    if _redis:
        try:
            pipe = _redis.pipeline()
            pipe.delete("birdeye:seen")
            if s:
                pipe.sadd("birdeye:seen", *list(s))
            pipe.execute()
            return
        except Exception:
            pass
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(SEEN_FILE, "w") as f:
            json.dump(sorted(list(s)), f)
    except Exception:
        pass

def _age_min(ts):
    try:
        ts = int(ts)
        return max(0, int((time.time() - ts) / 60))
    except Exception:
        return None

def _rpc(url, method, params=None, timeout=6):
    body = {"jsonrpc":"2.0","id":1,"method":method,"params":params or []}
    r = requests.post(url, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()

def _is_pumpfun_mint(mint):
    """Lightweight check using recent txs for the mint to see PUMPFUN program involvement."""
    rpc = os.environ.get("SOLANA_RPC_HTTP","").strip()
    program = os.environ.get("PUMPFUN_PROGRAM_ID","").strip()
    if not rpc or not program:
        return False
    try:
        # signers for the mint account itself may be sparse; instead check signatures for program id.
        # Cheap heuristic: fetch last N signatures for the PROGRAM and scan tx meta for this mint once.
        sigs = _rpc(rpc, "getSignaturesForAddress", [program, {"limit": 20}]).get("result") or []
        for s in sigs:
            sig = s.get("signature")
            if not sig: continue
            tx = _rpc(rpc, "getTransaction", [sig, {"encoding":"jsonParsed","maxSupportedTransactionVersion":0}]).get("result") or {}
            meta = tx.get("meta") or {}
            post = meta.get("postTokenBalances") or []
            pre  = meta.get("preTokenBalances") or []
            pre_mints = {b.get("mint") for b in pre if b.get("mint")}
            new_mints = [b.get("mint") for b in post if b.get("mint") and b.get("mint") not in pre_mints]
            if mint in new_mints:
                return True
    except Exception as e:
        logging.debug("pumpfun verify error: %s", e)
    return False

class BirdeyePoller:
    def __init__(self, send_func, interval=10):
        """
        send_func(chat_id, text, disable_preview=True) -> coroutine or callable
        """
        self.interval = max(5, int(interval))
        self._thr = None
        self._stop = threading.Event()
        self.send_func = send_func
        self.chat_id = int(os.environ.get("ASSISTANT_ADMIN_TELEGRAM_ID","0") or "0")
        self.filter_mode = os.environ.get("SCAN_FILTER","all")  # "all" or "pumpfun"
        self.birdeye_key = os.environ.get("BIRDEYE_API_KEY","").strip()
        self._seen = _load_seen()

    def start(self):
        if self._thr and self._thr.is_alive():
            return
        self._stop.clear()
        self._thr = threading.Thread(target=self._run, name="BirdeyePoller", daemon=True)
        self._thr.start()
        logging.info("[SCAN] Birdeye poller started @%ss filter=%s", self.interval, self.filter_mode)
2025-08-10 17:17:34,797 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:34,803 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121331, 'message': {'message_id': 4378, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846254, 'text': 'def stop(self):\n        if self._thr:\n            self._stop.set()\n            self._thr.join(timeout=3.0)\n            self._thr = None\n        logging.info("[SCAN] Birdeye poller stopped")\n\n    def is_running(self):\n        return self._thr is not None and self._thr.is_alive()\n\n    def set_interval(self, sec):\n        self.interval = max(5, int(sec))\n\n    def set_filter(self, mode):\n        self.filter_mode = mode\n\n    def _run(self):\n        url = "https://public-api.birdeye.so/public/token/solana/recent"\n        headers = {"accept":"application/json"}\n        if self.birdeye_key:\n            headers["X-API-KEY"] = self.birdeye_key\n        while not self._stop.is_set():\n            try:\n                r = requests.get(url, headers=headers, timeout=8, params={"limit": 120})\n                if r.status_code != 200:\n                    logging.warning("[SCAN] Birdeye status=%s", r.status_code)\n                    time.sleep(self.interval); continue\n                js = r.json() or {}\n                data = js.get("data") or js.get("tokens") or js.get("result") or []\n                new_cnt = 0\n                for it in data:\n                    mint = it.get("address") or it.get("mint") or it.get("tokenAddress")\n                    if not mint: continue\n                    key = mint  # de-dup by mint\n                    if key in self._seen: continue\n\n                    # optional pump.fun verification\n                    if self.filter_mode == "pumpfun":\n                        if not _is_pumpfun_mint(mint):\n                            continue\n\n                    self._seen.add(key); new_cnt += 1\n\n                    sym  = it.get("symbol") or mint[:4]\n                    name = it.get("name") or mint\n                    liq  = it.get("liquidity") or it.get("liquidityUSD")\n                    mcap = it.get("marketCap")\n                    ts   = it.get("updateUnixTime") or int(time.time())\n                    age  = _age_min(ts) or "?"\n\n                    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n                    pumpfun_url = f"https://pump.fun/{mint}"\n\n                    parts = [\n                        f"🆕 *{name}* ({sym})",\n                        f"mint: `{mint}`",\n                        f"age: {age} min",\n                        f"mcap: {mcap:,}" if isinstance(mcap,(int,float)) else "mcap: –",\n                        f"liq: {liq:,}" if isinstance(liq,(int,float)) else "liq: –",\n                        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n                    ]\n                    text = " \\n".join(parts)\n                    try:\n                        # send_func may be async or sync; handle both\n                        res = self.send_func(self.chat_id, text)\n                        if hasattr(res, "__await__"):\n                            # running in thread; we can\'t await. Best-effort: log request and move on.\n                            logging.info("[SCAN] queued alert for %s", mint)\n                        else:\n                            pass\n                    except Exception as e:\n                        logging.warning("[SCAN] send failed: %s", e)\n\n                if new_cnt:\n                    _save_seen(self._seen)\n                    logging.info("[SCAN] sent %d new alerts", new_cnt)\n            except Exception as e:\n                logging.warning("[SCAN] loop error: %s", e)\n            time.sleep(self.interval)\n\n# singleton holder\n_scanner = None\ndef get_scanner(sender):\n    global _scanner\n    if _scanner is None:\n        _scanner = BirdeyePoller(send_func=sender, interval=int(os.environ.get("SCAN_INTERVAL","10") or "10"))\n    return _scanner\n\n\n--- PATCH data_fetcher.py ---', 'entities': [{'offset': 144, 'length': 12, 'type': 'url'}, {'offset': 455, 'length': 56, 'type': 'url'}, {'offset': 1406, 'length': 8, 'type': 'url'}, {'offset': 2012, 'length': 44, 'type': 'url'}, {'offset': 2094, 'length': 23, 'type': 'url'}, {'offset': 2514, 'length': 8, 'type': 'url'}, {'offset': 2952, 'length': 12, 'type': 'url'}, {'offset': 3268, 'length': 12, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 17:17:34,803 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:34,803 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'def stop(self):
        if self._thr:
            self._stop.set()
            self._thr.join(timeout=3.0)
            self._thr = None
        logging.info("[SCAN] Birdeye poller stopped")

    def is_running(self):
        return self._thr is not None and self._thr.is_alive()

    def set_interval(self, sec):
        self.interval = max(5, int(sec))

    def set_filter(self, mode):
        self.filter_mode = mode

    def _run(self):
        url = "https://public-api.birdeye.so/public/token/solana/recent"
        headers = {"accept":"application/json"}
        if self.birdeye_key:
            headers["X-API-KEY"] = self.birdeye_key
        while not self._stop.is_set():
            try:
                r = requests.get(url, headers=headers, timeout=8, params={"limit": 120})
                if r.status_code != 200:
                    logging.warning("[SCAN] Birdeye status=%s", r.status_code)
                    time.sleep(self.interval); continue
                js = r.json() or {}
                data = js.get("data") or js.get("tokens") or js.get("result") or []
                new_cnt = 0
                for it in data:
                    mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
                    if not mint: continue
                    key = mint  # de-dup by mint
                    if key in self._seen: continue

                    # optional pump.fun verification
                    if self.filter_mode == "pumpfun":
                        if not _is_pumpfun_mint(mint):
                            continue

                    self._seen.add(key); new_cnt += 1

                    sym  = it.get("symbol") or mint[:4]
                    name = it.get("name") or mint
                    liq  = it.get("liquidity") or it.get("liquidityUSD")
                    mcap = it.get("marketCap")
                    ts   = it.get("updateUnixTime") or int(time.time())
                    age  = _age_min(ts) or "?"

                    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
                    pumpfun_url = f"https://pump.fun/{mint}"

                    parts = [
                        f"🆕 *{name}* ({sym})",
                        f"mint: `{mint}`",
                        f"age: {age} min",
                        f"mcap: {mcap:,}" if isinstance(mcap,(int,float)) else "mcap: –",
                        f"liq: {liq:,}" if isinstance(liq,(int,float)) else "liq: –",
                        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
                    ]
                    text = " \n".join(parts)
                    try:
                        # send_func may be async or sync; handle both
                        res = self.send_func(self.chat_id, text)
                        if hasattr(res, "__await__"):
                            # running in thread; we can't await. Best-effort: log request and move on.
                            logging.info("[SCAN] queued alert for %s", mint)
                        else:
                            pass
                    except Exception as e:
                        logging.warning("[SCAN] send failed: %s", e)

                if new_cnt:
                    _save_seen(self._seen)
                    logging.info("[SCAN] sent %d new alerts", new_cnt)
            except Exception as e:
                logging.warning("[SCAN] loop error: %s", e)
            time.sleep(self.interval)

# singleton holder
_scanner = None
def get_scanner(sender):
    global _scanner
    if _scanner is None:
        _scanner = BirdeyePoller(send_func=sender, interval=int(os.environ.get("SCAN_INTERVAL","10") or "10"))
    return _scanner


--- PATCH data_fetcher.py ---'
2025-08-10 17:17:34,920 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:34,926 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121332, 'message': {'message_id': 4379, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846254, 'text': '# no functional changes required for the poller, but ensure this helper exists:\ndef birdeye_debug_recent(limit=40):\n    import requests, os, logging\n    url = "https://public-api.birdeye.so/public/token/solana/recent"\n    headers = {"accept":"application/json"}\n    if os.environ.get("BIRDEYE_API_KEY"):\n        headers["X-API-KEY"] = os.environ["BIRDEYE_API_KEY"]\n    r = requests.get(url, headers=headers, timeout=8, params={"limit":min(200, max(10, limit))})\n    r.raise_for_status()\n    js = r.json() or {}\n    data = js.get("data") or js.get("tokens") or js.get("result") or []\n    out = []\n    now = int(time.time())\n    for it in data[:limit]:\n        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")\n        sym  = it.get("symbol") or (mint[:4] if mint else "?")\n        name = it.get("name") or mint or "?"\n        liq  = it.get("liquidity") or it.get("liquidityUSD")\n        mcap = it.get("marketCap")\n        ts   = it.get("updateUnixTime") or now\n        out.append({\n            "source":"birdeye",\n            "symbol":sym,"name":name,"holders":it.get("holders"),\n            "mcap_usd":mcap,"liquidity_usd":liq,"age_min":max(0,int((now-int(ts))/60))}\n        )\n    return out\n\n\n--- PATCH alerts/telegram.py ---\n\n# add imports\nimport os\nfrom poller import get_scanner\nfrom data_fetcher import birdeye_debug_recent\n\n# helper to send message from poller (thread-safe wrapper)\ndef _send_text_sync(chat_id, text):\n    # best-effort: queue via Telegram webhook object\n    try:\n        # update/message isn\'t available in thread; use bot token direct via requests if you prefer.\n        # For simplicity, re-use our reply helper when called from command context only.\n        pass\n    except Exception:\n        pass\n\n# --- Commands (place BEFORE \'unknown admin command\' fallback) ---\n\n# start scanning\nif text.startswith("/scan_start"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")\n    sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))\n    sc.set_interval(sec); sc.start()\n    await update.message.reply_text(f"✅ Scanner started every {sec}s (filter={sc.filter_mode})")\n    return "ok"\n\n# stop scanning\nif text.startswith("/scan_stop"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    sc = get_scanner(lambda *_: None)\n    sc.stop()\n    await update.message.reply_text("🛑 Scanner stopped")\n    return "ok"\n\n# status\nif text.startswith("/scan_status"):\n    sc = get_scanner(lambda *_: None)\n    state = "running" if sc.is_running() else "stopped"\n    await update.message.reply_text(f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}")\n    return "ok"\n\n# filter (all|pumpfun)\nif text.startswith("/scan_filter"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n    parts = text.split()\n    mode = parts[1].lower() if len(parts) > 1 else "all"\n    if mode not in ("all","pumpfun"):\n        await update.message.reply_text("Usage: /scan_filter all|pumpfun"); return "ok"\n    sc = get_scanner(lambda *_: None)\n    sc.set_filter(mode)\n    await update.message.reply_text(f"✅ Filter set to: {mode}")\n    return "ok"', 'entities': [{'offset': 160, 'length': 56, 'type': 'url'}, {'offset': 1179, 'length': 3, 'type': 'bot_command'}, {'offset': 1230, 'length': 11, 'type': 'url'}, {'offset': 1850, 'length': 11, 'type': 'bot_command'}, {'offset': 2487, 'length': 10, 'type': 'bot_command'}, {'offset': 2811, 'length': 12, 'type': 'bot_command'}, {'offset': 3091, 'length': 12, 'type': 'bot_command'}, {'offset': 3429, 'length': 12, 'type': 'bot_command'}], 'link_preview_options': {'is_disabled': True}}}
2025-08-10 17:17:34,926 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:34,926 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# no functional changes required for the poller, but ensure this helper exists:
def birdeye_debug_recent(limit=40):
    import requests, os, logging
    url = "https://public-api.birdeye.so/public/token/solana/recent"
    headers = {"accept":"application/json"}
    if os.environ.get("BIRDEYE_API_KEY"):
        headers["X-API-KEY"] = os.environ["BIRDEYE_API_KEY"]
    r = requests.get(url, headers=headers, timeout=8, params={"limit":min(200, max(10, limit))})
    r.raise_for_status()
    js = r.json() or {}
    data = js.get("data") or js.get("tokens") or js.get("result") or []
    out = []
    now = int(time.time())
    for it in data[:limit]:
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        sym  = it.get("symbol") or (mint[:4] if mint else "?")
        name = it.get("name") or mint or "?"
        liq  = it.get("liquidity") or it.get("liquidityUSD")
        mcap = it.get("marketCap")
        ts   = it.get("updateUnixTime") or now
        out.append({
            "source":"birdeye",
            "symbol":sym,"name":name,"holders":it.get("holders"),
            "mcap_usd":mcap,"liquidity_usd":liq,"age_min":max(0,int((now-int(ts))/60))}
        )
    return out


--- PATCH alerts/telegram.py ---

# add imports
import os
from poller import get_scanner
from data_fetcher import birdeye_debug_recent

# helper to send message from poller (thread-safe wrapper)
def _send_text_sync(chat_id, text):
    # best-effort: queue via Telegram webhook object
    try:
        # update/message isn't available in thread; use bot token direct via requests if you prefer.
        # For simplicity, re-use our reply helper when called from command context only.
        pass
    except Exception:
        pass

# --- Commands (place BEFORE 'unknown admin command' fallback) ---

# start scanning
if text.startswith("/scan_start"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
    sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
    sc.set_interval(sec); sc.start()
    await update.message.reply_text(f"✅ Scanner started every {sec}s (filter={sc.filter_mode})")
    return "ok"

# stop scanning
if text.startswith("/scan_stop"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    sc = get_scanner(lambda *_: None)
    sc.stop()
    await update.message.reply_text("🛑 Scanner stopped")
    return "ok"

# status
if text.startswith("/scan_status"):
    sc = get_scanner(lambda *_: None)
    state = "running" if sc.is_running() else "stopped"
    await update.message.reply_text(f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}")
    return "ok"

# filter (all|pumpfun)
if text.startswith("/scan_filter"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"
    parts = text.split()
    mode = parts[1].lower() if len(parts) > 1 else "all"
    if mode not in ("all","pumpfun"):
        await update.message.reply_text("Usage: /scan_filter all|pumpfun"); return "ok"
    sc = get_scanner(lambda *_: None)
    sc.set_filter(mode)
    await update.message.reply_text(f"✅ Filter set to: {mode}")
    return "ok"'
2025-08-10 17:17:35,052 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:35,052 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121333, 'message': {'message_id': 4380, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846254, 'text': '# manual peek of Birdeye (debug)\nif text.startswith("/fetch_source birdeye"):\n    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n    try:\n        items = birdeye_debug_recent(limit=40)\n        for t in items:\n            rows.append([\n                t.get("source","birdeye"),\n                t.get("symbol") or "?",\n                t.get("name") or "?",\n                t.get("holders") if t.get("holders") is not None else "-",\n                f"{int(t[\'mcap_usd\']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",\n                f"{int(t[\'liquidity_usd\']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",\n                int(t["age_min"]) if t.get("age_min") is not None else "-",\n            ])\n        txt = _format_table(rows, title="Birdeye (recent)")\n        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n    except Exception as e:\n        await update.message.reply_text(f"birdeye error: {e}")\n    return "ok"\n\n--- END PATCH ---\n\nENV:\n- Optional (recommended): add BIRDEYE_API_KEY  (Birdeye > Account > API)\n- Optional: REDIS_URL (for persistent/fast de-dupe). Falls back to file if absent.\n- Required for Pump.fun filtering: SOLANA_RPC_HTTP, PUMPFUN_PROGRAM_ID\n\nVALIDATION (expected):\n- No reply to this message.\n- Then run (in Telegram DM with your bot):\n  1) /scan_filter all            ← or /scan_filter pumpfun (requires RPC envs)\n  2) /scan_start 10              ← begin polling every 10s\n  3) Watch for 🆕 alerts with Birdeye + Pump.fun links\n  4) /scan_status                ← shows “running”\n  5) /scan_stop                  ← stops the thread\n- Logs will show: “[SCAN] Birdeye poller started…”, “sent N new alerts”, etc.\nEND', 'entities': [{'offset': 53, 'length': 13, 'type': 'bot_command'}, {'offset': 1219, 'length': 8, 'type': 'url'}, {'offset': 1375, 'length': 12, 'type': 'bot_command'}, {'offset': 1408, 'length': 12, 'type': 'bot_command'}, {'offset': 1454, 'length': 11, 'type': 'bot_command'}, {'offset': 1548, 'length': 8, 'type': 'url'}, {'offset': 1568, 'length': 12, 'type': 'bot_command'}, {'offset': 1619, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 17:17:35,053 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:35,053 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '# manual peek of Birdeye (debug)
if text.startswith("/fetch_source birdeye"):
    rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
    try:
        items = birdeye_debug_recent(limit=40)
        for t in items:
            rows.append([
                t.get("source","birdeye"),
                t.get("symbol") or "?",
                t.get("name") or "?",
                t.get("holders") if t.get("holders") is not None else "-",
                f"{int(t['mcap_usd']):,}" if isinstance(t.get("mcap_usd"),(int,float)) else "-",
                f"{int(t['liquidity_usd']):,}" if isinstance(t.get("liquidity_usd"),(int,float)) else "-",
                int(t["age_min"]) if t.get("age_min") is not None else "-",
            ])
        txt = _format_table(rows, title="Birdeye (recent)")
        await update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    except Exception as e:
        await update.message.reply_text(f"birdeye error: {e}")
    return "ok"

--- END PATCH ---

ENV:
- Optional (recommended): add BIRDEYE_API_KEY  (Birdeye > Account > API)
- Optional: REDIS_URL (for persistent/fast de-dupe). Falls back to file if absent.
- Required for Pump.fun filtering: SOLANA_RPC_HTTP, PUMPFUN_PROGRAM_ID

VALIDATION (expected):
- No reply to this message.
- Then run (in Telegram DM with your bot):
  1) /scan_filter all            ← or /scan_filter pumpfun (requires RPC envs)
  2) /scan_start 10              ← begin polling every 10s
  3) Watch for 🆕 alerts with Birdeye + Pump.fun links
  4) /scan_status                ← shows “running”
  5) /scan_stop                  ← stops the thread
- Logs will show: “[SCAN] Birdeye poller started…”, “sent N new alerts”, etc.
END'
2025-08-10 17:17:46,643 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 17:17:46,643 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 17:17:46,643 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 17:17:46,656 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 17:17:47,942 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 17:17:57,069 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:17:57,070 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121334, 'message': {'message_id': 4381, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846276, 'text': '/scan_start 10', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 17:17:57,070 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:17:57,070 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_start 10'
2025-08-10 17:17:57,071 [INFO] app: [WEBHOOK] Admin command detected: /scan_start 10
2025-08-10 17:17:57,071 [INFO] app: [WEBHOOK] Unknown admin command: /scan_start 10
2025-08-10 17:24:30,012 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:24:30,013 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121335, 'message': {'message_id': 4382, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846669, 'text': '/assistant\nBEGIN PATCH: add /scan_test\nFILE: alerts/telegram.py\n\n# --- insert BEFORE the "unknown admin command" fallback ---\n\n# /scan_test  — send a single fake alert to verify formatting/permissions\nif text.strip().startswith("/scan_test"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n\n    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test\n    name = "TestCoin"\n    sym  = "TEST"\n    age_min = 2\n    mcap = "—"\n    liq  = "—"\n    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n    pumpfun_url = f"https://pump.fun/{mint}"\n\n    msg = (\n        f"🆕 *{name}* ({sym})\\n"\n        f"mint: `{mint}`\\n"\n        f"age: {age_min} min\\n"\n        f"mcap: {mcap}\\n"\n        f"liq: {liq}\\n"\n        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n    )\n    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n    return "ok"\n\nEND PATCH', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 28, 'length': 10, 'type': 'bot_command'}, {'offset': 52, 'length': 11, 'type': 'url'}, {'offset': 129, 'length': 10, 'type': 'bot_command'}, {'offset': 229, 'length': 10, 'type': 'bot_command'}, {'offset': 607, 'length': 44, 'type': 'url'}, {'offset': 673, 'length': 23, 'type': 'url'}, {'offset': 892, 'length': 8, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 17:24:30,013 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:24:30,013 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH'
2025-08-10 17:24:30,013 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH
2025-08-10 17:24:30,013 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH
2025-08-10 17:24:40,774 [INFO] app: [WEBHOOK] Received POST request from 172.31.88.66
2025-08-10 17:24:40,776 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121336, 'message': {'message_id': 4383, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754846680, 'text': '/scan_test', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 17:24:40,776 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 17:24:40,777 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_test'
2025-08-10 17:24:40,778 [INFO] app: [WEBHOOK] Admin command detected: /scan_test
2025-08-10 17:24:40,779 [INFO] app: [WEBHOOK] Unknown admin command: /scan_test
2025-08-10 18:40:16,785 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 18:40:16,791 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 18:40:16,791 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 18:40:17,011 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 18:40:21,031 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 18:47:41,159 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:47:41,159 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121337, 'message': {'message_id': 4384, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851660, 'text': '/assistant\nBEGIN PATCH: add /scan_test\nFILE: alerts/telegram.py\n\n# --- insert BEFORE the "unknown admin command" fallback ---\n\n# /scan_test  — send a single fake alert to verify formatting/permissions\nif text.strip().startswith("/scan_test"):\n    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:\n        await update.message.reply_text("Not authorized."); return "ok"\n\n    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test\n    name = "TestCoin"\n    sym  = "TEST"\n    age_min = 2\n    mcap = "—"\n    liq  = "—"\n    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n    pumpfun_url = f"https://pump.fun/{mint}"\n\n    msg = (\n        f"🆕 *{name}* ({sym})\\n"\n        f"mint: `{mint}`\\n"\n        f"age: {age_min} min\\n"\n        f"mcap: {mcap}\\n"\n        f"liq: {liq}\\n"\n        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n    )\n    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n    return "ok"\n\nEND PATCH', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 28, 'length': 10, 'type': 'bot_command'}, {'offset': 52, 'length': 11, 'type': 'url'}, {'offset': 129, 'length': 10, 'type': 'bot_command'}, {'offset': 229, 'length': 10, 'type': 'bot_command'}, {'offset': 607, 'length': 44, 'type': 'url'}, {'offset': 673, 'length': 23, 'type': 'url'}, {'offset': 892, 'length': 8, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 18:47:41,159 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:47:41,160 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH'
2025-08-10 18:47:41,160 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH
2025-08-10 18:47:41,160 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: add /scan_test
FILE: alerts/telegram.py

# --- insert BEFORE the "unknown admin command" fallback ---

# /scan_test  — send a single fake alert to verify formatting/permissions
if text.strip().startswith("/scan_test"):
    if getattr(update.effective_user, "id", None) != ASSISTANT_ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Not authorized."); return "ok"

    mint = "So11111111111111111111111111111111111111112"  # sample (SOL) mint just for formatting test
    name = "TestCoin"
    sym  = "TEST"
    age_min = 2
    mcap = "—"
    liq  = "—"
    birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
    pumpfun_url = f"https://pump.fun/{mint}"

    msg = (
        f"🆕 *{name}* ({sym})\n"
        f"mint: `{mint}`\n"
        f"age: {age_min} min\n"
        f"mcap: {mcap}\n"
        f"liq: {liq}\n"
        f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    return "ok"

END PATCH
2025-08-10 18:47:54,538 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:47:54,538 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121338, 'message': {'message_id': 4385, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851674, 'text': '/scan_test', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 18:47:54,538 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:47:54,538 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_test'
2025-08-10 18:47:54,538 [INFO] app: [WEBHOOK] Admin command detected: /scan_test
2025-08-10 18:47:54,539 [INFO] app: [WEBHOOK] Unknown admin command: /scan_test
2025-08-10 18:48:14,132 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:48:14,132 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121339, 'message': {'message_id': 4386, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851694, 'text': '/scan_status', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 18:48:14,132 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:48:14,132 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_status'
2025-08-10 18:48:14,132 [INFO] app: [WEBHOOK] Admin command detected: /scan_status
2025-08-10 18:48:14,132 [INFO] app: [WEBHOOK] Unknown admin command: /scan_status
2025-08-10 18:48:30,968 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:48:30,969 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121340, 'message': {'message_id': 4387, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851710, 'text': '/scan_start 10', 'entities': [{'offset': 0, 'length': 11, 'type': 'bot_command'}]}}
2025-08-10 18:48:30,969 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:48:30,969 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_start 10'
2025-08-10 18:48:30,969 [INFO] app: [WEBHOOK] Admin command detected: /scan_start 10
2025-08-10 18:48:30,969 [INFO] app: [WEBHOOK] Unknown admin command: /scan_start 10
2025-08-10 18:48:39,135 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:48:39,136 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121341, 'message': {'message_id': 4388, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851719, 'text': '/scan_filter pumpfun', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 18:48:39,136 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:48:39,136 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_filter pumpfun'
2025-08-10 18:48:39,136 [INFO] app: [WEBHOOK] Admin command detected: /scan_filter pumpfun
2025-08-10 18:48:39,136 [INFO] app: [WEBHOOK] Unknown admin command: /scan_filter pumpfun
2025-08-10 18:48:53,911 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:48:53,912 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121342, 'message': {'message_id': 4389, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851733, 'text': '/scan_stop', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 18:48:53,912 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:48:53,912 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/scan_stop'
2025-08-10 18:48:53,913 [INFO] app: [WEBHOOK] Admin command detected: /scan_stop
2025-08-10 18:48:53,913 [INFO] app: [WEBHOOK] Unknown admin command: /scan_stop
2025-08-10 18:49:02,212 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:49:02,212 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121343, 'message': {'message_id': 4390, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754851742, 'text': '/a_logs_tail 40 level=info', 'entities': [{'offset': 0, 'length': 12, 'type': 'bot_command'}]}}
2025-08-10 18:49:02,212 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:49:02,212 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/a_logs_tail 40 level=info'
2025-08-10 18:49:02,213 [INFO] app: [WEBHOOK] Admin command detected: /a_logs_tail 40 level=info
2025-08-10 18:49:02,795 [INFO] app: [WEBHOOK] Command '/a_logs_tail 40 level=info' processed, response sent: 200
2025-08-10 18:49:24,619 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 18:49:24,620 [INFO] root: Boot logging ready: file=logs/app.log + ring-buffer
2025-08-10 18:49:24,620 [INFO] root: Boot: robust logging with ring buffer initialized
2025-08-10 18:49:24,631 [INFO] root: PTB streamlined mode not available (cannot import name 'Chat' from 'telegram' (unknown location)) - using Flask fallback
2025-08-10 18:49:25,568 [WARNING] bot: Telegram bot disabled: cannot import name 'Chat' from 'telegram' (unknown location)
2025-08-10 18:55:48,889 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:55:48,889 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121344, 'message': {'message_id': 4392, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754852148, 'text': '/assistant\nBEGIN PATCH: route scan/birdeye commands\nFILES: alerts/telegram.py, app.py\n\n--- PATCH alerts/telegram.py ---\n\n# ADD near the top (exports a single entry-point for admin commands)\ndef handle_scan_command_sync(update, context, text):\n    """\n    Entry-point called from app.py for scan/birdeye utilities.\n    This wraps the existing inline blocks so app.py can delegate here.\n    """\n    # reuse existing variables in this module\n    from telegram.constants import ParseMode\n    import os, logging\n    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)\n\n    async def _async_reply(msg):\n        # app.py calls us from sync; use run_until_complete-like helper via context\n        try:\n            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n        except Exception as e:\n            logging.warning("reply failed: %s", e)\n\n    # Normalize for easier matching\n    t = (text or "").strip()\n\n    # Mirror the handlers we previously added inline:\n    if t.startswith("/scan_test"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        mint = "So11111111111111111111111111111111111111112"\n        name, sym, age_min = "TestCoin", "TEST", 2\n        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n        pumpfun_url = f"https://pump.fun/{mint}"\n        msg = (\n            f"🆕 *{name}* ({sym})\\n"\n            f"mint: `{mint}`\\n"\n            f"age: {age_min} min\\n"\n            f"mcap: —\\n"\n            f"liq: —\\n"\n            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n        )\n        # schedule async send\n        return ("reply", msg)\n\n    if t.startswith("/scan_start"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        parts = t.split()\n        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")\n        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))\n        sc.set_interval(sec); sc.start()\n        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"\n\n    if t.startswith("/scan_stop"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        sc = get_scanner(lambda *_: None)\n        sc.stop()\n        return "🛑 Scanner stopped"\n\n    if t.startswith("/scan_status"):\n        from poller import get_scanner\n        sc = get_scanner(lambda *_: None)\n        state = "running" if sc.is_running() else "stopped"\n        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"\n\n    if t.startswith("/scan_filter"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        parts = t.split()\n        mode = parts[1].lower() if len(parts) > 1 else "all"\n        if mode not in ("all","pumpfun"):\n            return "Usage: /scan_filter all|pumpfun"\n        sc = get_scanner(lambda *_: None)\n        sc.set_filter(mode)\n        return f"✅ Filter set to: {mode}"', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 66, 'length': 11, 'type': 'url'}, {'offset': 79, 'length': 6, 'type': 'url'}, {'offset': 104, 'length': 11, 'type': 'url'}, {'offset': 279, 'length': 6, 'type': 'url'}, {'offset': 359, 'length': 6, 'type': 'url'}, {'offset': 599, 'length': 6, 'type': 'url'}, {'offset': 1028, 'length': 10, 'type': 'bot_command'}, {'offset': 1285, 'length': 44, 'type': 'url'}, {'offset': 1355, 'length': 23, 'type': 'url'}, {'offset': 1592, 'length': 8, 'type': 'url'}, {'offset': 1710, 'length': 11, 'type': 'bot_command'}, {'offset': 2299, 'length': 10, 'type': 'bot_command'}, {'offset': 2577, 'length': 12, 'type': 'bot_command'}, {'offset': 2844, 'length': 12, 'type': 'bot_command'}, {'offset': 3162, 'length': 12, 'type': 'bot_command'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 18:55:48,890 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:55:48,890 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"'
2025-08-10 18:55:48,890 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"
2025-08-10 18:55:48,890 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"
2025-08-10 18:55:49,009 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:55:49,009 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121345, 'message': {'message_id': 4393, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754852148, 'text': 'if t.startswith("/fetch_source birdeye"):\n        # run the same debug we added\n        from telegram.constants import ParseMode\n        from data_fetcher import birdeye_debug_recent\n        rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n        try:\n            items = birdeye_debug_recent(limit=40)\n            for x in items:\n                rows.append([\n                    x.get("source","birdeye"),\n                    x.get("symbol") or "?",\n                    x.get("name") or "?",\n                    x.get("holders") if x.get("holders") is not None else "-",\n                    f"{int(x[\'mcap_usd\']):,}" if isinstance(x.get("mcap_usd"),(int,float)) else "-",\n                    f"{int(x[\'liquidity_usd\']):,}" if isinstance(x.get("liquidity_usd"),(int,float)) else "-",\n                    int(x["age_min"]) if x.get("age_min") is not None else "-",\n                ])\n            txt = _format_table(rows, title="Birdeye (recent)")\n            return ("reply", txt)\n        except Exception as e:\n            return f"birdeye error: {e}"\n\n    return None  # not handled here\n\n\n--- PATCH app.py ---\n\n# Find your webhook handler where text = message.get("text","") is parsed,\n# and BEFORE falling through to "Unknown admin command", add this block:\n\n        # --- SCAN / BIRDEYE ROUTES (delegate to alerts.telegram) ---\n        if text.startswith("/scan_start") or text.startswith("/scan_stop") \\\n           or text.startswith("/scan_status") or text.startswith("/scan_filter") \\\n           or text.startswith("/fetch_source birdeye") or text.startswith("/scan_test"):\n            logging.info("[WEBHOOK] Routing scan/birdeye command: %s", text.split()[0])\n            try:\n                from alerts.telegram import handle_scan_command_sync\n                res = handle_scan_command_sync(mock_update, None, text)\n                if isinstance(res, tuple) and res[0] == "reply":\n                    # replies are returned as ("reply", markdown_text)\n                    await tg._safe_reply(mock_update, res[1])\n                elif isinstance(res, str) and res:\n                    await tg._safe_reply(mock_update, res)\n                return "ok"\n            except Exception as e:\n                logging.exception("scan/birdeye handler error: %s", e)\n                await tg._safe_reply(mock_update, f"scan error: {e}")\n                return "ok"\n\n# (keep existing routes and the final Unknown admin command branch below)\n\n--- END PATCH ---', 'entities': [{'offset': 17, 'length': 13, 'type': 'bot_command'}, {'offset': 1126, 'length': 6, 'type': 'url'}, {'offset': 1172, 'length': 29, 'type': 'code'}, {'offset': 1385, 'length': 11, 'type': 'bot_command'}, {'offset': 1419, 'length': 10, 'type': 'bot_command'}, {'offset': 1465, 'length': 12, 'type': 'bot_command'}, {'offset': 1500, 'length': 12, 'type': 'bot_command'}, {'offset': 1548, 'length': 13, 'type': 'bot_command'}, {'offset': 1592, 'length': 10, 'type': 'bot_command'}, {'offset': 1618, 'length': 12, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 18:55:49,009 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:55:49,010 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): 'if t.startswith("/fetch_source birdeye"):
        # run the same debug we added
        from telegram.constants import ParseMode
        from data_fetcher import birdeye_debug_recent
        rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]
        try:
            items = birdeye_debug_recent(limit=40)
            for x in items:
                rows.append([
                    x.get("source","birdeye"),
                    x.get("symbol") or "?",
                    x.get("name") or "?",
                    x.get("holders") if x.get("holders") is not None else "-",
                    f"{int(x['mcap_usd']):,}" if isinstance(x.get("mcap_usd"),(int,float)) else "-",
                    f"{int(x['liquidity_usd']):,}" if isinstance(x.get("liquidity_usd"),(int,float)) else "-",
                    int(x["age_min"]) if x.get("age_min") is not None else "-",
                ])
            txt = _format_table(rows, title="Birdeye (recent)")
            return ("reply", txt)
        except Exception as e:
            return f"birdeye error: {e}"

    return None  # not handled here


--- PATCH app.py ---

# Find your webhook handler where text = message.get("text","") is parsed,
# and BEFORE falling through to "Unknown admin command", add this block:

        # --- SCAN / BIRDEYE ROUTES (delegate to alerts.telegram) ---
        if text.startswith("/scan_start") or text.startswith("/scan_stop") \
           or text.startswith("/scan_status") or text.startswith("/scan_filter") \
           or text.startswith("/fetch_source birdeye") or text.startswith("/scan_test"):
            logging.info("[WEBHOOK] Routing scan/birdeye command: %s", text.split()[0])
            try:
                from alerts.telegram import handle_scan_command_sync
                res = handle_scan_command_sync(mock_update, None, text)
                if isinstance(res, tuple) and res[0] == "reply":
                    # replies are returned as ("reply", markdown_text)
                    await tg._safe_reply(mock_update, res[1])
                elif isinstance(res, str) and res:
                    await tg._safe_reply(mock_update, res)
                return "ok"
            except Exception as e:
                logging.exception("scan/birdeye handler error: %s", e)
                await tg._safe_reply(mock_update, f"scan error: {e}")
                return "ok"

# (keep existing routes and the final Unknown admin command branch below)

--- END PATCH ---'
2025-08-10 18:56:05,952 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:56:05,952 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121346, 'message': {'message_id': 4394, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754852165, 'text': '/assistant', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}]}}
2025-08-10 18:56:05,952 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:56:05,952 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant'
2025-08-10 18:56:05,952 [INFO] app: [WEBHOOK] Admin command detected: /assistant
2025-08-10 18:56:05,952 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
2025-08-10 18:56:16,787 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:56:16,787 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121347, 'message': {'message_id': 4395, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754852176, 'text': '/assistant\nBEGIN PATCH: route scan/birdeye commands\nFILES: alerts/telegram.py, app.py\n\n--- PATCH alerts/telegram.py ---\n\n# ADD near the top (exports a single entry-point for admin commands)\ndef handle_scan_command_sync(update, context, text):\n    """\n    Entry-point called from app.py for scan/birdeye utilities.\n    This wraps the existing inline blocks so app.py can delegate here.\n    """\n    # reuse existing variables in this module\n    from telegram.constants import ParseMode\n    import os, logging\n    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)\n\n    async def _async_reply(msg):\n        # app.py calls us from sync; use run_until_complete-like helper via context\n        try:\n            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n        except Exception as e:\n            logging.warning("reply failed: %s", e)\n\n    # Normalize for easier matching\n    t = (text or "").strip()\n\n    # Mirror the handlers we previously added inline:\n    if t.startswith("/scan_test"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        mint = "So11111111111111111111111111111111111111112"\n        name, sym, age_min = "TestCoin", "TEST", 2\n        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"\n        pumpfun_url = f"https://pump.fun/{mint}"\n        msg = (\n            f"🆕 *{name}* ({sym})\\n"\n            f"mint: `{mint}`\\n"\n            f"age: {age_min} min\\n"\n            f"mcap: —\\n"\n            f"liq: —\\n"\n            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"\n        )\n        # schedule async send\n        return ("reply", msg)\n\n    if t.startswith("/scan_start"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        parts = t.split()\n        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")\n        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))\n        sc.set_interval(sec); sc.start()\n        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"\n\n    if t.startswith("/scan_stop"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        sc = get_scanner(lambda *_: None)\n        sc.stop()\n        return "🛑 Scanner stopped"\n\n    if t.startswith("/scan_status"):\n        from poller import get_scanner\n        sc = get_scanner(lambda *_: None)\n        state = "running" if sc.is_running() else "stopped"\n        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"\n\n    if t.startswith("/scan_filter"):\n        if str(getattr(update.effective_user, "id", "")) != admin_id:\n            return "Not authorized."\n        from poller import get_scanner\n        parts = t.split()\n        mode = parts[1].lower() if len(parts) > 1 else "all"\n        if mode not in ("all","pumpfun"):\n            return "Usage: /scan_filter all|pumpfun"\n        sc = get_scanner(lambda *_: None)\n        sc.set_filter(mode)\n        return f"✅ Filter set to: {mode}"', 'entities': [{'offset': 0, 'length': 10, 'type': 'bot_command'}, {'offset': 66, 'length': 11, 'type': 'url'}, {'offset': 79, 'length': 6, 'type': 'url'}, {'offset': 104, 'length': 11, 'type': 'url'}, {'offset': 279, 'length': 6, 'type': 'url'}, {'offset': 359, 'length': 6, 'type': 'url'}, {'offset': 599, 'length': 6, 'type': 'url'}, {'offset': 1028, 'length': 10, 'type': 'bot_command'}, {'offset': 1285, 'length': 44, 'type': 'url'}, {'offset': 1355, 'length': 23, 'type': 'url'}, {'offset': 1592, 'length': 8, 'type': 'url'}, {'offset': 1710, 'length': 11, 'type': 'bot_command'}, {'offset': 2299, 'length': 10, 'type': 'bot_command'}, {'offset': 2577, 'length': 12, 'type': 'bot_command'}, {'offset': 2844, 'length': 12, 'type': 'bot_command'}, {'offset': 3162, 'length': 12, 'type': 'bot_command'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 18:56:16,787 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
2025-08-10 18:56:16,787 [INFO] app: [WEBHOOK] Message from Drahcir196 (1653046781): '/assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"'
2025-08-10 18:56:16,787 [INFO] app: [WEBHOOK] Admin command detected: /assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"
2025-08-10 18:56:16,788 [INFO] app: [WEBHOOK] Unknown admin command: /assistant
BEGIN PATCH: route scan/birdeye commands
FILES: alerts/telegram.py, app.py

--- PATCH alerts/telegram.py ---

# ADD near the top (exports a single entry-point for admin commands)
def handle_scan_command_sync(update, context, text):
    """
    Entry-point called from app.py for scan/birdeye utilities.
    This wraps the existing inline blocks so app.py can delegate here.
    """
    # reuse existing variables in this module
    from telegram.constants import ParseMode
    import os, logging
    admin_id = str(ASSISTANT_ADMIN_TELEGRAM_ID)

    async def _async_reply(msg):
        # app.py calls us from sync; use run_until_complete-like helper via context
        try:
            return await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
        except Exception as e:
            logging.warning("reply failed: %s", e)

    # Normalize for easier matching
    t = (text or "").strip()

    # Mirror the handlers we previously added inline:
    if t.startswith("/scan_test"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        mint = "So11111111111111111111111111111111111111112"
        name, sym, age_min = "TestCoin", "TEST", 2
        birdeye_url = f"https://birdeye.so/token/{mint}?chain=solana"
        pumpfun_url = f"https://pump.fun/{mint}"
        msg = (
            f"🆕 *{name}* ({sym})\n"
            f"mint: `{mint}`\n"
            f"age: {age_min} min\n"
            f"mcap: —\n"
            f"liq: —\n"
            f"[Birdeye]({birdeye_url}) • [Pump.fun]({pumpfun_url})"
        )
        # schedule async send
        return ("reply", msg)

    if t.startswith("/scan_start"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        sec = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else int(os.environ.get("SCAN_INTERVAL","10") or "10")
        sc = get_scanner(lambda chat_id, msg: update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True))
        sc.set_interval(sec); sc.start()
        return f"✅ Scanner started every {sec}s (filter={sc.filter_mode})"

    if t.startswith("/scan_stop"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        sc.stop()
        return "🛑 Scanner stopped"

    if t.startswith("/scan_status"):
        from poller import get_scanner
        sc = get_scanner(lambda *_: None)
        state = "running" if sc.is_running() else "stopped"
        return f"🔎 Scanner: {state}  interval={sc.interval}s  filter={sc.filter_mode}"

    if t.startswith("/scan_filter"):
        if str(getattr(update.effective_user, "id", "")) != admin_id:
            return "Not authorized."
        from poller import get_scanner
        parts = t.split()
        mode = parts[1].lower() if len(parts) > 1 else "all"
        if mode not in ("all","pumpfun"):
            return "Usage: /scan_filter all|pumpfun"
        sc = get_scanner(lambda *_: None)
        sc.set_filter(mode)
        return f"✅ Filter set to: {mode}"
2025-08-10 18:56:16,910 [INFO] app: [WEBHOOK] Received POST request from 172.31.76.98
2025-08-10 18:56:16,911 [INFO] app: [WEBHOOK] Update data: {'update_id': 112121348, 'message': {'message_id': 4396, 'from': {'id': 1653046781, 'is_bot': False, 'first_name': 'Turk', 'username': 'Drahcir196', 'language_code': 'en', 'is_premium': True}, 'chat': {'id': 1653046781, 'first_name': 'Turk', 'username': 'Drahcir196', 'type': 'private'}, 'date': 1754852176, 'text': 'if t.startswith("/fetch_source birdeye"):\n        # run the same debug we added\n        from telegram.constants import ParseMode\n        from data_fetcher import birdeye_debug_recent\n        rows = [["source","symbol","name","holders","mcap$","liq$","age_min"]]\n        try:\n            items = birdeye_debug_recent(limit=40)\n            for x in items:\n                rows.append([\n                    x.get("source","birdeye"),\n                    x.get("symbol") or "?",\n                    x.get("name") or "?",\n                    x.get("holders") if x.get("holders") is not None else "-",\n                    f"{int(x[\'mcap_usd\']):,}" if isinstance(x.get("mcap_usd"),(int,float)) else "-",\n                    f"{int(x[\'liquidity_usd\']):,}" if isinstance(x.get("liquidity_usd"),(int,float)) else "-",\n                    int(x["age_min"]) if x.get("age_min") is not None else "-",\n                ])\n            txt = _format_table(rows, title="Birdeye (recent)")\n            return ("reply", txt)\n        except Exception as e:\n            return f"birdeye error: {e}"\n\n    return None  # not handled here\n\n\n--- PATCH app.py ---\n\n# Find your webhook handler where text = message.get("text","") is parsed,\n# and BEFORE falling through to "Unknown admin command", add this block:\n\n        # --- SCAN / BIRDEYE ROUTES (delegate to alerts.telegram) ---\n        if text.startswith("/scan_start") or text.startswith("/scan_stop") \\\n           or text.startswith("/scan_status") or text.startswith("/scan_filter") \\\n           or text.startswith("/fetch_source birdeye") or text.startswith("/scan_test"):\n            logging.info("[WEBHOOK] Routing scan/birdeye command: %s", text.split()[0])\n            try:\n                from alerts.telegram import handle_scan_command_sync\n                res = handle_scan_command_sync(mock_update, None, text)\n                if isinstance(res, tuple) and res[0] == "reply":\n                    # replies are returned as ("reply", markdown_text)\n                    await tg._safe_reply(mock_update, res[1])\n                elif isinstance(res, str) and res:\n                    await tg._safe_reply(mock_update, res)\n                return "ok"\n            except Exception as e:\n                logging.exception("scan/birdeye handler error: %s", e)\n                await tg._safe_reply(mock_update, f"scan error: {e}")\n                return "ok"\n\n# (keep existing routes and the final Unknown admin command branch below)\n\n--- END PATCH ---', 'entities': [{'offset': 17, 'length': 13, 'type': 'bot_command'}, {'offset': 1126, 'length': 6, 'type': 'url'}, {'offset': 1172, 'length': 29, 'type': 'code'}, {'offset': 1385, 'length': 11, 'type': 'bot_command'}, {'offset': 1419, 'length': 10, 'type': 'bot_command'}, {'offset': 1465, 'length': 12, 'type': 'bot_command'}, {'offset': 1500, 'length': 12, 'type': 'bot_command'}, {'offset': 1548, 'length': 13, 'type': 'bot_command'}, {'offset': 1592, 'length': 10, 'type': 'bot_command'}, {'offset': 1618, 'length': 12, 'type': 'url'}], 'link_preview_options': {'url': 'https://birdeye.so/token/%7Bmint%7D?chain=solana'}}}
2025-08-10 18:56:16,911 [WARNING] app: [WEBHOOK] PTB disabled, using direct webhook processing
