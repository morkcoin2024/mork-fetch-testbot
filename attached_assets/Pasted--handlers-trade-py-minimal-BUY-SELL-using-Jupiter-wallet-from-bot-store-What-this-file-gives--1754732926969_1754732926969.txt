"""
handlers/trade.py — minimal BUY/SELL using Jupiter, wallet from bot store

What this file gives you:
- /fetch: picks 1 routable Pump.fun token and buys 0.05 SOL automatically via Jupiter
- Shows tokens received, SOL spent, tx signature
- Presents inline buttons: BUY MORE (0.01 SOL), SELL (100%)
- /sell <mint> <percent>: manual sell path

Assumptions:
- You already have jupiter_engine.py in project (Canvas version) with `safe_swap_via_jupiter`.
- You store user wallet (pubkey + base58 private key) in your DB or store; simple fallback JSON is provided.
- python-telegram-bot v20+

Safe defaults:
- Checks Jupiter routability before buying
- Confirms post-trade token balance delta
- Uses 0.05 SOL on /fetch (configurable)

Integrate:
from handlers.trade import register_trade_handlers
register_trade_handlers(application)
"""
import os
import json
import time
import base64
import logging
from decimal import Decimal
from typing import Optional, Tuple

import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler

from jupiter_engine import safe_swap_via_jupiter

logger = logging.getLogger(__name__)

SOL_MINT = "So11111111111111111111111111111111111111112"
JUP_BASE = os.getenv("JUPITER_BASE", "https://quote-api.jup.ag/v6")
DEFAULT_FETCH_BUY_SOL = float(os.getenv("DEFAULT_FETCH_BUY_SOL", "0.05"))
SAFE_MODE = os.getenv("SAFE_MODE", "0") == "1"

WALLET_STORE_PATH = os.getenv("WALLET_STORE_PATH", "wallet_store.json")

# ----------------------- Wallet helpers (replace with your DB) -----------------------

def _load_wallet_from_store(chat_id: str) -> Optional[dict]:
    # Replace with your persistent DB lookup (UserSession/Wallet table)
    try:
        if not os.path.exists(WALLET_STORE_PATH):
            return None
        with open(WALLET_STORE_PATH, "r") as f:
            data = json.load(f)
        return data.get(chat_id)
    except Exception as e:
        logger.error("wallet store read failed: %s", e)
        return None

# ----------------------- Jupiter helpers -----------------------

def is_routable_on_jupiter(output_mint: str, amount_sol: float = 0.01) -> bool:
    try:
        params = {
            "inputMint": SOL_MINT,
            "outputMint": output_mint,
            "amount": str(int(amount_sol * 1_000_000_000)),
            "slippageBps": "150",
            "onlyDirectRoutes": "false",
            "asLegacyTransaction": "false",
        }
        r = requests.get(f"{JUP_BASE}/quote", params=params, timeout=15)
        if r.status_code != 200:
            return False
        j = r.json()
        return bool(j and isinstance(j, dict) and j.get("routes")) or ("inAmount" in j and "outAmount" in j)
    except Exception as e:
        logger.warning("routability check failed: %s", e)
        return False

# Minimal token discovery — get first Pump.fun token that is routable
PUMPFUN_LATEST = os.getenv("PUMPFUN_LATEST", "https://pump.fun/api/latest")

def get_one_routable_pumpfun_token() -> Optional[dict]:
    try:
        r = requests.get(PUMPFUN_LATEST, timeout=10)
        if r.status_code != 200:
            return None
        data = r.json()
        # data format can vary; expect a list of token dicts with key "mint"
        tokens = data if isinstance(data, list) else data.get("tokens") or []
        for t in tokens:
            mint = t.get("mint") or t.get("address") or t.get("tokenAddress")
            if not mint:
                continue
            if is_routable_on_jupiter(mint, amount_sol=0.01):
                t["mint"] = mint
                return t
        return None
    except Exception as e:
        logger.error("pump.fun discovery failed: %s", e)
        return None

# ----------------------- Telegram handlers -----------------------

async def fetch_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = str(update.effective_chat.id)

    if SAFE_MODE:
        await update.message.reply_text("SAFE_MODE is ON — no real trades will be executed.")
        return

    wallet = _load_wallet_from_store(chat_id)
    if not wallet or "priv_b58" not in wallet or "pubkey" not in wallet:
        await update.message.reply_text("No wallet linked. Use /linkwallet to import or create one.")
        return

    await update.message.reply_text("Scanning Pump.fun for a routable token…")
    token = get_one_routable_pumpfun_token()
    if not token:
        await update.message.reply_text("No routable Pump.fun token found right now. Try again in a moment.")
        return

    mint = token["mint"]
    symbol = token.get("symbol") or token.get("ticker") or "UNKNOWN"

    await update.message.reply_text(f"Found: {symbol}\nMint: {mint}\nAttempting buy of {DEFAULT_FETCH_BUY_SOL} SOL via Jupiter…")

    try:
        res = safe_swap_via_jupiter(
            private_key_b58=wallet["priv_b58"],
            output_mint_str=mint,
            amount_in_sol=DEFAULT_FETCH_BUY_SOL,
            slippage_bps=150,
            min_post_delta_raw=1,
        )

        if not res.get("success"):
            await update.message.reply_text("❌ Buy failed — no token delta detected. Routing/liquidity may be insufficient.")
            return

        tx = res.get("signature", "(no sig)")
        delta = res.get("delta_raw", "0")
        msg = (
            f"✅ BUY COMPLETE\n"
            f"Token: {symbol}\n"
            f"Mint: {mint}\n"
            f"SOL Spent: {DEFAULT_FETCH_BUY_SOL}\n"
            f"Tokens Received (raw): {delta}\n"
            f"Tx: {tx}"
        )

        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("BUY MORE (0.01 SOL)", callback_data=f"buy_more:{mint}:0.01"),
                InlineKeyboardButton("SELL (100%)", callback_data=f"sell_all:{mint}")
            ]
        ])
        await update.message.reply_text(msg, reply_markup=keyboard)

    except Exception as e:
        logger.exception("/fetch buy failed: %s", e)
        await update.message.reply_text(f"❌ Error during buy: {e}")


async def on_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    chat_id = str(query.message.chat_id)

    wallet = _load_wallet_from_store(chat_id)
    if not wallet:
        await query.edit_message_text("No wallet linked. Use /linkwallet first.")
        return

    data = query.data
    try:
        if data.startswith("buy_more:"):
            _, mint, sol_str = data.split(":")
            sol_amt = float(sol_str)
            if SAFE_MODE:
                await query.edit_message_text("SAFE_MODE is ON — no buy executed.")
                return
            res = safe_swap_via_jupiter(wallet["priv_b58"], mint, sol_amt, slippage_bps=150, min_post_delta_raw=1)
            if res.get("success"):
                await query.edit_message_text(f"✅ BUY MORE success — tx {res.get('signature')}")
            else:
                await query.edit_message_text("❌ BUY MORE failed — no token delta detected.")
            return

        if data.startswith("sell_all:"):
            _, mint = data.split(":")
            if SAFE_MODE:
                await query.edit_message_text("SAFE_MODE is ON — no sell executed.")
                return
            sell_res = await _sell_token_to_sol(wallet["priv_b58"], mint, percent=100.0)
            if sell_res.get("success"):
                await query.edit_message_text(f"✅ SELL success — tx {sell_res.get('signature')}")
            else:
                await query.edit_message_text("❌ SELL failed — check liquidity/route.")
            return

    except Exception as e:
        logger.exception("button handler error: %s", e)
        await query.edit_message_text(f"❌ Error: {e}")


async def sell_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /sell <mint> <percent>
    if SAFE_MODE:
        await update.message.reply_text("SAFE_MODE is ON — no sell executed.")
        return

    if len(context.args) < 2:
        await update.message.reply_text("Usage: /sell <mint> <percent>")
        return
    mint = context.args[0]
    percent = float(context.args[1])

    chat_id = str(update.effective_chat.id)
    wallet = _load_wallet_from_store(chat_id)
    if not wallet:
        await update.message.reply_text("No wallet linked. Use /linkwallet first.")
        return

    try:
        res = await _sell_token_to_sol(wallet["priv_b58"], mint, percent=percent)
        if res.get("success"):
            await update.message.reply_text(f"✅ SELL success — tx {res.get('signature')}")
        else:
            await update.message.reply_text("❌ SELL failed — check liquidity/route.")
    except Exception as e:
        logger.exception("/sell failed: %s", e)
        await update.message.reply_text(f"❌ Error: {e}")

# ----------------------- SELL via Jupiter (token->SOL) -----------------------

async def _sell_token_to_sol(priv_b58: str, mint: str, percent: float = 100.0) -> dict:
    """Minimal sell helper: swap token -> SOL via Jupiter for given percent of balance.
    NOTE: For brevity, balance/decimals are approximated; production should read token decimals and compute precise raw.
    """
    try:
        # fetch token balance (raw) from ATA
        from solana.rpc.api import Client
        from solana.publickey import PublicKey
        from spl.token.instructions import get_associated_token_address
        import base58

        client = Client(os.getenv("SOLANA_RPC_URL", "https://api.mainnet-beta.solana.com"))
        owner = _pub_from_priv(priv_b58)
        mint_pk = PublicKey(mint)
        ata = get_associated_token_address(owner, mint_pk)
        ai = client.get_token_account_balance(ata)
        if ai.value is None or ai.value.ui_amount is None:
            return {"success": False, "error": "No token balance"}

        ui_amt = float(ai.value.ui_amount)
        if ui_amt <= 0:
            return {"success": False, "error": "Zero balance"}

        sell_amt_ui = ui_amt * max(0.0, min(percent, 100.0)) / 100.0
        # Quote wants input as raw amount in smallest units; use amount as float (Jupiter accepts decimals in v6 / swap input)
        params = {
            "inputMint": mint,
            "outputMint": SOL_MINT,
            "amount": str(sell_amt_ui),
            "slippageBps": "150",
            "onlyDirectRoutes": "false",
            "asLegacyTransaction": "false",
        }
        qr = requests.get(f"{JUP_BASE}/quote", params=params, timeout=15)
        qr.raise_for_status()
        route = qr.json()
        if not route:
            return {"success": False, "error": "No route"}

        # Build swap tx
        headers = {"Content-Type": "application/json"}
        body = {
            "quoteResponse": route,
            "userPublicKey": str(owner),
            "wrapAndUnwrapSol": True,
            "useSharedAccounts": True,
            "asLegacyTransaction": False,
        }
        sr = requests.post(f"{JUP_BASE}/swap", headers=headers, data=json.dumps(body), timeout=20)
        sr.raise_for_status()
        j = sr.json()
        b64 = j.get("swapTransaction")
        if not b64:
            return {"success": False, "error": "No swapTransaction"}

        # Send raw
        from solana.rpc.types import TxOpts
        c = Client(os.getenv("SOLANA_RPC_URL", "https://api.mainnet-beta.solana.com"))
        txsig = c.send_raw_transaction(b64, opts=TxOpts(skip_preflight=True)).value
        c.confirm_transaction(txsig)
        return {"success": True, "signature": txsig}

    except Exception as e:
        logger.exception("sell helper error: %s", e)
        return {"success": False, "error": str(e)}


def _pub_from_priv(b58: str):
    from solana.keypair import Keypair
    try:
        import base58 as _b58
        kp = Keypair.from_secret_key(_b58.b58decode(b58))
        return kp.public_key
    except Exception:
        import base64 as _b64
        kp = Keypair.from_secret_key(_b64.b64decode(b58))
        return kp.public_key

# ----------------------- Registration -----------------------

def register_trade_handlers(app):
    app.add_handler(CommandHandler("fetch", fetch_handler))
    app.add_handler(CommandHandler("sell", sell_handler))
    app.add_handler(CallbackQueryHandler(on_button, pattern=r"^(buy_more|sell_all):"))
