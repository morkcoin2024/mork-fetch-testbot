# --- BEGIN PATCH: robust Birdeye tokenlist without sort_by ---

def tick(self):
    if not self.running:
        return
    if not BIRDEYE_KEY:
        self.publish("scan.birdeye.error", {"err":"missing BIRDEYE_API_KEY"})
        return

    url = f"{API}/defi/tokenlist"

    # Try minimal params first (most compatible), then fallbacks
    param_variants = [
        {"chain": "solana", "offset": 0, "limit": 20},                                 # 1) no sort_by at all
        {"chain": "solana", "sort_type": "desc", "offset": 0, "limit": 20},            # 2) only sort_type
        {"chain": "solana", "sort_by": "createdTime", "sort_type": "desc", "offset": 0, "limit": 20},  # 3) camel
        {"chain": "solana", "sort_by": "created_at", "sort_type": "desc", "offset": 0, "limit": 20},   # 4) snake
    ]

    last_err = None
    data = None

    for i, params in enumerate(param_variants, start=1):
        try:
            data = _birdeye_get(url, params, HEADERS, max_retries=_MAX_RETRIES)
            break  # success
        except httpx.HTTPStatusError as e:
            sc = e.response.status_code
            body = e.response.text[:200] if e.response is not None else ""
            logging.warning(
                "[SCAN] Birdeye status=%s (try %d/%d) url=%s params=%s body=%s",
                sc, i, len(param_variants), str(getattr(e.request, "url", url)), params, body
            )
            last_err = f"HTTP {sc}"
            # 429 handling happens inside _birdeye_get, so we just move on to next variant for 400s, etc.
            continue
        except Exception as e:
            logging.warning("[SCAN] Birdeye tick error (try %d/%d): %s", i, len(param_variants), e)
            last_err = str(e)
            continue

    if data is None:
        # All variants failed
        self.publish("scan.birdeye.error", {"err": last_err or "unknown"})
        return

    items = (
        data.get("data", {}).get("tokens")
        or data.get("data", [])
        or data.get("tokens", [])
        or []
    )

    new_tokens = []
    for it in items:
        mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
        if not mint:
            continue
        if self._mark_seen(mint):
            new_tokens.append({
                "mint": mint,
                "symbol": it.get("symbol") or "?",
                "name": it.get("name") or "?",
                "price": it.get("priceUsd") or it.get("price") or None,
            })

    if new_tokens:
        self.publish("scan.birdeye.new", {"count": len(new_tokens), "items": new_tokens[:10]})
    logging.info("[SCAN] Birdeye tick ok: %s items, %s new", len(items), len(new_tokens))

# --- END PATCH ---
