import logging
import base58
from solders.keypair import Keypair
from solders.pubkey import Pubkey as PublicKey
from solders.transaction import VersionedTransaction
from solana.rpc.api import Client
import aiohttp
import asyncio
import base64

# Robustness settings
MAX_RETRIES = 3
INITIAL_RETRY_DELAY = 2
API_TIMEOUT = 30
PUMPPORTAL_API = "https://pumpportal.fun/api/trade-local"

logger = logging.getLogger(__name__)

class PumpFunTrader:
    def __init__(self, rpc_endpoint: str = "https://api.mainnet-beta.solana.com"):
        self.rpc_endpoint = rpc_endpoint
        self.client = Client(rpc_endpoint)
    
    def check_wallet_balance(self, wallet_address: str):
        try:
            pubkey = PublicKey.from_string(wallet_address)
            balance_response = self.client.get_balance(pubkey)
            if balance_response.value is not None:
                lamports = balance_response.value
                sol_balance = lamports / 1e9
                logger.info(f"Wallet balance: {sol_balance:.6f} SOL")
                return {"success": True, "sol_balance": sol_balance, "funded": lamports > 0}
            else:
                return {"success": False, "error": "Unable to fetch balance", "funded": False}
        except Exception as e:
            logger.error(f"Balance check failed: {e}")
            return {"success": False, "error": str(e), "funded": False}

    async def buy_pump_token(self, private_key: str, token_contract: str, sol_amount: float, slippage_percent: float = 1.0) -> dict:
        """
        Buy Pump.fun token using PumpPortal API only (NO direct SOL transfer)
        """
        try:
            # --- Key handling (your same logic) ---
            if private_key.startswith('gAAAAAB'):
                logger.info("Decrypting encrypted private key...")
                from cryptography.fernet import Fernet
                import os
                key_file = 'wallet_encryption.key'
                if os.path.exists(key_file):
                    with open(key_file, 'rb') as f:
                        key = f.read()
                    fernet = Fernet(key)
                    decrypted_str = fernet.decrypt(private_key.encode()).decode()
                    private_key_bytes = base64.b64decode(decrypted_str)
                    logger.info(f"âœ… Private key decrypted successfully")
                else:
                    return {"success": False, "error": "Encryption key file not found"}
            else:
                logger.info("Using plain base58 private key...")
                private_key_bytes = base58.b58decode(private_key)
            keypair = Keypair.from_bytes(private_key_bytes)
            public_key = str(keypair.pubkey())

            # --- Check wallet balance before proceeding ---
            balance_check = self.check_wallet_balance(public_key)
            sol_balance = balance_check.get('sol_balance', 0)
            if not balance_check.get("funded", False) or sol_balance < sol_amount:
                return {
                    "success": False,
                    "error": f"Insufficient funds: {sol_balance:.6f} SOL available, need {sol_amount} SOL"
                }
            logger.info(f"Ready to buy {sol_amount} SOL of {token_contract[:8]} from wallet {public_key}")

            # --- PumpPortal API loop with retries ---
            trade_data = {
                "publicKey": public_key,
                "action": "buy",
                "mint": token_contract,
                "denominatedInSol": "true",
                "amount": sol_amount,  # Float (not lamports!)
                "slippage": slippage_percent,
                "priorityFee": 0.0001
            }
            retry_delay = INITIAL_RETRY_DELAY
            for attempt in range(MAX_RETRIES):
                try:
                    logger.info(f"ðŸš€ Attempt {attempt+1}/{MAX_RETRIES}: Sending buy request to PumpPortal API...")
                    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=API_TIMEOUT)) as session:
                        async with session.post(PUMPPORTAL_API, json=trade_data, headers={"Content-Type": "application/json"}) as response:
                            if response.status == 200:
                                response_data = await response.json()
                                logger.info(f"PumpPortal API responded: {str(response_data)[:120]}...")

                                # Handle returned serialized transaction
                                if "transaction" in response_data:
                                    serialized_transaction = response_data["transaction"]
                                elif isinstance(response_data, str):
                                    serialized_transaction = response_data
                                else:
                                    logger.error(f"Invalid API response: {response_data}")
                                    return {"success": False, "error": "Invalid API response from PumpPortal"}

                                # Decode, sign, and send the transaction
                                try:
                                    transaction_bytes = base64.b64decode(serialized_transaction)
                                    versioned_tx = VersionedTransaction.from_bytes(transaction_bytes)
                                    versioned_tx.sign([keypair])
                                    send_result = self.client.send_transaction(versioned_tx)
                                    tx_hash = send_result.value if hasattr(send_result, 'value') else send_result
                                    logger.info(f"âœ… Token purchase sent! TX: {tx_hash}")
                                    return {
                                        "success": True,
                                        "transaction_id": tx_hash,
                                        "transaction_hash": tx_hash,
                                        "message": f"Successfully bought {sol_amount} SOL worth of {token_contract}",
                                        "amount_sol": sol_amount,
                                        "platform": "pump_fun"
                                    }
                                except Exception as sign_error:
                                    logger.error(f"Transaction signing/sending failed: {sign_error}")
                                    return {"success": False, "error": f"Failed to sign/send transaction: {sign_error}"}
                            else:
                                error_text = await response.text()
                                logger.warning(f"PumpPortal API error: Status {response.status}, {error_text}")
                                if attempt == MAX_RETRIES - 1:
                                    return {"success": False, "error": f"API error after {MAX_RETRIES} attempts: {error_text}"}
                                await asyncio.sleep(retry_delay)
                                retry_delay *= 2
                except aiohttp.ClientError as e:
                    logger.warning(f"Network error: {e}")
                    if attempt == MAX_RETRIES - 1:
                        return {"success": False, "error": f"Network error after {MAX_RETRIES} attempts: {e}"}
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 2
            return {"success": False, "error": "PumpPortal API call failed after all retries."}
        except Exception as e:
            logger.error(f"Pump.fun buy failed: {e}")
            return {"success": False, "error": str(e)}
