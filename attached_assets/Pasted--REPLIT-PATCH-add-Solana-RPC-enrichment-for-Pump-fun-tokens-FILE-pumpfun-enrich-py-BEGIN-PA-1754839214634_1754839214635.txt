# REPLIT PATCH â€” add Solana RPC enrichment for Pump.fun tokens

FILE: pumpfun_enrich.py
--- BEGIN PATCH ---
import httpx, os, time, random
from eventbus import publish

PUMP_BASE = "https://frontend-api.pump.fun/coins/created"
DEX_PAIR   = "https://api.dexscreener.com/latest/dex/pairs/solana/"
HEADERS = {
    "user-agent": "Mozilla/5.0 (MorkFetcher; +https://github.com/mork-bot)",
    "accept": "application/json",
}
SOLANA_RPC_HTTP = os.environ.get("SOLANA_RPC_HTTP","").strip()

def fetch_pumpfun(limit=50, offset=0, retries=3):
    url = f"{PUMP_BASE}?limit={limit}&offset={offset}"
    last = None
    for attempt in range(retries):
        try:
            r = httpx.get(url, headers=HEADERS, timeout=8)
            last = r.status_code
            if r.status_code == 200:
                data = r.json()
                # Expect either list or {"coins":[...]}
                if isinstance(data, dict) and "coins" in data:
                    data = data["coins"]
                publish("pumpfun.raw", {"n": len(data)})
                return data
            else:
                publish("pumpfun.err", {"code": r.status_code})
        except Exception as e:
            publish("pumpfun.exc", {"err": str(e)})
        if attempt < retries - 1:
            time.sleep(0.4 * (2**attempt) + random.uniform(0.05, 0.3))
    publish("pumpfun.empty", {"note": "no data", "last": last})
    return []

def enrich_with_dex(tokens):
    out = []
    for tok in tokens:
        mint = tok.get("mint")
        if not mint:
            out.append(tok); continue
        try:
            r = httpx.get(f"{DEX_PAIR}{mint}", headers=HEADERS, timeout=6)
            if r.status_code == 200:
                ds = r.json()
                tok["dex_data"] = ds.get("pairs", [])
            else:
                publish("dex.err", {"mint": mint, "code": r.status_code})
        except Exception as e:
            publish("dex.exc", {"mint": mint, "err": str(e)})
        out.append(tok)
    publish("pumpfun.enriched.dex", {"n": len(out)})
    return out

def _rpc_batch_token_supply(mints, batch_size=25, timeout=12):
    """
    Batch JSON-RPC: getTokenSupply for each mint.
    Returns dict[mint] -> {"decimals": int, "amount": str, "uiAmount": float}
    """
    if not SOLANA_RPC_HTTP:
        publish("rpc.disabled", {"reason": "no SOLANA_RPC_HTTP"})
        return {}

    results = {}
    try:
        with httpx.Client(timeout=timeout, headers={"content-type":"application/json"}) as c:
            for i in range(0, len(mints), batch_size):
                chunk = mints[i:i+batch_size]
                calls = []
                for idx, mint in enumerate(chunk):
                    calls.append({
                        "jsonrpc":"2.0","id":idx,
                        "method":"getTokenSupply","params":[mint]
                    })
                r = c.post(SOLANA_RPC_HTTP, json=calls)
                if r.status_code != 200:
                    publish("rpc.batch.err", {"code": r.status_code}); continue
                arr = r.json()
                # JSON-RPC batch is a list of responses
                for resp in arr:
                    rid = resp.get("id")
                    val = (resp.get("result") or {}).get("value") or {}
                    # Need to map back to mint by position
                    try:
                        mint = chunk[rid]
                    except Exception:
                        continue
                    if isinstance(val, dict):
                        results[mint] = {
                            "decimals": val.get("decimals"),
                            "amount": val.get("amount"),
                            "uiAmount": val.get("uiAmount"),
                        }
                publish("rpc.supply.batch", {"n": len(chunk)})
    except Exception as e:
        publish("rpc.batch.exc", {"err": str(e)})
    return results

def enrich_with_solana_rpc(tokens):
    """
    Add rpc.{decimals, supply} to tokens that have 'mint'.
    """
    mints = [t.get("mint") for t in tokens if t.get("mint")]
    mints = [m for m in mints if isinstance(m, str)]
    if not mints:
        publish("rpc.supply.skip", {"reason": "no mints"})
        return tokens

    sup = _rpc_batch_token_supply(mints)
    out = []
    for t in tokens:
        m = t.get("mint")
        if m and m in sup:
            t.setdefault("rpc", {})
            t["rpc"]["decimals"] = sup[m].get("decimals")
            t["rpc"]["supply"]   = sup[m].get("amount")
            t["rpc"]["supply_ui"]= sup[m].get("uiAmount")
        out.append(t)
    publish("pumpfun.rpc_enriched", {"n": len(out), "matched": len(sup)})
    return out

def pumpfun_full(limit=50):
    raw = fetch_pumpfun(limit=limit)
    if not raw:
        return []
    # Normalize: ensure minimal shape + source
    norm = []
    for c in raw:
        norm.append({
            "source": "pumpfun",
            "symbol": c.get("symbol") or c.get("ticker") or None,
            "name": c.get("name") or None,
            "mint": c.get("mint") or c.get("mintAddress") or c.get("tokenAddress"),
            "holders": c.get("holders") or None,
            "mcap_usd": c.get("market_cap") or c.get("mcap") or None,
            "liquidity_usd": c.get("liquidity_usd") or c.get("liquidity") or None,
            "age_min": None,  # can compute if you have createdAt; left None if missing
        })
    # RPC enrichment (decimals/supply), then Dex data
    step1 = enrich_with_solana_rpc(norm)
    step2 = enrich_with_dex(step1)
    publish("pumpfun.full.done", {"n": len(step2)})
    return step2
--- END PATCH ---

FILE: data_fetcher.py
--- BEGIN PATCH ---
# ensure imports
from pumpfun_enrich import pumpfun_full
from eventbus import publish

def fetch_source_pumpfun(limit=50):
    items = pumpfun_full(limit=limit)
    publish("fetch.pumpfun.final", {"n": len(items)})
    return items

# In your main aggregation for /fetch_now, ensure you call:
# pumpfun_rows = []
# try: pumpfun_rows = fetch_source_pumpfun(limit=200)
# except Exception as e: publish("fetch.pumpfun.exc", {"err": str(e)}); pumpfun_rows = []
# if not pumpfun_rows:  # keep your chain/early fallbacks here
#     ...
# all_items.extend(pumpfun_rows)
--- END PATCH ---
