# ---------- NAME SPLITTER (ticker first, brand second) ----------
def split_primary_secondary(name_str: str) -> tuple[str, str]:
    """
    Accepts forms like:
      - 'Solana (SOL)'                  -> ('SOL', 'Solana')
      - 'WINGS â€” Wings Stays On'        -> ('WINGS', 'Wings Stays On')
      - 'BONK Bonk Inu' (fallback)      -> ('BONK', 'Bonk Inu')
    """
    s = (name_str or "").strip()

    # 1) Form: 'Brand (TICKER)'
    if "(" in s and s.endswith(")"):
        try:
            base, tick = s.rsplit("(", 1)
            secondary = base.strip()
            primary = tick[:-1].strip()
            if primary:
                return primary, secondary
        except Exception:
            pass

    # 2) Form: 'TICKER â€” Brand'
    if "â€”" in s:
        a, b = [x.strip() for x in s.split("â€”", 1)]
        if a.isupper() and 1 <= len(a) <= 8:
            return a, b

    # 3) Fallback: pick shortest ALL-CAPS token as ticker; rest as brand
    tokens = s.replace("(", " ").replace(")", " ").replace("â€”", " ").split()
    caps = [t for t in tokens if t.isalpha() and t.isupper()]
    if caps:
        primary = min(caps, key=len)
        secondary = s if s != primary else ""
        return primary, secondary

    # Last resort: show shortened mint later; here just echo
    return s, ""

# ---------- PRETTY ROW (no code block, no copy bar) ----------
def _fmt_pct_cell(pct: float | None) -> str:
    if pct is None:
        return "n/a"
    arrow = "ðŸŸ¢â–²" if pct >= 0 else "ðŸ”´â–¼"
    # keep two spaces after colon for a tidy look in proportional font
    return f"{arrow} {pct:+.2f}%"

def render_about_list(mint: str, price: float, source: str, name_str: str, tf: dict) -> str:
    primary, secondary = split_primary_secondary(name_str)
    short = f"{mint[:4]}..{mint[-4:]}"
    lines = [
        "*Info*",
        f"Mint: {primary or short}",
    ]
    if secondary and secondary.lower() != (primary or "").lower():
        lines.append(secondary)
    lines.extend([
        f"({short})",
        f"Price: ${price:.6f}",
        f"Source: {source}",
        f"5m:  {_fmt_pct_cell(tf.get('5m'))}",
        f"30m: {_fmt_pct_cell(tf.get('30m'))}",
        f"1h:  {_fmt_pct_cell(tf.get('1h'))}",
        f"6h:  {_fmt_pct_cell(tf.get('6h'))}",
        # 12h intentionally omitted per request
        f"24h: {_fmt_pct_cell(tf.get('24h'))}",
    ])
    return "\n".join(lines)

# ---------- /about handler: USE THE NEW RENDERER ONCE ----------
# In your /about branch, replace the current text-building + sends with:
name_display = resolve_token_name(mint)  # e.g., 'Solana (SOL)' or 'WINGS â€” Wings Stays On'
tf = fetch_timeframes(mint)              # already exists (5m, 30m, 1h, 6h, 24h)
text = render_about_list(mint, price, src, name_display, tf)
tg_send(chat_id, text, preview=True)     # single send; no code block, no copy bar
return {"status": "ok"}                  # and RETURN so it doesn't send twice
