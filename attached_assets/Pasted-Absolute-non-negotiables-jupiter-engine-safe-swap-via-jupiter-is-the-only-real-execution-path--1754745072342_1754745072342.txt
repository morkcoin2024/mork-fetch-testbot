Absolute non-negotiables:

jupiter_engine.safe_swap_via_jupiter() is the only real execution path.

Preflight: is_bonded_and_routable(mint) must pass or abort.

After swap: verify token ATA delta; if zero, mark as failed & alert.

Extensive logging for every step. No silent failures.

Deliverable criteria (acceptance tests at bottom).
Proceed now; create minimal MVP first, then add Pro features.

2) Implementation blueprint (what to build)
A) Jupiter engine (we already gave you this)
Use the Canvas file “jupiter_engine.py (Safe Swap Module)” you already have.

Function exported:

safe_swap_via_jupiter(private_key_b58, output_mint_str, amount_in_sol, slippage_bps=150, min_post_delta_raw=1) -> dict

Guarantees: ATA creation, rent checks, route, swap, confirm, post-trade delta verification.

B) Discovery & checks
discovery.py

get_pumpfun_new(): lightweight pull of latest pump.fun launches (use public feed or HTML/API; for MVP, accept manual /snipe <mint> <sol> too).

is_bonded_and_routable(mint): returns True iff:

token has bonded Raydium pool OR

Jupiter quote exists (route not empty).

risk.py

basic_token_sanity(mint): creator/mint/freeze authority checks; blocklist; min liquidity threshold.

gas_headroom_ok(pubkey): ≥ 0.01 SOL headroom.

C) Database models
models.py (with SQLAlchemy)

User(id, chat_id, created_at)

Wallet(id, user_id, label, pubkey, enc_privkey, created_at)

Position(id, user_id, mint, amount_raw, avg_price_sol, status, created_at, updated_at)

TradeLog(id, user_id, mint, side, sol_amount, sig, status, pre_raw, post_raw, delta_raw, created_at)

Settings(id, user_id, slippage_bps, priority_microlamports, spend_cap_sol, auto_tpsl, stop_loss_pct, take_profit_pct, created_at)

D) Wallet management
wallet.py

Local JSON keystore (per user). Never send keys off-box.

create_wallet(...), import_wallet_from_b58(...), get_wallet(chat_id).

Decrypt into memory only when needed; wipe after.

E) Telegram handlers
handlers/core.py

/start — welcome + brand

/linkwallet — import or create burner; confirm pubkey

/status — SOL balance, emergency stop state, SAFE_MODE

/config — per-user: slippage, priority fee, spend cap; show current

/stop — toggle global emergency stop (admin only)

handlers/trade.py

/snipe <mint> <sol> — single token buy path:

require MORK ≥ holder_min_snipe

preflight: rent headroom, is_bonded_and_routable

run safe_swap_via_jupiter, log TradeLog, verify success

return TX + token delta

/fetch — discovery + buy preset:

require MORK ≥ holder_min_fetch

discover candidates (pump.fun), filter via risk.basic_token_sanity

pick top (or present list) → run same execution path

/sell <mint> <pct> — Jupiter swap token→SOL (mirror of buy)

/positions — show user open positions (simple per-ATA balance read + DB)

Decorator: @require_mork_holder(min_amount)

Reuse your existing SPL balance checker; paramized min.

Guardrails in all trade handlers:

Abort if SAFE_MODE=1.

Abort if emergency stop is on.

Enforce per-user spend_cap_sol (from Settings).

F) Webhook + bot bootstrap
app.py — Flask with /webhook/<token> endpoint (Telegram POST → dispatcher).

bot.py — create Application, register handlers, set webhook.

G) OpenAI (optional, but requested)
Use OpenAI only for narrative/training/tutorial content and trend summarization from internal data you already fetch (e.g., top movers from Dexscreener/CoinGecko APIs).

Do not rely on OpenAI for trading decisions or private key handling.

Commands:

/alpha — summarize “top mover trends” (you feed it token lists + stats).

/howtotrade — short safe trading tutorials in “Mork voice”.

3) Minimal viable code targets (what the agent should ship first)
Working webhook bot with /start, /linkwallet, /status, /config, /stop.

/snipe path using:

is_bonded_and_routable(mint) → if False, abort with guidance

safe_swap_via_jupiter(...) → success requires token delta > 0

TradeLog record creation

/positions that reads token ATAs and SOL balance, shows a clean summary.

/fetch basic version: accept a mint or present 1–3 discovered tokens (manual/hard-coded pull is fine for MVP), run the same checks, execute.

Safety rails: SAFE_MODE, emergency stop, spend caps, MORK-holder gates.

Then: add stop-loss/take-profit worker (timer-based), copy-trade, channel scraper.

4) Acceptance tests (agent must run & pass)
A. Webhook & boot

Hitting /start returns “Mork — Degens’ Best Friend is online.”

/status prints SAFE_MODE, emergency stop, SOL balance if wallet linked.

B. Wallet

/linkwallet can import b58 or create burner; prints public key.

Secrets never leave the process.

C. Snipe (bonded & routable only)

/snipe <mint> 0.02

If not routable: “Not bonded/routable yet — try later.”

If routable: executes swap → returns TX sig + token delta > 0.

D. Guards

With SAFE_MODE=1, /snipe aborts.

With emergency stop on, all trades abort.

If SOL < 0.01 headroom → abort with clear message.

If MORK balance < threshold → abort with gate message.

E. Logs/DB

TradeLog row created per attempt; status reflects success/failure reasons.

5) Prompts/snippets for the agent to generate each file quickly