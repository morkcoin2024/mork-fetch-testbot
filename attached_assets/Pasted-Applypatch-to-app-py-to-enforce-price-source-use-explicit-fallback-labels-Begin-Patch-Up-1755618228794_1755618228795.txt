Applypatch to app.py to enforce price-source use + explicit fallback labels.

*** Begin Patch
*** Update File: app.py
@@
+# --- Price source persistence helpers ---
+PRICE_SOURCE_FILE = "/tmp/mork_price_source"
+
+def _read_price_source():
+    try:
+        s = open(PRICE_SOURCE_FILE, "r").read().strip().lower()
+        return s if s in ("sim", "dex", "birdeye") else "sim"
+    except Exception:
+        return "sim"
+
+def _write_price_source(s: str):
+    try:
+        open(PRICE_SOURCE_FILE, "w").write(s.strip().lower())
+    except Exception:
+        pass
@@
-    # /source (status or set src)
+    # /source (status or set src)
     elif cmd == "/source":
-        # existing logic was here
-        # ensure both status (no arg) and set (sim|dex|birdeye) work
-        ...
+        arg = parts[1].strip().lower() if len(parts) > 1 else ""
+        if arg in ("sim", "dex", "birdeye"):
+            _write_price_source(arg)
+            return ok(f"âœ… Price source set: {arg}")
+        cur = _read_price_source()
+        body = (
+            "ðŸ“Š **Price Sources Status**\n\n"
+            f"**Active:** {cur.capitalize()} Mode\n"
+            f"**Primary:** {cur}\n"
+            "**Fallback:** API sources available\n"
+            "**Status:** âœ… Operational\n\n"
+            "Use `/source sim|dex|birdeye`"
+        )
+        return ok(body)
@@
-    # /price <mint>
+    # /price <mint>
     elif cmd == "/price":
         if len(parts) < 2:
             return usage("/price <mint>")
-        mint = parts[1].strip()
-        # old behavior may have ignored persisted /source or mislabeled fallback
-        # replace with: read persisted source, try primary, then fallback to other live source, then sim
-        ...
+        mint = parts[1].strip()
+        src = _read_price_source()
+        used = None
+        price = None
+        err_notes = []
+
+        # Try primary
+        if src == "birdeye":
+            try:
+                price = _price_from_birdeye(mint)  # must exist in this module
+                used = "birdeye" if price is not None else None
+            except Exception as e:
+                err_notes.append(f"birdeye:{e}")
+        elif src == "dex":
+            try:
+                price = _price_from_dexscreener(mint)  # must exist in this module
+                used = "dex" if price is not None else None
+            except Exception as e:
+                err_notes.append(f"dex:{e}")
+        elif src == "sim":
+            price = _price_sim(mint)  # must exist in this module
+            used = "sim"
+
+        # Fallbacks (only if not sim already)
+        if price is None and src != "dex":
+            try:
+                fx = _price_from_dexscreener(mint)
+                if fx is not None:
+                    price, used = fx, "dex"
+            except Exception as e:
+                err_notes.append(f"dex:{e}")
+        if price is None and src != "birdeye":
+            try:
+                fb = _price_from_birdeye(mint)
+                if fb is not None:
+                    price, used = fb, "birdeye"
+            except Exception as e:
+                err_notes.append(f"birdeye:{e}")
+
+        # Final fallback â†’ sim
+        if price is None:
+            price, used = _price_sim(mint), "sim"
+
+        # Labeling (show fallback path when used != src)
+        if used == src:
+            src_line = f"**Source:** {used}"
+        else:
+            src_line = f"**Source:** {used} (fallback from {src})"
+
+        body = (
+            f"ðŸ’° **Price Lookup:** `{mint[:12]}..`\n\n"
+            f"**Current Price:** ${price:0.6f}\n"
+            f"{src_line}\n"
+        )
+        return ok(body)
*** End Patch
