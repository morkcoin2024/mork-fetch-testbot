def tick(self):
    if not self.running:
        return
    if not BIRDEYE_KEY:
        self.publish("scan.birdeye.error", {"err": "missing BIRDEYE_API_KEY"})
        return

    url = f"{API}/defi/tokenlist"

    def _fetch(params):
        r = httpx.get(url, headers=HEADERS, params=params, timeout=12)
        r.raise_for_status()
        return r.json() or {}

    try:
        # Primary attempt (Birdeye expects createdAt; include chain=solana)
        params = {
            "chain": "solana",
            "sort_by": "createdAt",
            "sort_type": "desc",
            "offset": 0,
            "limit": 50,
        }
        try:
            data = _fetch(params)
        except httpx.HTTPStatusError as e:
            # Fallback if Birdeye tweaks the field name again
            if e.response.status_code == 400 and "sort_by" in e.response.text:
                logging.warning("[SCAN] Birdeye 400 on sort_by=%s, retrying with created_at", params["sort_by"])
                params["sort_by"] = "created_at"
                data = _fetch(params)
            else:
                raise

        # Normalize payload across variants
        items = (
            data.get("data", {}).get("tokens")
            or data.get("data", [])
            or data.get("tokens", [])
            or []
        )

        new_tokens = []
        for it in items:
            mint = it.get("address") or it.get("mint") or it.get("tokenAddress")
            if not mint:
                continue
            if self._mark_seen(mint):
                new_tokens.append({
                    "mint": mint,
                    "symbol": it.get("symbol") or "?",
                    "name": it.get("name") or "?",
                    "price": it.get("priceUsd") or it.get("price") or None,
                })

        if new_tokens:
            self.publish("scan.birdeye.new", {"count": len(new_tokens), "items": new_tokens[:10]})
        logging.info("[SCAN] Birdeye tick ok: %s items, %s new", len(items), len(new_tokens))

    except httpx.HTTPStatusError as e:
        logging.warning(
            "[SCAN] Birdeye status=%s url=%s body=%s",
            e.response.status_code, str(e.request.url), e.response.text[:200]
        )
        self.publish("scan.birdeye.error", {"err": f"HTTP {e.response.status_code}"})
    except Exception as e:
        logging.warning("[SCAN] Birdeye tick error: %s", e)
        self.publish("scan.birdeye.error", {"err": str(e)})
