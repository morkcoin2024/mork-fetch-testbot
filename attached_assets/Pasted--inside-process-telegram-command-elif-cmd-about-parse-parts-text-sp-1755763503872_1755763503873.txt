# --- inside process_telegram_command(...) ---
elif cmd == "/about":
    # parse
    parts = text.split(maxsplit=1)
    if len(parts) < 2:
        return ok("Usage: `/about <mint>`")
    mint = parts[1].strip()

    # source + live price
    src = (_get_current_price_source() or "auto")
    got = get_price(mint, src)
    if not (got and got.get("ok") and got.get("price")):
        return ok(f"Could not fetch price for `{short_mint(mint)}` from `{src}`.")
    price  = float(got["price"])
    source = got.get("source", src)

    # record a point so local windows can exist over time
    try:
        record_price_point(mint, price, source)
    except Exception:
        pass

    # provider timeframes (dexscreener + jupiter merged)
    tf = fetch_timeframes(mint) or {}   # keys among: 5m,1h,6h,24h

    # history windows from our recorder (may be n/a right after boot)
    w30m, _ = window_change(mint,  30*60)
    w12h, _ = window_change(mint, 12*60*60)

    # formatting helpers
    def arrow(v):
        return "ðŸŸ¢â–²" if v is not None and v >= 0 else ("ðŸ”´â–¼" if v is not None else "n/a")
    def pct(v):
        return f"{v:+.2f}%" if v is not None else "n/a"
    def fmt(v):
        return f"{arrow(v)} {pct(v)}" if v is not None else "n/a"

    sym, full = name_line(mint)

    # optional baseline footer
    import time
    try:
        base = _load_alerts_baseline().get(mint)
    except Exception:
        base = None
    base_line = ""
    if base and base.get("ts"):
        base_line = f"\nSince tracking: ${price:.6f} @ {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime(base['ts']))}"

    lines = [
        "*Info*",
        f"Mint: {sym}",
        f"{full}" if full else "",
        f"({short_mint(mint)})",
        f"Price: ${price:.6f}",
        f"Source: {source}",
        "",
        f"5m:  {fmt(tf.get('5m'))}     |   30m: {fmt(w30m)}",
        f"1h:  {fmt(tf.get('1h'))}     |    6h: {fmt(tf.get('6h'))}",
        f"12h: {fmt(w12h)}     |   24h: {fmt(tf.get('24h'))}",
        base_line,
    ]
    return ok("\n".join([s for s in lines if s]))
