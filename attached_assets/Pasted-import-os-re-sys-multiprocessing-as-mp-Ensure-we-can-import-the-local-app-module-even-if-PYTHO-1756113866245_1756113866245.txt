import os, re, sys, multiprocessing as mp

# Ensure we can import the local app module even if PYTHONPATH isn't set
sys.path.insert(0, os.getcwd())
import app  # noqa: E402

CHAT = -1002782542798
ADMIN = 1653046781

# Known good + unknown mints
SOL = "So11111111111111111111111111111111111111112"
UNK = "So11111111111111111111111111111111111111113"

TIMEOUT = float(os.getenv("TEST_TIMEOUT", "8"))

def _worker(cmd, q):
    upd = {
        "message": {
            "message_id": 1,
            "date": 0,
            "chat": {"id": CHAT, "type": "supergroup"},
            "from": {"id": ADMIN, "is_bot": False, "username": "turk"},
            "text": cmd,
        }
    }
    out = app.process_telegram_command(upd) or {}
    q.put(out.get("text") or out.get("response") or "")

def send(cmd, timeout=TIMEOUT):
    q = mp.Queue()
    p = mp.Process(target=_worker, args=(cmd, q), daemon=True)
    p.start()
    p.join(timeout)
    if p.is_alive():
        p.terminate(); p.join(1)
        return "__TIMEOUT__"
    return q.get() if not q.empty() else ""

def rows(s: str):
    return [ln for ln in s.splitlines() if " `" in ln and "—" in ln]

def present(resp: str, short_mint: str) -> bool:
    return f"`{short_mint}`" in resp or short_mint in resp

def shortify(addr: str) -> str:
    # matches UI style like So1111…111112
    return addr[:6] + "…" + addr[-6:]

def ck(ok, msg):
    print(("✅" if ok else "❌"), msg)
    return 0 if ok else 1

fails = 0

# 1) start clean
ack = send("/watch_clear")
fails += ck(bool(ack) and "cleared" in ack.lower(), "watch_clear")

# 2) add two mints
send(f"/watch {SOL}")
send(f"/watch {UNK}")

# verify both present in any mode (use prices)
resp = send("/watchlist prices")
sol_s = shortify(SOL); unk_s = shortify(UNK)
fails += ck("Watchlist" in resp, "header present after add")
fails += ck(present(resp, sol_s), "SOL present after add")
fails += ck(present(resp, unk_s), "UNK present after add")

# 3) remove UNK (support both /watch_remove and /unwatch)
send(f"/watch_remove {UNK}")
resp = send("/watchlist prices")
if present(resp, unk_s):
    send(f"/unwatch {UNK}")
    resp = send("/watchlist prices")
fails += ck(not present(resp, unk_s), "UNK removed")
fails += ck(present(resp, sol_s), "SOL still present after removing UNK")

# 4) idempotent remove (UNK again shouldn't break anything)
send(f"/watch_remove {UNK}")
resp = send("/watchlist prices")
fails += ck(not present(resp, unk_s), "UNK remove idempotent")

# 5) remove SOL (support both commands)
send(f"/watch_remove {SOL}")
resp = send("/watchlist prices")
if present(resp, sol_s):
    send(f"/unwatch {SOL}")
    resp = send("/watchlist prices")
fails += ck(not rows(resp), "watchlist empty after removing SOL")

# 6) removing non-existent mint keeps it empty
send("/watch_remove So11111111111111111111111111111111111111999")
resp = send("/watchlist prices")
fails += ck(not rows(resp), "still empty after removing non-existent")

print("\nPASS" if fails == 0 else f"FAIL({fails})")
sys.exit(0 if fails == 0 else 1)
