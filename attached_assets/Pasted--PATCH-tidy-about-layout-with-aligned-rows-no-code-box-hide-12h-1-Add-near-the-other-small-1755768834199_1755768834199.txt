# PATCH: tidy /about layout with aligned rows (no code box), hide 12h

# 1) Add near the other small helpers:
FIGURE_SPACE = "\u2007"  # fixed-width space that aligns in Telegram UI

def _pad_label(label: str, width: int) -> str:
    """Pad label to fixed width using figure spaces, so arrows line up without code blocks."""
    need = max(0, width - len(label))
    return f"{label}:{FIGURE_SPACE * need}"

def _fmt_pct_cell(pct):
    """Existing helper is fine, keep arrows & colors; just return 'n/a' when pct is None."""
    if pct is None:
        return "n/a"
    try:
        p = float(pct)
    except Exception:
        return "n/a"
    up = "ðŸŸ¢â–²" if p >= 0 else "ðŸ”´â–¼"
    return f"{up} {p:+.2f}%"

def render_about_list(mint: str, price: float, source: str, name_display: str, tf: dict) -> str:
    """
    Pretty, aligned /about output WITHOUT code block.
    Shows primary on 'Mint:', then secondary on next line (if distinct), then short mint.
    Aligns timeframe rows with figure-space padding so emoji arrows start in a column.
    Hides 12h (often unavailable).
    """
    primary = name_display.split(" (", 1)[0].strip() if name_display else ""
    secondary = ""
    short = f"({mint[:4]}..{mint[-4:]})"

    # If resolve_token_name returned like "SOL (Solana)", split primary/secondary
    if "(" in name_display and name_display.endswith(")"):
        # e.g., "SOL (Solana)"
        try:
            p, rest = name_display.split("(", 1)
            primary = p.strip()
            secondary = rest[:-1].strip()
        except Exception:
            pass

    lines = ["*Info*"]
    lines.append(f"Mint: {primary or mint[:4]}")
    if secondary and secondary.lower() != (primary or "").lower():
        lines.append(secondary)
    lines.append(short)
    lines.append(f"Price: ${price:.6f}")
    lines.append(f"Source: {source}")

    # Build aligned timeframe rows (drop 12h)
    order = [("5m", "5m"), ("30m", "30m"), ("1h", "1h"), ("6h", "6h"), ("24h", "24h")]
    # compute label width before colon (5m, 30m, 1h, 6h, 24h)
    maxw = max(len(lbl) for _, lbl in order)

    for key, lbl in order:
        val = _fmt_pct_cell(tf.get(key))
        lines.append(f"{_pad_label(lbl, maxw)}  {val}")

    return "\n".join(lines)

# 2) In process_telegram_command, keep the current /about branch but ensure it calls the renderer above:
# (This is just for clarity; if you already have this call wired, no changes needed.)
# elif cmd == "/about":
#     if len(parts) < 2:
#         tg_send(chat_id, "Usage: /about <mint>", preview=True)
#         return {"status": "error", "err": "missing mint"}
#     mint = parts[1].strip()
#     pr = get_price(mint, CURRENT_PRICE_SOURCE if 'CURRENT_PRICE_SOURCE' in globals() else None) or {}
#     price = float(pr.get("price") or 0.0)
#     src = pr.get("source") or "?"
#     name_display = resolve_token_name(mint) or ""
#     tf = fetch_timeframes(mint) or {}
#     text = render_about_list(mint, price, src, name_display, tf)
#     tg_send(chat_id, text, preview=True)
#     return {"status": "ok"}
