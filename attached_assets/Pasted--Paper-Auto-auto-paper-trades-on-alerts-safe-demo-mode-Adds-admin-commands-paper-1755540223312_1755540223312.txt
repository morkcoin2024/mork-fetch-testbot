# === Paper-Auto: auto paper trades on alerts (safe demo mode) ===
# Adds admin commands:
#   /paper_auto_on [qty]     -> enable with optional per-trade qty (default 0.1)
#   /paper_auto_off          -> disable
#   /paper_auto_status       -> show current setting
#
# Behavior (simple, safe demo):
#   - Watches the AutoSell event stream.
#   - When an "[ALERT]" arrives:
#       * If delta > 0 (up): try to SELL <qty> (only if position > 0).
#       * If delta < 0 (down): BUY <qty>.
#   - Trades are recorded in the paper ledger only (no real orders).
#
# Notes:
#   - Uses existing _EVENTS log; no changes to the main worker loop required.
#   - Thread is lightweight; exits when disabled.

cd /home/runner/workspace

# 1) autosell.py â€” add paper-auto state + watcher thread + event parser
applypatch <<'PATCH'
*** Begin Patch
*** Update File: autosell.py
@@
 import threading, time, random, math, logging
 from collections import deque
@@
 _EVENTS = deque(maxlen=200)   # existing event buffer used by /autosell_logs
 _LEDGER = {"positions": {}, "realized": 0.0}  # mint -> {qty, avg}
 _PRICE_OVERRIDES = {}
+
+# --- Paper-auto state ---
+_PAPER_AUTO = {"enabled": False, "qty": 0.1}
+_PA_THREAD = None
+_PA_STOP = False
+_PA_CURSOR = 0  # index into event stream we've processed
@@
 def _event(msg: str):
     """Append a human-friendly event line to the ring buffer and log it."""
     logging.getLogger(__name__).info(msg)
     _EVENTS.append(msg)
+
+def _pos_qty(mint: str) -> float:
+    p = _LEDGER["positions"].get(mint)
+    return float(p["qty"]) if p else 0.0
+
+def _paper_auto_maybe(mint: str, price: float, direction: str):
+    """direction: 'up' or 'down'."""
+    if not _PAPER_AUTO["enabled"]:
+        return False
+    qty = float(_PAPER_AUTO.get("qty", 0.1))
+    qty = max(0.000001, qty)  # guard
+    try:
+        if direction == "up":
+            # take-profit only if we actually hold some
+            if _pos_qty(mint) > 0:
+                ledger_sell(mint, qty, price, source="auto")
+                _event(f"[AUTO] paper SELL {mint} qty={qty} px={price:.6f}")
+                return True
+            return False
+        else:  # 'down' -> buy (average down demo)
+            ledger_buy(mint, qty, price, source="auto")
+            _event(f"[AUTO] paper BUY {mint} qty={qty} px={price:.6f}")
+            return True
+    except Exception as e:
+        _event(f"[AUTO] error {mint} dir={direction} err={e}")
+        return False
+
+def _parse_alert_event(e: str):
+    """
+    Parse an '[ALERT]' multi-line entry produced by the worker.
+    Expected shape (examples seen in logs):
+      '... [ALERT]\\n<mint> +2.62%\\nprice=0.735307 src=sim\\nref=...'
+    Returns (mint, price, direction) or None.
+    """
+    import re
+    if "[ALERT]" not in e:
+        return None
+    m_mint = re.search(r"\[ALERT\]\s*\n([^\s]+)\s+([+\-]?\d+(?:\.\d+)?)%", e)
+    m_px   = re.search(r"price=([0-9]+(?:\.[0-9]+)?)", e)
+    if not m_mint or not m_px:
+        return None
+    mint = m_mint.group(1)
+    delta = float(m_mint.group(2))
+    price = float(m_px.group(1))
+    direction = "up" if delta > 0 else "down"
+    return mint, price, direction
+
+def _paper_auto_loop():
+    global _PA_CURSOR
+    logger = logging.getLogger(__name__)
+    logger.info("[PAPER-AUTO] watcher started (qty=%s)", _PAPER_AUTO.get("qty"))
+    # start from the tail
+    _PA_CURSOR = len(_EVENTS)
+    while not _PA_STOP and _PAPER_AUTO["enabled"]:
+        try:
+            # sweep new events
+            while _PA_CURSOR < len(_EVENTS):
+                e = _EVENTS[_PA_CURSOR]
+                _PA_CURSOR += 1
+                parsed = _parse_alert_event(e)
+                if parsed:
+                    mint, price, direction = parsed
+                    _paper_auto_maybe(mint, price, direction)
+        except Exception as ex:
+            logger.warning("[PAPER-AUTO] loop error: %s", ex)
+        time.sleep(0.5)
+    logger.info("[PAPER-AUTO] watcher stopped")
+
+def paper_auto_enable(qty: float | None = None):
+    """Enable paper-auto watcher with optional qty per auto trade."""
+    global _PA_THREAD, _PA_STOP
+    if qty is not None:
+        try:
+            q = float(qty)
+            if q > 0:
+                _PAPER_AUTO["qty"] = q
+        except Exception:
+            pass
+    _PAPER_AUTO["enabled"] = True
+    _PA_STOP = False
+    if _PA_THREAD is None or not _PA_THREAD.is_alive():
+        _PA_THREAD = threading.Thread(target=_paper_auto_loop, daemon=True)
+        _PA_THREAD.start()
+    _event(f"[AUTO] paper-auto ENABLED qty={_PAPER_AUTO['qty']}")
+    return True
+
+def paper_auto_disable():
+    global _PA_STOP
+    _PAPER_AUTO["enabled"] = False
+    _PA_STOP = True
+    _event("[AUTO] paper-auto DISABLED")
+    return True
+
+def paper_auto_status():
+    return {"enabled": _PAPER_AUTO["enabled"], "qty": _PAPER_AUTO["qty"]}
*** End Patch
PATCH

# 2) app.py â€” add admin commands for paper-auto
applypatch <<'PATCH'
*** Begin Patch
*** Update File: app.py
@@
             "/watch", "/unwatch", "/watchlist", "/watch_sens",
             "/paper_buy", "/paper_sell", "/ledger", "/ledger_reset",
-            "/ledger_pnl", "/paper_setprice", "/paper_clearprice", "/ledger_pnl_csv"
+            "/ledger_pnl", "/paper_setprice", "/paper_clearprice", "/ledger_pnl_csv",
+            "/paper_auto_on", "/paper_auto_off", "/paper_auto_status"
         ]
@@
         elif cmd == "/ledger_pnl_csv":
             deny = _require_admin(user)
             if deny: return deny
             import autosell
             csv = autosell.ledger_mark_to_market_csv()
             return _reply("```\n" + csv + "\n```")
+
+        elif cmd == "/paper_auto_on":
+            deny = _require_admin(user)
+            if deny: return deny
+            import autosell
+            q = None
+            if args:
+                try: q = float(args.strip())
+                except: pass
+            autosell.paper_auto_enable(q)
+            st = autosell.paper_auto_status()
+            return _reply(f"ðŸ¤– paper-auto ENABLED qty={st['qty']}")
+
+        elif cmd == "/paper_auto_off":
+            deny = _require_admin(user)
+            if deny: return deny
+            import autosell
+            autosell.paper_auto_disable()
+            return _reply("ðŸ¤– paper-auto DISABLED")
+
+        elif cmd == "/paper_auto_status":
+            deny = _require_admin(user)
+            if deny: return deny
+            import autosell
+            st = autosell.paper_auto_status()
+            return _reply(f"ðŸ¤– paper-auto status: enabled={st['enabled']} qty={st['qty']}")
*** End Patch
PATCH

# 3) Router smoke test (wiring)
python3 - <<'PY'
from app import process_telegram_command
def mk(text):
    upd={'message':{'message_id':1,'date':0,'chat':{'id':1,'type':'private'},
                    'from':{'id':1,'is_bot':False,'username':'test'},'text':text}}
    out=process_telegram_command(upd) or {}
    print(text, "->", out.get("status"), (out.get("response") or "")[:120].replace("\n"," "))
for t in ["/paper_auto_status","/paper_auto_on 0.1","/paper_auto_off"]:
    mk(t)
PY
