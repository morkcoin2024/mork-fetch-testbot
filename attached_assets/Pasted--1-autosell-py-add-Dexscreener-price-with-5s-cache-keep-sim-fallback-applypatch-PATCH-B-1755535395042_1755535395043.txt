# 1) autosell.py ‚Äî add Dexscreener price with 5s cache, keep sim fallback
applypatch <<'PATCH'
*** Begin Patch
*** Update File: autosell.py
@@
-import threading, time, logging, os, json, math, hashlib, collections
+import threading, time, logging, os, json, math, hashlib, collections, requests
@@
 _EVENTS = collections.deque(maxlen=100)  # rolling log of dry-run decisions
+_PX_CACHE = {}  # mint -> (ts, price)
+_PX_TTL   = int(os.environ.get("FETCH_PRICE_TTL_SEC", "5"))
@@
 def _get_price(mint:str):
-    """Return (price, source) or (None, None). Hook up real scanners later."""
-    # TODO: integrate dexscreener/birdeye read-only; for now return None to use sim
-    return None, None
+    """Return (price, source) or (None, None). Uses short cache + Dexscreener; falls back to sim in caller."""
+    now = time.time()
+    m = (mint or "").strip()
+    if not m:
+        return None, None
+    # cache
+    ent = _PX_CACHE.get(m.lower())
+    if ent and (now - ent[0]) <= _PX_TTL:
+        return ent[1], "dex(cache)"
+    # fetch fresh
+    p = _dex_price(m)
+    if p is not None:
+        _PX_CACHE[m.lower()] = (now, float(p))
+        return float(p), "dex"
+    return None, None
+
+def _dex_price(mint:str):
+    """Dexscreener public API ‚Äì best-effort USD price."""
+    url = f"https://api.dexscreener.com/latest/dex/tokens/{mint}"
+    try:
+        r = requests.get(url, timeout=8)
+        if r.status_code != 200:
+            return None
+        j = r.json() or {}
+        pairs = j.get("pairs") or []
+        if not pairs:
+            return None
+        # choose the pair with highest liquidityUsd, else first with priceUsd
+        pairs = [p for p in pairs if p.get("priceUsd")]
+        if not pairs:
+            return None
+        best = max(pairs, key=lambda p: float(p.get("liquidity", {}).get("usd") or 0.0))
+        return float(best["priceUsd"])
+    except Exception:
+        return None
*** End Patch
PATCH

# 2) app.py ‚Äî add public /price command (MarkdownV2-safe via tg_send already)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: app.py
@@
-        public_commands = ["/help", "/ping", "/info", "/test123", "/commands", "/debug_cmd", "/status", "/uptime", "/version"]
+        public_commands = ["/help", "/ping", "/info", "/test123", "/commands", "/debug_cmd", "/status", "/uptime", "/version", "/price"]
@@
+        elif cmd == "/price":
+            # public: /price <mint>
+            a = (args or "").strip()
+            if not a:
+                return _reply("Usage: /price <mint>")
+            try:
+                import autosell
+                px, src = autosell._get_price(a)
+                if px is None:
+                    # show simulated so users get *some* answer
+                    spx = autosell._sim_price(a)
+                    return _reply(f"üìà {a}\nprice: ~${spx:.6f} (sim)\nsource: none (fallback to simulator)")
+                return _reply(f"üìà {a}\nprice: ${px:.6f}\nsource: {src}")
+            except Exception as e:
+                return _reply(f"‚ö†Ô∏è Price lookup failed: {e}")
*** End Patch
PATCH

# 3) Quick smoke (local)
python3 - <<'PY'
from app import process_telegram_command
def mk(t):
    upd={'message':{'message_id':1,'date':0,'chat':{'id':1,'type':'private'},'from':{'id':1,'is_bot':False,'username':'x'},'text':t}}
    out=process_telegram_command(upd) or {}
    print(f"{t:18} -> {out.get('status')} | {(out.get('response') or '')[:90].replace('\n',' ')}")
for t in ["/price MINT1","/autosell_dryrun MINT1"]:
    mk(t)
PY

# 4) Hot-reload and test in Telegram (DM)
# /price <your real mint address>
# /autosell_dryrun <same mint>
# /autosell_logs 10
