# === Add Discord alert mirror (optional) ===
# New commands:
#   /discord_set <webhook-url>   (set in DM with the bot)
#   /discord_clear               (remove the webhook)
#   /discord_test <text>         (send test to Discord)
#
# Mirrors any alert (after mute/threshold/rate checks) to the configured Discord webhook.

cd /home/runner/workspace

applypatch <<'PATCH'
*** Begin Patch
*** Update File: app.py
@@
-import json, re, time, traceback
+import json, re, time, traceback, os
+try:
+    import requests
+except Exception:  # very defensive
+    requests = None
@@
-        try:
-            with open(_ALERT_CFG_PATH, "r") as f:
-                _ALERT_CFG = json.load(f)
-        except Exception:
-            _ALERT_CFG = {"chat_id": None, "min_move_pct": 0.0, "rate_per_min": 60, "muted_until": 0}
+        try:
+            with open(_ALERT_CFG_PATH, "r") as f:
+                _ALERT_CFG = json.load(f)
+        except Exception:
+            _ALERT_CFG = {
+                "chat_id": None,
+                "min_move_pct": 0.0,
+                "rate_per_min": 60,
+                "muted_until": 0,
+                "discord_webhook": None,
+            }
@@
-            mu = float(_ALERT_CFG.get("muted_until", 0) or 0)
+            mu = float(_ALERT_CFG.get("muted_until", 0) or 0)
             remaining = max(0, int(mu - time.time()))
-            return _reply(
+            return _reply(
                 "ðŸ“Ÿ Alerts settings:\n"
                 f"chat: {cid if cid else 'not set'}\n"
                 f"min_move_pct: { _ALERT_CFG.get('min_move_pct', 0.0) }%\n"
-                f"rate_per_min: { _ALERT_CFG.get('rate_per_min', 60) }\n"
-                f"muted: {'yes' if remaining>0 else 'no'}"
+                f"rate_per_min: { _ALERT_CFG.get('rate_per_min', 60) }\n"
+                f"muted: {'yes' if remaining>0 else 'no'}"
                 + (f" ({remaining}s left)" if remaining>0 else "")
+                + "\n"
+                + f"discord: {'set' if (_ALERT_CFG.get('discord_webhook') or os.getenv('DISCORD_WEBHOOK_URL')) else 'not set'}"
             )
@@
             def _notify_line(txt: str):
                 cid = _ALERT_CFG.get("chat_id")
                 if cid:
-                    # mute check
+                    # mute check
                     import time, re
                     if float(_ALERT_CFG.get("muted_until", 0) or 0) > time.time():
                         return
                     # threshold filter â€” look for Â±X.XX%
                     m = re.search(r'([+-]?\d+(?:\.\d+)?)%', txt)
                     if m:
                         try:
                             move = abs(float(m.group(1)))
                             if move < float(_ALERT_CFG.get("min_move_pct", 0.0)):
                                 return  # below threshold
                         except Exception:
                             pass
                     # rate limiting
                     nonlocal _ALERT_LAST_SENT
                     now = time.time()
                     min_interval = max(1.0, 60.0 / float(_ALERT_CFG.get("rate_per_min", 60) or 60))
                     if now - _ALERT_LAST_SENT < min_interval:
                         return
                     _ALERT_LAST_SENT = now
                     tg_send(cid, txt, preview=True)
+                    # Discord mirror (best-effort; won't raise)
+                    try:
+                        _discord_send(txt)
+                    except Exception:
+                        pass
+
+        # --- Discord helper & commands ---
+        def _discord_send(text: str):
+            url = (_ALERT_CFG.get("discord_webhook")
+                   or os.getenv("DISCORD_WEBHOOK_URL"))
+            if not url or not requests:
+                return {"ok": False, "reason": "no_webhook_or_requests"}
+            try:
+                r = requests.post(url, json={"content": text}, timeout=8)
+                return {"ok": r.status_code in (200, 204), "status": r.status_code}
+            except Exception as e:
+                return {"ok": False, "error": str(e)}
@@
         elif cmd == "/alerts_unmute":
             deny = _require_admin(user)
             if deny: return deny
             _ALERT_CFG["muted_until"] = 0
             try:
                 with open(_ALERT_CFG_PATH, "w") as f: json.dump(_ALERT_CFG, f)
             except Exception: pass
             return _reply("ðŸ”” Alerts unmuted")
+
+        elif cmd == "/discord_set":
+            deny = _require_admin(user)
+            if deny: return deny
+            if not args:
+                return _reply("Usage: /discord_set <webhook-url> (send this in DM, not group)")
+            _ALERT_CFG["discord_webhook"] = args.strip()
+            try:
+                with open(_ALERT_CFG_PATH, "w") as f: json.dump(_ALERT_CFG, f)
+            except Exception: pass
+            ok = _discord_send("âœ… Discord webhook set (test)")
+            return _reply(f"âœ… Discord set: {bool(ok.get('ok'))}")
+
+        elif cmd == "/discord_clear":
+            deny = _require_admin(user)
+            if deny: return deny
+            _ALERT_CFG["discord_webhook"] = None
+            try:
+                with open(_ALERT_CFG_PATH, "w") as f: json.dump(_ALERT_CFG, f)
+            except Exception: pass
+            return _reply("ðŸ§¹ Discord webhook cleared")
+
+        elif cmd == "/discord_test":
+            deny = _require_admin(user)
+            if deny: return deny
+            msg = args.strip() or "test"
+            ok = _discord_send(f"[TEST] {msg}")
+            return _reply(f"ðŸ“¤ Discord test sent: {bool(ok.get('ok'))}")
*** End Patch
PATCH

# Quick smoke test (local function calls)
python3 - <<'PY'
from app import process_telegram_command
def run(t):
    upd={'message':{'message_id':1,'date':0,'chat':{'id':1,'type':'private'},
                    'from':{'id':1,'is_bot':False,'username':'admin'},'text':t}}
    out = process_telegram_command(upd) or {}
    print(t, "->", out.get("status"), (out.get("response") or "")[:120].replace("\n"," "))
for t in ["/alerts_settings","/discord_clear","/alerts_settings"]:
    run(t)
PY
