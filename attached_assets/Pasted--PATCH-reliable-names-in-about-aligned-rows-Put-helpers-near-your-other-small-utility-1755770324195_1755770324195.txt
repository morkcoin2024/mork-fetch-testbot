# === PATCH: reliable names in /about + aligned rows ===
# Put helpers near your other small utility functions.

import json, re

FIGURE_SPACE = "\u2007"  # fixed-width space that aligns in Telegram

def _fmt_pct_cell(pct):
    if pct is None:
        return "n/a"
    try:
        p = float(pct)
    except Exception:
        return "n/a"
    up = "ðŸŸ¢â–²" if p >= 0 else "ðŸ”´â–¼"
    return f"{up} {p:+.2f}%"

def _split_primary_secondary(name: str):
    """Extract ticker (primary) + long name (secondary) from a single string."""
    if not name:
        return "", ""
    s = name.strip()

    # 'Solana (SOL)' -> secondary='Solana', primary='SOL'
    m = re.match(r"^([^(]+?)\s*\(\s*([A-Z0-9]{2,12})\s*\)$", s)
    if m:
        return (m.group(2).strip(), m.group(1).strip())

    # 'SOL â€” Solana' or 'SOL - Solana'
    m = re.match(r"^([A-Z0-9]{2,12})\s*[â€”-]\s*(.+)$", s)
    if m:
        return (m.group(1).strip(), m.group(2).strip())

    # Just a ticker
    if re.fullmatch(r"[A-Z0-9]{2,12}", s):
        return (s, "")

    # Last resort: treat whole string as primary
    return (s, "")

def _cached_primary_secondary(mint: str):
    """Read token_names.json; support both old ('name') and new ('primary'/'secondary') shapes."""
    try:
        data = json.load(open("token_names.json"))
        entry = data.get(mint) or {}
        if isinstance(entry, dict):
            p = entry.get("primary")
            s = entry.get("secondary")
            if p or s:
                return (p or "", s or "")
            n = entry.get("name")
            if n:
                return _split_primary_secondary(n)
    except Exception:
        pass
    return ("", "")

def _label_block(lbl: str, width: int = 4) -> str:
    """Produce aligned 'LBL:' using figure spaces so arrows line up."""
    pad = max(0, width - len(lbl))
    return f"{lbl}:{FIGURE_SPACE * pad}"

def render_about_list(mint: str, price: float, source: str, name_display: str, tf: dict) -> str:
    """
    Pretty, aligned /about output (no code block).
    Always prefers cache primary/secondary; falls back to resolve_token_name/name_display.
    """
    # Prefer cache first
    primary, secondary = _cached_primary_secondary(mint)

    # If cache empty, use provided name and try to split
    if not (primary or secondary):
        pr2, sc2 = _split_primary_secondary(name_display or "")
        primary, secondary = (pr2 or primary), (sc2 or secondary)

    # If STILL empty, attempt a fresh resolve (may still be short mint)
    if not (primary or secondary):
        try:
            from app import resolve_token_name
            nm = resolve_token_name(mint) or ""
            pr3, sc3 = _split_primary_secondary(nm)
            primary, secondary = (pr3 or primary), (sc3 or secondary)
        except Exception:
            pass

    short = f"({mint[:4]}..{mint[-4:]})"

    lines = ["*Info*"]
    lines.append(f"Mint: {primary or mint[:4]}")
    if secondary and secondary.lower() != (primary or "").lower():
        lines.append(secondary)
    lines.append(short)
    lines.append(f"Price: ${price:.6f}")
    lines.append(f"Source: {source}")

    # Timeframes (omit 12h)
    for key in ["5m", "30m", "1h", "6h", "24h"]:
        lines.append(f"{_label_block(key)} { _fmt_pct_cell(tf.get(key)) }")

    return "\n".join(lines)

# ---- Ensure the /about branch uses render_about_list exactly once ----
# Replace the /about handler body with this:

# elif cmd == "/about":
#     if len(parts) < 2:
#         tg_send(chat_id, "Usage: /about <mint>", preview=True)
#         return {"status": "error", "err": "missing mint"}
#     mint = parts[1].strip()
#     pr = get_price(mint, CURRENT_PRICE_SOURCE if 'CURRENT_PRICE_SOURCE' in globals() else None) or {}
#     price = float(pr.get("price") or 0.0)
#     src = pr.get("source") or "?"
#     try:
#         from app import resolve_token_name
#         name_display = resolve_token_name(mint) or ""
#     except Exception:
#         name_display = ""
#     tf = fetch_timeframes(mint) or {}
#     tg_send(chat_id, render_about_list(mint, price, src, name_display, tf), preview=True)
#     return {"status": "ok"}
