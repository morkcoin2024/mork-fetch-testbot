# --- [A] imports (near other imports at top of app.py) ---
from pathlib import Path
import json, base58, os, time
try:
    from solders.pubkey import Pubkey  # solana-py 0.30+
except Exception:
    Pubkey = None
try:
    from solana.rpc.api import Client
except Exception:
    Client = None

# Access the global BUS if present (used by /bus_test)
try:
    BUS  # noqa
except NameError:
    BUS = None

# --- [B] wallet storage + helpers (place with other module-level helpers) ---
_WALLET_DB = Path("data/wallets.json")
_WALLET_DB.parent.mkdir(parents=True, exist_ok=True)

def _walletdb_load():
    if _WALLET_DB.exists():
        try:
            return json.loads(_WALLET_DB.read_text())
        except Exception:
            return {}
    return {}

def _walletdb_save(data: dict):
    _WALLET_DB.write_text(json.dumps(data, indent=2))

def _get_user_wallet(uid: int):
    db = _walletdb_load()
    w = db.get(str(uid))
    return w

def _create_user_wallet(uid: int):
    """
    Minimal burner wallet generator using os.urandom + base58.
    (If you already have a wallet module, you can swap this out to call it.)
    """
    db = _walletdb_load()
    if str(uid) in db:
        return db[str(uid)]
    # 32-byte secret key -> base58
    sk = os.urandom(32)
    sk58 = base58.b58encode(sk).decode()
    # very light address derivation if solders is available; otherwise store 'unknown'
    if Pubkey is not None:
        try:
            # This is a placeholder burner's pubkey derivation only if you have seed->key available.
            # If you use a proper Keypair lib elsewhere, prefer that and return its public key.
            # Here we just mark "unknown" to avoid pretending to sign.
            addr = "unknown"
        except Exception:
            addr = "unknown"
    else:
        addr = "unknown"
    db[str(uid)] = {"addr": addr, "sk58": sk58, "created_at": int(time.time())}
    _walletdb_save(db)
    return db[str(uid)]

def _sol_client():
    url = os.getenv("SOLANA_RPC", "https://api.mainnet-beta.solana.com")
    return Client(url) if Client is not None else None

def _format_plain(text: str) -> str:
    # Avoid Telegram markdown parse glitches -> send as plain text
    return text

# --- [C] command handlers (place near other command helpers) ---
def handle_wallet_new(user_id: int):
    w = _get_user_wallet(user_id) or _create_user_wallet(user_id)
    # Never show secret in chat; only indicate it exists.
    lines = [
        "Wallet created (or already exists).",
        f"Address: {w.get('addr', 'unknown')}",
        "Secret key: stored securely (not displayed here).",
        "NOTE: This is a burner wallet for testing. Move funds at your own risk."
    ]
    return _format_plain("\n".join(lines))

def handle_wallet_addr(user_id: int):
    w = _get_user_wallet(user_id)
    if not w:
        w = _create_user_wallet(user_id)
    return _format_plain(f"Your wallet address: {w.get('addr', 'unknown')}")

def handle_wallet_balance(user_id: int):
    w = _get_user_wallet(user_id)
    if not w:
        return _format_plain("No wallet yet. Use /wallet_new first.")
    cli = _sol_client()
    if not cli:
        return _format_plain("RPC client unavailable in this environment.")
    try:
        if w.get("addr") in (None, "unknown"):
            return _format_plain("Address unavailable for this burner wallet build.")
        resp = cli.get_balance(w["addr"])
        lamports = resp["result"]["value"]
        sol = lamports / 1_000_000_000
        return _format_plain(f"Balance for {w['addr']}: {sol:.9f} SOL")
    except Exception as e:
        return _format_plain(f"Balance lookup failed: {e}")

def handle_bus_test():
    if not BUS:
        return _format_plain("Event bus not available.")
    payload = {
        "source": "synthetic",
        "symbol": "TEST",
        "name": "Synthetic Token",
        "mint": "TestMint11111111111111111111111111111111111",
        "holders": 123,
        "mcap_usd": 123456,
        "liquidity_usd": 98765,
        "age_min": 1.2,
        "risk": 12.3,
        "links": {}
    }
    try:
        BUS.publish("NEW_TOKEN", payload)
        return _format_plain("Published synthetic NEW_TOKEN event.")
    except Exception as e:
        return _format_plain(f"Bus publish failed: {e}")

# --- [D] webhook routing (add inside your main text routing block) ---
# Example inside your big `if text.strip().startswith(...)` chain:
elif text.strip().startswith("/wallet_new"):
    response_text = handle_wallet_new(chat_id)
    # send as plain text to avoid markdown issues with underscores
    _reply(response_text, parse_mode=None, no_preview=True)

elif text.strip().startswith("/wallet_addr"):
    response_text = handle_wallet_addr(chat_id)
    _reply(response_text, parse_mode=None, no_preview=True)

elif text.strip().startswith("/wallet_balance"):
    response_text = handle_wallet_balance(chat_id)
    _reply(response_text, parse_mode=None, no_preview=True)

elif text.strip().startswith("/bus_test"):
    response_text = handle_bus_test()
    _reply(response_text, parse_mode=None, no_preview=True)